 Percent |	Source code & Disassembly of minisat_HACK_999ED_CSSC_static for cycles:u (2 samples, percent: local period)
---------------------------------------------------------------------------------------------------------------------------
         :
         :
         :
         : 3      Disassembly of section .text:
         :
         : 5      000000000040efe0 <Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&)>:
         : 6      |        rest of literals. There may be others from the same level though.
         : 7      |
         : 8      |________________________________________________________________________________________________@*/
         : 9      #define LBD(C)   N++; for (L = i = 0; i < C.size(); i++) if ((l = level(var(C[i]))) != 0 && m[l] != N) m[l] = N, L++;
         : 10     void Solver::analyze(CRef confl, vec<Lit>& out_learnt, int& out_btlevel)
         : 11     {
    0.00 :   40efe0: endbr64
    0.00 :   40efe4: push   %r15
    0.00 :   40efe6: mov    %rdi,%r15
    0.00 :   40efe9: push   %r14
    0.00 :   40efeb: push   %r13
    0.00 :   40efed: push   %r12
    0.00 :   40efef: push   %rbp
    0.00 :   40eff0: mov    %esi,%ebp
    0.00 :   40eff2: push   %rbx
    0.00 :   40eff3: sub    $0x38,%rsp
         : 22     void     growTo   (int size);
         : 23     void     growTo   (int size, const T& pad);
         : 24     void     clear    (bool dealloc = false);
         :
         : 26     // Stack interface:
         : 27     void     push  (void)              { if (sz == cap) capacity(sz+1); new (&data[sz]) T(); sz++; }
    0.00 :   40eff7: mov    0x8(%rdx),%eax
    0.00 :   40effa: mov    %rdx,0x8(%rsp)
    0.00 :   40efff: mov    %rcx,0x28(%rsp)
    0.00 :   40f004: cmp    0xc(%rdx),%eax
    0.00 :   40f007: je     40fa5c <Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&)+0xa7c>
    0.00 :   40f00d: mov    0x8(%rsp),%rbx
    0.00 :   40f012: movslq %eax,%rcx
    0.00 :   40f015: add    $0x1,%eax
         : 36     int pathC = 0;
    0.00 :   40f018: movl   $0x0,0x4(%rsp)
    0.00 :   40f020: movapd 0xe1478(%rip),%xmm2        # 4f04a0 <typeinfo name for Minisat::Solver+0x100>
    0.00 :   40f028: mov    (%rbx),%rdx
    0.00 :   40f02b: movl   $0x0,(%rdx,%rcx,4)
    0.00 :   40f032: mov    %eax,0x8(%rbx)
         : 42     Lit p     = lit_Undef;
         :
         : 44     // Generate conflict clause:
         : 45     //
         : 46     out_learnt.push();      // (leave room for the asserting literal)
         : 47     int index   = trail.size() - 1;
    0.00 :   40f035: mov    0x1e8(%r15),%eax
         : 49     Lit p     = lit_Undef;
    0.00 :   40f03c: mov    $0xfffffffe,%ebx
         : 51     int index   = trail.size() - 1;
    0.00 :   40f041: lea    -0x1(%rax),%r14d
    0.00 :   40f045: mov    %r15,%rax
    0.00 :   40f048: mov    %r14d,%r15d
    0.00 :   40f04b: mov    %rax,%r14
    0.00 :   40f04e: xchg   %ax,%ax
         :
         : 58     Ref      alloc     (int size);
         : 59     void     free      (int size)    { wasted_ += size; }
         :
         : 61     // Deref, Load Effective Address (LEA), Inverse of LEA (AEL):
         : 62     T&       operator[](Ref r)       { assert(r >= 0 && r < sz); return memory[r]; }
    0.00 :   40f050: mov    0x308(%r14),%rcx
    0.00 :   40f057: mov    %ebp,%eax
    0.00 :   40f059: lea    (%rcx,%rax,4),%r13
         : 66     for (int i = 0; i < size(); i++)
         : 67     abstraction |= 1 << (var(data[i].lit) & 31);
         : 68     data[header.size].abs = abstraction;  }
         :
         :
         : 71     int          size        ()      const   { return header.size; }
    0.00 :   40f05d: mov    0x0(%r13),%esi
         : 73     void         shrink      (int i)         { assert(i <= size()); if (header.has_extra) data[header.size-i] = data[header.size]; header.size -= i; }
         : 74     void         pop         ()              { shrink(1); }
         : 75     bool         learnt      ()      const   { return header.learnt; }
    0.00 :   40f061: movzbl 0x0(%r13),%eax
         : 77     int          size        ()      const   { return header.size; }
    0.00 :   40f066: shr    $0x5,%esi
         :
         : 80     do{
         : 81     assert(confl != CRef_Undef); // (otherwise should be UIP)
         : 82     Clause& c = ca[confl];
         :
         : 84     if (c.learnt() && c.mark() != 3){
    0.00 :   40f069: test   $0x4,%al
    0.00 :   40f06b: je     40f078 <Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&)+0x98>
         : 87     bool         has_extra   ()      const   { return header.has_extra; }
         : 88     uint32_t     mark        ()      const   { return header.mark; }
    0.00 :   40f06d: and    $0x3,%eax
    0.00 :   40f070: cmp    $0x3,%al
    0.00 :   40f072: jne    40f518 <Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&)+0x538>
         :
         : 93     claBumpActivity(c);
         : 94     }/*auto*/
         : 95     }
         :
         : 97     for (int j = (p == lit_Undef) ? 0 : 1; j < c.size(); j++){
    0.00 :   40f078: cmp    $0xfffffffe,%ebx
         : 99     const T& last  (void) const        { return data[sz-1]; }
         : 100    T&       last  (void)              { return data[sz-1]; }
         :
         : 102    // Vector interface:
         : 103    const T& operator [] (int index) const { return data[index]; }
         : 104    T&       operator [] (int index)       { return data[index]; }
    0.00 :   40f07b: mov    0x320(%r14),%rdx
         : 106    const T& operator [] (int index) const { return data[index]; }
    0.00 :   40f082: mov    0x200(%r14),%r8
    0.00 :   40f089: setne  %al
    0.00 :   40f08c: setne  %cl
    0.00 :   40f08f: movzbl %al,%eax
    0.00 :   40f092: cmp    %esi,%eax
    0.00 :   40f094: jae    40f3f5 <Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&)+0x415>
         : 113    inline void Solver::varBumpActivity(Var v) { varBumpActivity(v, var_inc); }
         : 114    inline void Solver::varBumpActivity(Var v, double inc) {
         : 115    if ( (activity[v] += inc) > 1e100 ) {
         : 116    // Rescale:
         : 117    for (int i = 0; i < nVars(); i++)
         : 118    activity[i] *= 1e-100;
    0.00 :   40f09a: mov    %r15d,0x10(%rsp)
         : 120    if ( (activity[v] += inc) > 1e100 ) {
    0.00 :   40f09f: movsd  0xe1341(%rip),%xmm3        # 4f03e8 <typeinfo name for Minisat::Solver+0x48>
    0.00 :   40f0a7: movzbl %cl,%r12d
         : 123    activity[i] *= 1e-100;
    0.00 :   40f0ab: mov    %r13,%r15
    0.00 :   40f0ae: jmp    40f0bd <Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&)+0xdd>
    0.00 :   40f0b0: add    $0x1,%r12
    0.00 :   40f0b4: cmp    %r12d,%esi
    0.00 :   40f0b7: jle    40f3f0 <Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&)+0x410>
         : 129    Lit q = c[j];
    0.00 :   40f0bd: mov    0x4(%r15,%r12,4),%ebx
         : 131    inline  int  var       (Lit p)              { return p.x >> 1; }
   48.86 :   40f0c2: mov    %ebx,%ecx
    0.00 :   40f0c4: sar    %ecx
         : 134    T&       operator [] (int index)       { return data[index]; }
    0.00 :   40f0c6: movslq %ecx,%rax
    0.00 :   40f0c9: lea    (%rdx,%rax,1),%rdi
         :
         : 138    if (!seen[var(q)] && level(var(q)) > 0){
    0.00 :   40f0cd: cmpb   $0x0,(%rdi)
    0.00 :   40f0d0: jne    40f0b0 <Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&)+0xd0>
    0.00 :   40f0d2: mov    0x4(%r8,%rax,8),%r13d
         : 142    const T& operator [] (int index) const { return data[index]; }
    0.00 :   40f0d7: lea    0x0(,%rax,8),%rbp
    0.00 :   40f0df: test   %r13d,%r13d
    0.00 :   40f0e2: jle    40f0b0 <Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&)+0xd0>
         : 146    if ( (activity[v] += inc) > 1e100 ) {
    0.00 :   40f0e4: movsd  0x170(%r14),%xmm0
         : 148    T&       operator [] (int index)       { return data[index]; }
    0.00 :   40f0ed: mov    0x160(%r14),%rsi
    0.00 :   40f0f4: lea    (%rsi,%rbp,1),%rdx
    0.00 :   40f0f8: addsd  (%rdx),%xmm0
    0.00 :   40f0fc: comisd %xmm3,%xmm0
    0.00 :   40f100: movsd  %xmm0,(%rdx)
    0.00 :   40f104: jbe    40f196 <Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&)+0x1b6>
         : 155    int      size     (void) const     { return sz; }
    0.00 :   40f10a: mov    0x208(%r14),%r8d
         : 157    for (int i = 0; i < nVars(); i++)
    0.00 :   40f111: test   %r8d,%r8d
    0.00 :   40f114: jle    40f6e8 <Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&)+0x708>
    0.00 :   40f11a: cmp    $0x1,%r8d
    0.00 :   40f11e: je     40f6f5 <Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&)+0x715>
    0.00 :   40f124: mov    %r8d,%r9d
    0.00 :   40f127: mov    %rsi,%rdx
    0.00 :   40f12a: shr    %r9d
    0.00 :   40f12d: sub    $0x1,%r9d
    0.00 :   40f131: shl    $0x4,%r9
    0.00 :   40f135: lea    0x10(%rsi,%r9,1),%r9
    0.00 :   40f13a: nopw   0x0(%rax,%rax,1)
         : 169    activity[i] *= 1e-100;
    0.00 :   40f140: movupd (%rdx),%xmm0
    0.00 :   40f144: add    $0x10,%rdx
    0.00 :   40f148: mulpd  %xmm2,%xmm0
    0.00 :   40f14c: movups %xmm0,-0x10(%rdx)
    0.00 :   40f150: cmp    %r9,%rdx
    0.00 :   40f153: jne    40f140 <Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&)+0x160>
    0.00 :   40f155: mov    %r8d,%edx
    0.00 :   40f158: movsd  0xe1340(%rip),%xmm0        # 4f04a0 <typeinfo name for Minisat::Solver+0x100>
    0.00 :   40f160: and    $0xfffffffe,%edx
    0.00 :   40f163: and    $0x1,%r8d
    0.00 :   40f167: je     40f184 <Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&)+0x1a4>
         : 181    T&       operator [] (int index)       { return data[index]; }
    0.00 :   40f169: movslq %edx,%rdx
    0.00 :   40f16c: movsd  0xe132c(%rip),%xmm0        # 4f04a0 <typeinfo name for Minisat::Solver+0x100>
    0.00 :   40f174: lea    (%rsi,%rdx,8),%rdx
    0.00 :   40f178: movsd  (%rdx),%xmm1
    0.00 :   40f17c: mulsd  %xmm0,%xmm1
    0.00 :   40f180: movsd  %xmm1,(%rdx)
         : 188    var_inc *= 1e-100; }
    0.00 :   40f184: mulsd  0x170(%r14),%xmm0
    0.00 :   40f18d: movsd  %xmm0,0x170(%r14)
         : 191    public:
         : 192    Heap(const Comp& c) : lt(c) { }
         :
         : 194    int  size      ()          const { return heap.size(); }
         : 195    bool empty     ()          const { return heap.size() == 0; }
         : 196    bool inHeap    (int n)     const { return n < indices.size() && indices[n] >= 0; }
    0.00 :   40f196: cmp    0x250(%r14),%ecx
    0.00 :   40f19d: jge    40f245 <Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&)+0x265>
         : 199    const T& operator [] (int index) const { return data[index]; }
    0.00 :   40f1a3: mov    0x248(%r14),%r13
    0.00 :   40f1aa: mov    0x0(%r13,%rax,4),%edx
    0.00 :   40f1af: test   %edx,%edx
    0.00 :   40f1b1: js     40f245 <Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&)+0x265>
         : 204    T&       operator [] (int index)       { return data[index]; }
    0.00 :   40f1b7: mov    0x238(%r14),%r10
    0.00 :   40f1be: movslq %edx,%r11
         : 207    static inline int parent(int i) { return (i-1) >> 1; }
    0.00 :   40f1c1: lea    -0x1(%rdx),%esi
    0.00 :   40f1c4: sar    %esi
         : 210    int x  = heap[i];
    0.00 :   40f1c6: movslq (%r10,%r11,4),%r9
    0.00 :   40f1ca: mov    %r9d,0x14(%rsp)
    0.00 :   40f1cf: mov    %r9,0x18(%rsp)
         : 214    while (i != 0 && lt(x, heap[p])){
    0.00 :   40f1d4: test   %edx,%edx
    0.00 :   40f1d6: je     40f234 <Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&)+0x254>
         : 217    const T& operator [] (int index) const { return data[index]; }
    0.00 :   40f1d8: mov    0x230(%r14),%r8
    0.00 :   40f1df: mov    %rbp,0x20(%rsp)
    0.00 :   40f1e4: mov    (%r8),%r8
         : 221    bool operator () (Var x, Var y) const { return activity[x] > activity[y]; }
    0.00 :   40f1e7: movsd  (%r8,%r9,8),%xmm0
    0.00 :   40f1ed: mov    %r8,%rbp
    0.00 :   40f1f0: jmp    40f218 <Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&)+0x238>
    0.00 :   40f1f2: nopw   0x0(%rax,%rax,1)
         : 226    heap[i]          = heap[p];
    0.00 :   40f1f8: mov    %r8d,(%r11)
         : 228    indices[heap[p]] = i;
    0.00 :   40f1fb: mov    %edx,0x0(%r13,%r8,4)
         : 230    static inline int parent(int i) { return (i-1) >> 1; }
    0.00 :   40f200: lea    -0x1(%rsi),%edx
    0.00 :   40f203: sar    %edx
    0.00 :   40f205: mov    %edx,%r8d
         : 234    while (i != 0 && lt(x, heap[p])){
    0.00 :   40f208: mov    %esi,%edx
    0.00 :   40f20a: test   %esi,%esi
    0.00 :   40f20c: je     40f508 <Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&)+0x528>
         : 238    p                = parent(p);
    0.00 :   40f212: mov    %r8d,%esi
    0.00 :   40f215: movslq %edx,%r11
         : 241    T&       operator [] (int index)       { return data[index]; }
    0.00 :   40f218: movslq %esi,%r8
    0.00 :   40f21b: lea    (%r10,%r11,4),%r11
         : 244    while (i != 0 && lt(x, heap[p])){
    0.00 :   40f21f: movslq (%r10,%r8,4),%r8
    0.00 :   40f223: comisd 0x0(%rbp,%r8,8),%xmm0
    0.00 :   40f22a: ja     40f1f8 <Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&)+0x218>
    0.00 :   40f22c: mov    0x20(%rsp),%rbp
   51.14 :   40f231: mov    %r11,%r10
         : 250    heap   [i] = x;
    0.00 :   40f234: mov    0x14(%rsp),%esi
    0.00 :   40f238: mov    %esi,(%r10)
         : 253    indices[x] = i;
    0.00 :   40f23b: mov    0x18(%rsp),%rsi
    0.00 :   40f240: mov    %edx,0x0(%r13,%rsi,4)
         : 256    varBumpActivity(var(q));
         : 257    seen[var(q)] = 1;
    0.00 :   40f245: movb   $0x1,(%rdi)
         : 259    const T& operator [] (int index) const { return data[index]; }
    0.00 :   40f248: mov    0x200(%r14),%r8
    0.00 :   40f24f: lea    (%r8,%rbp,1),%rdx
         : 262    if (level(var(q)) >= decisionLevel()){
    0.00 :   40f253: mov    0x4(%rdx),%edi
    0.00 :   40f256: cmp    %edi,0x1f8(%r14)
    0.00 :   40f25d: jg     40f4d0 <Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&)+0x4f0>
         : 266    inline CRef Solver::reason(Var x) const { return vardata[x].reason; }
    0.00 :   40f263: mov    (%rdx),%edi
         : 268    int          size        ()      const   { return header.size; }
    0.00 :   40f265: mov    (%r15),%esi
         : 270    pathC++;
    0.00 :   40f268: addl   $0x1,0x4(%rsp)
         : 272    T&       operator [] (int index)       { return data[index]; }
    0.00 :   40f26d: mov    0x320(%r14),%rdx
    0.00 :   40f274: shr    $0x5,%esi
         : 275    CRef r = reason(var(q));
         : 276    if (r != CRef_Undef && ca[r].mark() == 3)/*auto*/{
    0.00 :   40f277: cmp    $0xffffffff,%edi
    0.00 :   40f27a: je     40f0b0 <Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&)+0xd0>
         : 279    uint32_t     mark        ()      const   { return header.mark; }
    0.00 :   40f280: mov    0x308(%r14),%r9
    0.00 :   40f287: movzbl (%r9,%rdi,4),%edi
    0.00 :   40f28c: and    $0x3,%edi
    0.00 :   40f28f: cmp    $0x3,%dil
    0.00 :   40f293: jne    40f0b0 <Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&)+0xd0>
         : 285    if ( (activity[v] += inc) > 1e100 ) {
    0.00 :   40f299: movsd  0x170(%r14),%xmm0
    0.00 :   40f2a2: mov    0x160(%r14),%rdi
    0.00 :   40f2a9: add    %rdi,%rbp
    0.00 :   40f2ac: addsd  0x0(%rbp),%xmm0
    0.00 :   40f2b1: comisd %xmm3,%xmm0
    0.00 :   40f2b5: movsd  %xmm0,0x0(%rbp)
    0.00 :   40f2ba: jbe    40f34d <Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&)+0x36d>
         : 293    int      size     (void) const     { return sz; }
    0.00 :   40f2c0: mov    0x208(%r14),%r10d
         : 295    for (int i = 0; i < nVars(); i++)
    0.00 :   40f2c7: test   %r10d,%r10d
    0.00 :   40f2ca: jle    40fa9c <Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&)+0xabc>
    0.00 :   40f2d0: cmp    $0x1,%r10d
    0.00 :   40f2d4: je     40faa9 <Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&)+0xac9>
    0.00 :   40f2da: mov    %r10d,%r11d
    0.00 :   40f2dd: mov    %rdi,%r9
    0.00 :   40f2e0: shr    %r11d
    0.00 :   40f2e3: sub    $0x1,%r11d
    0.00 :   40f2e7: shl    $0x4,%r11
    0.00 :   40f2eb: lea    0x10(%rdi,%r11,1),%r11
         : 306    activity[i] *= 1e-100;
    0.00 :   40f2f0: movupd (%r9),%xmm0
    0.00 :   40f2f5: add    $0x10,%r9
    0.00 :   40f2f9: mulpd  %xmm2,%xmm0
    0.00 :   40f2fd: movups %xmm0,-0x10(%r9)
    0.00 :   40f302: cmp    %r9,%r11
    0.00 :   40f305: jne    40f2f0 <Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&)+0x310>
    0.00 :   40f307: mov    %r10d,%r9d
    0.00 :   40f30a: movsd  0xe118e(%rip),%xmm0        # 4f04a0 <typeinfo name for Minisat::Solver+0x100>
    0.00 :   40f312: and    $0xfffffffe,%r9d
    0.00 :   40f316: and    $0x1,%r10d
    0.00 :   40f31a: je     40f33b <Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&)+0x35b>
         : 318    T&       operator [] (int index)       { return data[index]; }
    0.00 :   40f31c: movslq %r9d,%r9
    0.00 :   40f31f: mov    0xe117a(%rip),%rbx        # 4f04a0 <typeinfo name for Minisat::Solver+0x100>
    0.00 :   40f326: lea    (%rdi,%r9,8),%rdi
    0.00 :   40f32a: movsd  (%rdi),%xmm1
    0.00 :   40f32e: movq   %rbx,%xmm0
    0.00 :   40f333: mulsd  %xmm0,%xmm1
    0.00 :   40f337: movsd  %xmm1,(%rdi)
         : 326    var_inc *= 1e-100; }
    0.00 :   40f33b: mulsd  0x170(%r14),%xmm0
    0.00 :   40f344: movsd  %xmm0,0x170(%r14)
         : 329    bool inHeap    (int n)     const { return n < indices.size() && indices[n] >= 0; }
    0.00 :   40f34d: cmp    0x250(%r14),%ecx
    0.00 :   40f354: jge    40f0b0 <Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&)+0xd0>
         : 332    const T& operator [] (int index) const { return data[index]; }
    0.00 :   40f35a: mov    0x248(%r14),%rbx
    0.00 :   40f361: mov    (%rbx,%rax,4),%eax
    0.00 :   40f364: test   %eax,%eax
    0.00 :   40f366: js     40f0b0 <Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&)+0xd0>
         : 337    T&       operator [] (int index)       { return data[index]; }
    0.00 :   40f36c: mov    0x238(%r14),%r10
    0.00 :   40f373: movslq %eax,%r11
         : 340    static inline int parent(int i) { return (i-1) >> 1; }
    0.00 :   40f376: lea    -0x1(%rax),%ecx
    0.00 :   40f379: sar    %ecx
         : 343    int x  = heap[i];
    0.00 :   40f37b: movslq (%r10,%r11,4),%r13
    0.00 :   40f37f: mov    %r13d,0x14(%rsp)
         : 346    while (i != 0 && lt(x, heap[p])){
    0.00 :   40f384: test   %eax,%eax
    0.00 :   40f386: je     40f3ce <Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&)+0x3ee>
         : 349    const T& operator [] (int index) const { return data[index]; }
    0.00 :   40f388: mov    0x230(%r14),%rdi
    0.00 :   40f38f: mov    (%rdi),%rbp
         : 352    bool operator () (Var x, Var y) const { return activity[x] > activity[y]; }
    0.00 :   40f392: movsd  0x0(%rbp,%r13,8),%xmm0
    0.00 :   40f399: jmp    40f3b8 <Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&)+0x3d8>
    0.00 :   40f39b: nopl   0x0(%rax,%rax,1)
         : 356    heap[i]          = heap[p];
    0.00 :   40f3a0: mov    %edi,(%r11)
         : 358    indices[heap[p]] = i;
    0.00 :   40f3a3: mov    %eax,(%rbx,%rdi,4)
         : 360    static inline int parent(int i) { return (i-1) >> 1; }
    0.00 :   40f3a6: lea    -0x1(%rcx),%eax
    0.00 :   40f3a9: sar    %eax
    0.00 :   40f3ab: mov    %eax,%edi
         : 364    while (i != 0 && lt(x, heap[p])){
    0.00 :   40f3ad: mov    %ecx,%eax
    0.00 :   40f3af: test   %ecx,%ecx
    0.00 :   40f3b1: je     40f3ce <Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&)+0x3ee>
         : 368    p                = parent(p);
    0.00 :   40f3b3: mov    %edi,%ecx
    0.00 :   40f3b5: movslq %eax,%r11
         : 371    T&       operator [] (int index)       { return data[index]; }
    0.00 :   40f3b8: movslq %ecx,%rdi
    0.00 :   40f3bb: lea    (%r10,%r11,4),%r11
         : 374    while (i != 0 && lt(x, heap[p])){
    0.00 :   40f3bf: movslq (%r10,%rdi,4),%rdi
    0.00 :   40f3c3: comisd 0x0(%rbp,%rdi,8),%xmm0
    0.00 :   40f3c9: ja     40f3a0 <Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&)+0x3c0>
    0.00 :   40f3cb: mov    %r11,%r10
         : 379    heap   [i] = x;
    0.00 :   40f3ce: mov    0x14(%rsp),%edi
         : 381    for (int j = (p == lit_Undef) ? 0 : 1; j < c.size(); j++){
    0.00 :   40f3d2: add    $0x1,%r12
    0.00 :   40f3d6: mov    %edi,(%r10)
         : 384    indices[x] = i;
    0.00 :   40f3d9: mov    %eax,(%rbx,%r13,4)
    0.00 :   40f3dd: cmp    %r12d,%esi
    0.00 :   40f3e0: jg     40f0bd <Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&)+0xdd>
    0.00 :   40f3e6: cs nopw 0x0(%rax,%rax,1)
    0.00 :   40f3f0: mov    0x10(%rsp),%r15d
    0.00 :   40f3f5: lea    -0x1(%r15),%eax
    0.00 :   40f3f9: mov    0x1e0(%r14),%rdi
    0.00 :   40f400: cltq
    0.00 :   40f402: nopw   0x0(%rax,%rax,1)
         : 394    }/*auto*/
         : 395    }
         : 396    }
         :
         : 398    // Select next clause to look at:
         : 399    while (!seen[var(trail[index--])])/*auto*/{
    0.00 :   40f408: mov    0x4(%rdi,%rax,4),%ebx
    0.00 :   40f40c: mov    %eax,%r15d
    0.00 :   40f40f: sub    $0x1,%rax
         : 403    inline  int  var       (Lit p)              { return p.x >> 1; }
    0.00 :   40f413: mov    %ebx,%ecx
    0.00 :   40f415: sar    %ecx
    0.00 :   40f417: movslq %ecx,%rcx
    0.00 :   40f41a: lea    (%rdx,%rcx,1),%rsi
    0.00 :   40f41e: cmpb   $0x0,(%rsi)
    0.00 :   40f421: je     40f408 <Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&)+0x428>
         :
         : 411    }/*auto*/
         : 412    p     = trail[index+1];
         : 413    confl = reason(var(p));
         : 414    seen[var(p)] = 0;
         : 415    pathC--;
    0.00 :   40f423: subl   $0x1,0x4(%rsp)
    0.00 :   40f428: mov    0x4(%rsp),%eax
         : 418    inline CRef Solver::reason(Var x) const { return vardata[x].reason; }
    0.00 :   40f42c: mov    (%r8,%rcx,8),%ebp
         : 420    seen[var(p)] = 0;
    0.00 :   40f430: movb   $0x0,(%rsi)
         :
         : 423    }while (pathC > 0);
    0.00 :   40f433: test   %eax,%eax
    0.00 :   40f435: jg     40f050 <Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&)+0x70>
         : 426    out_learnt[0] = ~p;
    0.00 :   40f43b: mov    0x8(%rsp),%rax
         : 428    inline  Lit  operator ~(Lit p)              { Lit q; q.x = p.x ^ 1; return q; }
    0.00 :   40f440: xor    $0x1,%ebx
         : 430    sz = size; }
         :
         :
         : 433    template<class T>
         : 434    void vec<T>::clear(bool dealloc) {
         : 435    if (data != NULL){
    0.00 :   40f443: cmpq   $0x0,0x350(%r14)
    0.00 :   40f44b: mov    %r14,%r15
    0.00 :   40f44e: mov    (%rax),%rdx
    0.00 :   40f451: mov    %ebx,(%rdx)
    0.00 :   40f453: je     40fa48 <Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&)+0xa68>
         : 441    for (int i = 0; i < sz; i++) data[i].~T();
         : 442    sz = 0;
    0.00 :   40f459: movl   $0x0,0x358(%r14)
    0.00 :   40f464: xor    %eax,%eax
         : 445    void copyTo(vec<T>& copy) const { copy.clear(); copy.growTo(sz); for (int i = 0; i < sz; i++) copy[i] = data[i]; }
    0.00 :   40f466: mov    0x8(%rsp),%rbx
    0.00 :   40f46b: mov    0x8(%rbx),%ebx
         : 448    if (sz >= size) return;
    0.00 :   40f46e: cmp    %eax,%ebx
    0.00 :   40f470: jg     40f7b4 <Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&)+0x7d4>
         : 451    void copyTo(vec<T>& copy) const { copy.clear(); copy.growTo(sz); for (int i = 0; i < sz; i++) copy[i] = data[i]; }
    0.00 :   40f476: test   %ebx,%ebx
    0.00 :   40f478: jle    40f49f <Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&)+0x4bf>
         : 454    T&       operator [] (int index)       { return data[index]; }
    0.00 :   40f47a: mov    0x350(%r15),%rdi
    0.00 :   40f481: movslq %ebx,%rsi
    0.00 :   40f484: xor    %eax,%eax
    0.00 :   40f486: cs nopw 0x0(%rax,%rax,1)
         : 459    void copyTo(vec<T>& copy) const { copy.clear(); copy.growTo(sz); for (int i = 0; i < sz; i++) copy[i] = data[i]; }
    0.00 :   40f490: mov    (%rdx,%rax,4),%ecx
    0.00 :   40f493: mov    %ecx,(%rdi,%rax,4)
    0.00 :   40f496: add    $0x1,%rax
    0.00 :   40f49a: cmp    %rsi,%rax
    0.00 :   40f49d: jne    40f490 <Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&)+0x4b0>
         :
         : 466    // Simplify conflict clause:
         : 467    //
         : 468    int i, j;
         : 469    out_learnt.copyTo(analyze_toclear);
         : 470    if (ccmin_mode == 2){
    0.00 :   40f49f: mov    0x54(%r15),%ebp
    0.00 :   40f4a3: cmp    $0x2,%ebp
    0.00 :   40f4a6: je     40f805 <Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&)+0x825>
         :
         : 475    out_learnt[j++] = out_learnt[i];
         : 476    }/*auto*/
         : 477    }/*auto*/
         :
         : 479    }else if (ccmin_mode == 1){
    0.00 :   40f4ac: cmp    $0x1,%ebp
    0.00 :   40f4af: je     40f6fc <Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&)+0x71c>
         : 482    }else/*auto*/{
         :
         : 484    i = j = out_learnt.size();
         : 485    }/*auto*/
         :
         : 487    max_literals += out_learnt.size();
    0.00 :   40f4b5: movslq %ebx,%rcx
    0.00 :   40f4b8: mov    0x200(%r15),%rsi
    0.00 :   40f4bf: add    %rcx,0x110(%r15)
         : 491    void     shrink   (int nelems)     { assert(nelems <= sz); for (int i = 0; i < nelems; i++) sz--, data[sz].~T(); }
    0.00 :   40f4c6: jmp    40f8ee <Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&)+0x90e>
    0.00 :   40f4cb: nopl   0x0(%rax,%rax,1)
         : 494    void     push  (const T& elem)     { if (sz == cap) capacity(sz+1); data[sz++] = elem; }
    0.00 :   40f4d0: mov    0x8(%rsp),%rdi
    0.00 :   40f4d5: movslq 0x8(%rdi),%rax
    0.00 :   40f4d9: cmp    0xc(%rdi),%eax
    0.00 :   40f4dc: je     40f5f0 <Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&)+0x610>
    0.00 :   40f4e2: mov    0x8(%rsp),%rdi
    0.00 :   40f4e7: lea    0x1(%rax),%ecx
    0.00 :   40f4ea: mov    (%rdi),%rdx
    0.00 :   40f4ed: mov    %ecx,0x8(%rdi)
    0.00 :   40f4f0: mov    %ebx,(%rdx,%rax,4)
         : 504    int          size        ()      const   { return header.size; }
    0.00 :   40f4f3: mov    (%r15),%esi
         : 506    T&       operator [] (int index)       { return data[index]; }
    0.00 :   40f4f6: mov    0x320(%r14),%rdx
    0.00 :   40f4fd: shr    $0x5,%esi
         : 509    void     push  (const T& elem)     { if (sz == cap) capacity(sz+1); data[sz++] = elem; }
    0.00 :   40f500: jmp    40f0b0 <Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&)+0xd0>
    0.00 :   40f505: nopl   (%rax)
    0.00 :   40f508: mov    0x20(%rsp),%rbp
    0.00 :   40f50d: jmp    40f234 <Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&)+0x254>
    0.00 :   40f512: nopw   0x0(%rax,%rax,1)
         : 515    LBD(c);
    0.00 :   40f518: mov    0xe8(%r14),%rax
    0.00 :   40f51f: movl   $0x0,0x1240df(%rip)        # 533608 <i>
    0.00 :   40f529: movq   $0x0,0xe0(%r14)
    0.00 :   40f534: lea    0x1(%rax),%rdi
    0.00 :   40f538: mov    %rdi,0xe8(%r14)
    0.00 :   40f53f: test   %esi,%esi
    0.00 :   40f541: je     40fa54 <Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&)+0xa74>
         : 523    const T& operator [] (int index) const { return data[index]; }
    0.00 :   40f547: mov    0x200(%r14),%r9
    0.00 :   40f54e: xor    %r8d,%r8d
    0.00 :   40f551: xor    %edx,%edx
    0.00 :   40f553: nopl   0x0(%rax,%rax,1)
         : 528    inline  int  var       (Lit p)              { return p.x >> 1; }
    0.00 :   40f558: movslq %edx,%rax
    0.00 :   40f55b: mov    0x4(%r13,%rax,4),%eax
    0.00 :   40f560: sar    %eax
    0.00 :   40f562: cltq
         : 533    inline int  Solver::level (Var x) const { return vardata[x].level; }
    0.00 :   40f564: movslq 0x4(%r9,%rax,8),%rax
    0.00 :   40f569: mov    %eax,0x124091(%rip)        # 533600 <l>
    0.00 :   40f56f: test   %eax,%eax
    0.00 :   40f571: je     40f599 <Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&)+0x5b9>
         : 538    T&       operator [] (int index)       { return data[index]; }
    0.00 :   40f573: mov    0x330(%r14),%r10
    0.00 :   40f57a: lea    (%r10,%rax,4),%rax
    0.00 :   40f57e: mov    (%rax),%r10d
    0.00 :   40f581: cmp    %r10,%rdi
    0.00 :   40f584: je     40f599 <Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&)+0x5b9>
    0.00 :   40f586: add    $0x1,%r8
    0.00 :   40f58a: mov    %edi,(%rax)
    0.00 :   40f58c: mov    0x124076(%rip),%edx        # 533608 <i>
    0.00 :   40f592: mov    %r8,0xe0(%r14)
    0.00 :   40f599: add    $0x1,%edx
    0.00 :   40f59c: mov    %edx,0x124066(%rip)        # 533608 <i>
    0.00 :   40f5a2: cmp    %esi,%edx
    0.00 :   40f5a4: jl     40f558 <Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&)+0x578>
         : 552    c.mark(L < LBD_cut ? 3 : 2);
    0.00 :   40f5a6: mov    0x1245e0(%rip),%eax        # 533b8c <LBD_cut>
    0.00 :   40f5ac: cmp    %r8,%rax
    0.00 :   40f5af: jbe    40f620 <Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&)+0x640>
         : 556    void         mark        (uint32_t m)    { header.mark = m; }
    0.00 :   40f5b1: orb    $0x3,0x0(%r13)
         : 558    void     push  (const T& elem)     { if (sz == cap) capacity(sz+1); data[sz++] = elem; }
    0.00 :   40f5b6: movslq 0x150(%r14),%rax
    0.00 :   40f5bd: cmp    0x154(%r14),%eax
    0.00 :   40f5c4: je     40fa72 <Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&)+0xa92>
    0.00 :   40f5ca: mov    0x148(%r14),%rdx
    0.00 :   40f5d1: lea    0x1(%rax),%ecx
         : 564    core_added++;
    0.00 :   40f5d4: addl   $0x1,0x1245ad(%rip)        # 533b88 <core_added>
    0.00 :   40f5db: mov    %ecx,0x150(%r14)
    0.00 :   40f5e2: mov    %ebp,(%rdx,%rax,4)
    0.00 :   40f5e5: jmp    40f078 <Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&)+0x98>
    0.00 :   40f5ea: nopw   0x0(%rax,%rax,1)
    0.00 :   40f5f0: lea    0x1(%rax),%esi
    0.00 :   40f5f3: mov    %rdi,%rbp
    0.00 :   40f5f6: call   4055d0 <Minisat::vec<Minisat::Lit>::capacity(int)>
         : 573    const T& operator [] (int index) const { return data[index]; }
    0.00 :   40f5fb: mov    0xe0de6(%rip),%rdi        # 4f03e8 <typeinfo name for Minisat::Solver+0x48>
         : 575    void     push  (const T& elem)     { if (sz == cap) capacity(sz+1); data[sz++] = elem; }
    0.00 :   40f602: movslq 0x8(%rbp),%rax
         : 577    const T& operator [] (int index) const { return data[index]; }
    0.00 :   40f606: mov    0x200(%r14),%r8
    0.00 :   40f60d: movapd 0xe0e8b(%rip),%xmm2        # 4f04a0 <typeinfo name for Minisat::Solver+0x100>
    0.00 :   40f615: movq   %rdi,%xmm3
    0.00 :   40f61a: jmp    40f4e2 <Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&)+0x502>
    0.00 :   40f61f: nop
    0.00 :   40f620: movzbl 0x0(%r13),%eax
         : 584    if (order_heap.inHeap(v))
         : 585    order_heap.decrease(v); }
         :
         : 587    inline void Solver::claDecayActivity() { cla_inc *= (1 / clause_decay); }
         : 588    inline void Solver::claBumpActivity (Clause& c) {
         : 589    if ( (c.activity() += cla_inc) > 1e20 ) {
    0.00 :   40f625: pxor   %xmm0,%xmm0
    0.00 :   40f629: movsd  0x158(%r14),%xmm3
    0.00 :   40f632: and    $0xfffffffc,%eax
    0.00 :   40f635: or     $0x2,%eax
    0.00 :   40f638: mov    %al,0x0(%r13)
    0.00 :   40f63c: movslq %esi,%rax
    0.00 :   40f63f: cvtss2sd 0x4(%r13,%rax,4),%xmm0
    0.00 :   40f646: addsd  %xmm3,%xmm0
    0.00 :   40f64a: cvtsd2ss %xmm0,%xmm0
    0.00 :   40f64e: movss  %xmm0,0x4(%r13,%rax,4)
    0.00 :   40f655: cvtss2sd %xmm0,%xmm0
    0.00 :   40f659: comisd 0xe0d8f(%rip),%xmm0        # 4f03f0 <typeinfo name for Minisat::Solver+0x50>
    0.00 :   40f661: jbe    40f078 <Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&)+0x98>
         : 603    int      size     (void) const     { return sz; }
    0.00 :   40f667: mov    0x140(%r14),%edx
    0.00 :   40f66e: movsd  0xe0d6a(%rip),%xmm1        # 4f03e0 <typeinfo name for Minisat::Solver+0x40>
         : 606    // Rescale:
         : 607    for (int i = 0; i < learnts.size(); i++)
    0.00 :   40f676: test   %edx,%edx
    0.00 :   40f678: jle    40f6cf <Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&)+0x6ef>
    0.00 :   40f67a: mov    0x138(%r14),%rax
    0.00 :   40f681: lea    -0x1(%rdx),%edi
    0.00 :   40f684: movsd  0xe0d54(%rip),%xmm1        # 4f03e0 <typeinfo name for Minisat::Solver+0x40>
    0.00 :   40f68c: lea    0x4(%rax),%rdx
    0.00 :   40f690: lea    (%rdx,%rdi,4),%r8
    0.00 :   40f694: jmp    40f6a4 <Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&)+0x6c4>
    0.00 :   40f696: cs nopw 0x0(%rax,%rax,1)
    0.00 :   40f6a0: add    $0x4,%rdx
    0.00 :   40f6a4: mov    (%rax),%eax
         : 619    ca[learnts[i]].activity() *= 1e-20;
    0.00 :   40f6a6: pxor   %xmm0,%xmm0
    0.00 :   40f6aa: lea    (%rcx,%rax,4),%rdi
         : 622    //       subsumption operations to behave correctly.
         : 623    Lit&         operator [] (int i)         { return data[i].lit; }
         : 624    Lit          operator [] (int i) const   { return data[i].lit; }
         : 625    operator const Lit* (void) const         { return (Lit*)data; }
         :
         : 627    float&       activity    ()              { assert(header.has_extra); return data[header.size].act; }
    0.00 :   40f6ae: mov    (%rdi),%eax
    0.00 :   40f6b0: shr    $0x5,%eax
    0.00 :   40f6b3: cvtss2sd 0x4(%rdi,%rax,4),%xmm0
    0.00 :   40f6b9: mulsd  %xmm1,%xmm0
    0.00 :   40f6bd: cvtsd2ss %xmm0,%xmm0
    0.00 :   40f6c1: movss  %xmm0,0x4(%rdi,%rax,4)
         : 634    for (int i = 0; i < learnts.size(); i++)
    0.00 :   40f6c7: mov    %rdx,%rax
    0.00 :   40f6ca: cmp    %rdx,%r8
    0.00 :   40f6cd: jne    40f6a0 <Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&)+0x6c0>
         : 638    cla_inc *= 1e-20; } }
    0.00 :   40f6cf: mulsd  %xmm3,%xmm1
    0.00 :   40f6d3: movsd  %xmm1,0x158(%r14)
    0.00 :   40f6dc: jmp    40f078 <Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&)+0x98>
    0.00 :   40f6e1: nopl   0x0(%rax)
    0.00 :   40f6e8: movsd  0xe0db0(%rip),%xmm0        # 4f04a0 <typeinfo name for Minisat::Solver+0x100>
    0.00 :   40f6f0: jmp    40f184 <Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&)+0x1a4>
         : 645    for (int i = 0; i < nVars(); i++)
    0.00 :   40f6f5: xor    %edx,%edx
    0.00 :   40f6f7: jmp    40f169 <Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&)+0x189>
         : 648    for (i = j = 1; i < out_learnt.size(); i++){
    0.00 :   40f6fc: cmp    $0x1,%ebx
    0.00 :   40f6ff: jle    40f4b5 <Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&)+0x4d5>
    0.00 :   40f705: lea    -0x2(%rbx),%eax
         : 652    const T& operator [] (int index) const { return data[index]; }
    0.00 :   40f708: mov    0x200(%r15),%rsi
    0.00 :   40f70f: lea    0x4(%rdx),%r9
    0.00 :   40f713: lea    0x8(%rdx,%rax,4),%r10
    0.00 :   40f718: jmp    40f732 <Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&)+0x752>
    0.00 :   40f71a: nopw   0x0(%rax,%rax,1)
         : 658    T&       operator [] (int index)       { return data[index]; }
    0.00 :   40f720: movslq %ebp,%rax
         : 660    out_learnt[j++] = out_learnt[i];
    0.00 :   40f723: add    $0x1,%ebp
    0.00 :   40f726: mov    %ecx,(%rdx,%rax,4)
         : 663    for (i = j = 1; i < out_learnt.size(); i++){
    0.00 :   40f729: add    $0x4,%r9
    0.00 :   40f72d: cmp    %r10,%r9
    0.00 :   40f730: je     40f7ac <Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&)+0x7cc>
         : 667    inline  int  var       (Lit p)              { return p.x >> 1; }
    0.00 :   40f732: mov    (%r9),%ecx
    0.00 :   40f735: mov    %ecx,%eax
    0.00 :   40f737: sar    %eax
         : 671    const T& operator [] (int index) const { return data[index]; }
    0.00 :   40f739: cltq
         : 673    inline CRef Solver::reason(Var x) const { return vardata[x].reason; }
    0.00 :   40f73b: mov    (%rsi,%rax,8),%eax
         : 675    if (reason(x) == CRef_Undef)/*auto*/{
    0.00 :   40f73e: cmp    $0xffffffff,%eax
    0.00 :   40f741: je     40f720 <Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&)+0x740>
    0.00 :   40f743: mov    0x308(%r15),%rcx
    0.00 :   40f74a: lea    (%rcx,%rax,4),%rax
         : 680    int          size        ()      const   { return header.size; }
    0.00 :   40f74e: mov    (%rax),%ecx
    0.00 :   40f750: mov    %ecx,%r8d
    0.00 :   40f753: shr    $0x5,%r8d
         : 684    for (int k = 1; k < c.size(); k++)/*auto*/{
    0.00 :   40f757: cmp    $0x3f,%ecx
    0.00 :   40f75a: jbe    40f729 <Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&)+0x749>
    0.00 :   40f75c: sub    $0x2,%r8d
         : 688    T&       operator [] (int index)       { return data[index]; }
    0.00 :   40f760: mov    0x320(%r15),%rdi
    0.00 :   40f767: lea    0x8(%rax),%rcx
    0.00 :   40f76b: lea    0xc(%rax,%r8,4),%r8
    0.00 :   40f770: jmp    40f781 <Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&)+0x7a1>
    0.00 :   40f772: nopw   0x0(%rax,%rax,1)
    0.00 :   40f778: add    $0x4,%rcx
    0.00 :   40f77c: cmp    %r8,%rcx
    0.00 :   40f77f: je     40f729 <Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&)+0x749>
         : 697    inline  int  var       (Lit p)              { return p.x >> 1; }
    0.00 :   40f781: mov    (%rcx),%eax
    0.00 :   40f783: sar    %eax
    0.00 :   40f785: cltq
         : 701    if (!seen[var(c[k])] && level(var(c[k])) > 0){
    0.00 :   40f787: cmpb   $0x0,(%rdi,%rax,1)
    0.00 :   40f78b: jne    40f778 <Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&)+0x798>
    0.00 :   40f78d: mov    0x4(%rsi,%rax,8),%r11d
    0.00 :   40f792: test   %r11d,%r11d
    0.00 :   40f795: jle    40f778 <Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&)+0x798>
         : 707    out_learnt[j++] = out_learnt[i];
    0.00 :   40f797: mov    (%r9),%ecx
    0.00 :   40f79a: movslq %ebp,%rax
         : 710    for (i = j = 1; i < out_learnt.size(); i++){
    0.00 :   40f79d: add    $0x4,%r9
         : 712    out_learnt[j++] = out_learnt[i];
    0.00 :   40f7a1: add    $0x1,%ebp
    0.00 :   40f7a4: mov    %ecx,(%rdx,%rax,4)
         : 715    for (i = j = 1; i < out_learnt.size(); i++){
    0.00 :   40f7a7: cmp    %r10,%r9
    0.00 :   40f7aa: jne    40f732 <Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&)+0x752>
    0.00 :   40f7ac: mov    %ebx,%r12d
    0.00 :   40f7af: jmp    40f8ce <Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&)+0x8ee>
         : 720    out_learnt.copyTo(analyze_toclear);
    0.00 :   40f7b4: lea    0x350(%r15),%rdi
         : 722    capacity(size);
    0.00 :   40f7bb: mov    %ebx,%esi
    0.00 :   40f7bd: call   4055d0 <Minisat::vec<Minisat::Lit>::capacity(int)>
         : 725    for (int i = sz; i < size; i++) new (&data[i]) T();
    0.00 :   40f7c2: movslq 0x358(%r15),%rax
    0.00 :   40f7c9: cmp    %eax,%ebx
    0.00 :   40f7cb: jle    40f7ee <Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&)+0x80e>
    0.00 :   40f7cd: mov    %ebx,%edx
    0.00 :   40f7cf: mov    0x350(%r15),%rcx
    0.00 :   40f7d6: xor    %esi,%esi
    0.00 :   40f7d8: sub    %eax,%edx
    0.00 :   40f7da: sub    $0x1,%edx
    0.00 :   40f7dd: lea    (%rcx,%rax,4),%rdi
    0.00 :   40f7e1: lea    0x4(,%rdx,4),%rdx
    0.00 :   40f7e9: call   401120 <_init+0x120>
         : 737    void copyTo(vec<T>& copy) const { copy.clear(); copy.growTo(sz); for (int i = 0; i < sz; i++) copy[i] = data[i]; }
    0.00 :   40f7ee: mov    0x8(%rsp),%rax
         : 739    sz = size; }
    0.00 :   40f7f3: mov    %ebx,0x358(%r15)
    0.00 :   40f7fa: mov    (%rax),%rdx
         : 742    void copyTo(vec<T>& copy) const { copy.clear(); copy.growTo(sz); for (int i = 0; i < sz; i++) copy[i] = data[i]; }
    0.00 :   40f7fd: mov    0x8(%rax),%ebx
    0.00 :   40f800: jmp    40f476 <Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&)+0x496>
         : 745    for (i = 1; i < out_learnt.size(); i++)/*auto*/{
    0.00 :   40f805: cmp    $0x1,%ebx
    0.00 :   40f808: jle    40f4b5 <Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&)+0x4d5>
    0.00 :   40f80e: lea    -0x2(%rbx),%eax
    0.00 :   40f811: lea    0x4(%rdx),%rdi
         : 750    uint32_t abstract_level = 0;
    0.00 :   40f815: xor    %r13d,%r13d
         : 752    inline bool     Solver::addClause       (Lit p, Lit q, Lit r)   { add_tmp.clear(); add_tmp.push(p); add_tmp.push(q); add_tmp.push(r); return addClause_(add_tmp); }
         : 753    inline bool     Solver::locked          (const Clause& c) const { return value(c[0]) == l_True && reason(var(c[0])) != CRef_Undef && ca.lea(reason(var(c[0]))) == &c; }
         : 754    inline void     Solver::newDecisionLevel()                      { trail_lim.push(trail.size()); }
         :
         : 756    inline int      Solver::decisionLevel ()      const   { return trail_lim.size(); }
         : 757    inline uint32_t Solver::abstractLevel (Var x) const   { return 1 << (level(x) & 31); }
    0.00 :   40f818: mov    $0x1,%r8d
         : 759    const T& operator [] (int index) const { return data[index]; }
    0.00 :   40f81e: mov    0x200(%r15),%rsi
    0.00 :   40f825: lea    0x8(%rdx,%rax,4),%r9
    0.00 :   40f82a: nopw   0x0(%rax,%rax,1)
    0.00 :   40f830: mov    (%rdi),%eax
         : 764    for (i = 1; i < out_learnt.size(); i++)/*auto*/{
    0.00 :   40f832: add    $0x4,%rdi
    0.00 :   40f836: sar    %eax
    0.00 :   40f838: cltq
    0.00 :   40f83a: mov    0x4(%rsi,%rax,8),%ecx
    0.00 :   40f83e: mov    %r8d,%eax
    0.00 :   40f841: shl    %cl,%eax
         : 771    abstract_level |= abstractLevel(var(out_learnt[i]));
    0.00 :   40f843: or     %eax,%r13d
         : 773    for (i = 1; i < out_learnt.size(); i++)/*auto*/{
    0.00 :   40f846: cmp    %r9,%rdi
    0.00 :   40f849: jne    40f830 <Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&)+0x850>
    0.00 :   40f84b: mov    %ebx,%edi
    0.00 :   40f84d: mov    $0x4,%r14d
    0.00 :   40f853: mov    %r13d,%ebx
    0.00 :   40f856: mov    $0x1,%ebp
    0.00 :   40f85b: mov    0x8(%rsp),%r13
    0.00 :   40f860: mov    $0x1,%r12d
    0.00 :   40f866: mov    %rsi,%r8
    0.00 :   40f869: jmp    40f89e <Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&)+0x8be>
    0.00 :   40f86b: nopl   0x0(%rax,%rax,1)
         : 785    if (reason(var(out_learnt[i])) == CRef_Undef || !litRedundant(out_learnt[i], abstract_level))/*auto*/{
    0.00 :   40f870: mov    %ebx,%edx
    0.00 :   40f872: mov    %r15,%rdi
    0.00 :   40f875: call   40cb00 <Minisat::Solver::litRedundant(Minisat::Lit, unsigned int)>
    0.00 :   40f87a: test   %al,%al
    0.00 :   40f87c: je     40fa25 <Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&)+0xa45>
         : 791    int      size     (void) const     { return sz; }
    0.00 :   40f882: mov    0x8(%r13),%edi
         : 793    for (i = j = 1; i < out_learnt.size(); i++)/*auto*/{
    0.00 :   40f886: add    $0x1,%r12d
    0.00 :   40f88a: mov    0x0(%r13),%rdx
    0.00 :   40f88e: add    $0x4,%r14
    0.00 :   40f892: mov    0x200(%r15),%r8
    0.00 :   40f899: cmp    %edi,%r12d
    0.00 :   40f89c: jge    40f8c9 <Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&)+0x8e9>
         : 800    T&       operator [] (int index)       { return data[index]; }
    0.00 :   40f89e: lea    (%rdx,%r14,1),%rcx
    0.00 :   40f8a2: mov    (%rcx),%esi
    0.00 :   40f8a4: mov    %esi,%eax
    0.00 :   40f8a6: sar    %eax
         : 805    const T& operator [] (int index) const { return data[index]; }
    0.00 :   40f8a8: cltq
         : 807    if (reason(var(out_learnt[i])) == CRef_Undef || !litRedundant(out_learnt[i], abstract_level))/*auto*/{
    0.00 :   40f8aa: cmpl   $0xffffffff,(%r8,%rax,8)
    0.00 :   40f8af: jne    40f870 <Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&)+0x890>
         : 810    out_learnt[j++] = out_learnt[i];
    0.00 :   40f8b1: mov    (%rcx),%ecx
         : 812    T&       operator [] (int index)       { return data[index]; }
    0.00 :   40f8b3: movslq %ebp,%rax
    0.00 :   40f8b6: add    $0x1,%ebp
    0.00 :   40f8b9: mov    %ecx,(%rdx,%rax,4)
         : 816    for (i = j = 1; i < out_learnt.size(); i++)/*auto*/{
    0.00 :   40f8bc: add    $0x1,%r12d
    0.00 :   40f8c0: add    $0x4,%r14
    0.00 :   40f8c4: cmp    %edi,%r12d
    0.00 :   40f8c7: jl     40f89e <Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&)+0x8be>
    0.00 :   40f8c9: mov    %edi,%ebx
    0.00 :   40f8cb: mov    %r8,%rsi
         : 823    out_learnt.shrink(i - j);
    0.00 :   40f8ce: mov    %r12d,%eax
         : 825    max_literals += out_learnt.size();
    0.00 :   40f8d1: movslq %ebx,%rcx
    0.00 :   40f8d4: add    %rcx,0x110(%r15)
         : 828    out_learnt.shrink(i - j);
    0.00 :   40f8db: sub    %ebp,%eax
         : 830    void     shrink   (int nelems)     { assert(nelems <= sz); for (int i = 0; i < nelems; i++) sz--, data[sz].~T(); }
    0.00 :   40f8dd: test   %eax,%eax
    0.00 :   40f8df: jle    40f8ee <Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&)+0x90e>
    0.00 :   40f8e1: sub    %eax,%ebx
    0.00 :   40f8e3: mov    0x8(%rsp),%rax
         : 835    tot_literals += out_learnt.size();
    0.00 :   40f8e8: movslq %ebx,%rcx
    0.00 :   40f8eb: mov    %ebx,0x8(%rax)
         :
         : 839    LBD(out_learnt);
    0.00 :   40f8ee: mov    0xe8(%r15),%rax
         : 841    tot_literals += out_learnt.size();
    0.00 :   40f8f5: add    %rcx,0x118(%r15)
         : 843    LBD(out_learnt);
    0.00 :   40f8fc: movq   $0x0,0xe0(%r15)
    0.00 :   40f907: lea    0x1(%rax),%rdi
    0.00 :   40f90b: mov    %rdi,0xe8(%r15)
    0.00 :   40f912: test   %ebx,%ebx
    0.00 :   40f914: jle    40f967 <Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&)+0x987>
         : 849    const T& operator [] (int index) const { return data[index]; }
    0.00 :   40f916: mov    0x8(%rsp),%r9
    0.00 :   40f91b: xor    %ecx,%ecx
    0.00 :   40f91d: nopl   (%rax)
    0.00 :   40f920: mov    (%rdx,%rcx,4),%eax
    0.00 :   40f923: sar    %eax
    0.00 :   40f925: cltq
         : 856    inline int  Solver::level (Var x) const { return vardata[x].level; }
    0.00 :   40f927: movslq 0x4(%rsi,%rax,8),%rax
    0.00 :   40f92c: mov    %eax,0x123cce(%rip)        # 533600 <l>
    0.00 :   40f932: test   %eax,%eax
    0.00 :   40f934: je     40f957 <Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&)+0x977>
         : 861    T&       operator [] (int index)       { return data[index]; }
    0.00 :   40f936: mov    0x330(%r15),%r8
    0.00 :   40f93d: lea    (%r8,%rax,4),%rax
    0.00 :   40f941: mov    (%rax),%r8d
    0.00 :   40f944: cmp    %r8,%rdi
    0.00 :   40f947: je     40f957 <Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&)+0x977>
    0.00 :   40f949: mov    %edi,(%rax)
         : 868    int      size     (void) const     { return sz; }
    0.00 :   40f94b: mov    0x8(%r9),%ebx
    0.00 :   40f94f: addq   $0x1,0xe0(%r15)
    0.00 :   40f957: add    $0x1,%rcx
    0.00 :   40f95b: cmp    %ecx,%ebx
    0.00 :   40f95d: jg     40f920 <Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&)+0x940>
         :
         : 875    // Find correct backtrack level:
         : 876    //
         : 877    if (out_learnt.size() == 1)/*auto*/{
    0.00 :   40f95f: xor    %r9d,%r9d
    0.00 :   40f962: cmp    $0x1,%ebx
    0.00 :   40f965: je     40f9d6 <Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&)+0x9f6>
         :
         : 882    max_i = i;
         : 883    }/*auto*/
         : 884    }/*auto*/
         : 885    // Swap-in this literal at index 1:
         : 886    Lit p             = out_learnt[max_i];
    0.00 :   40f967: mov    0x4(%rdx),%ebp
         : 888    T&       operator [] (int index)       { return data[index]; }
    0.00 :   40f96a: lea    0x4(%rdx),%r10
    0.00 :   40f96e: mov    %ebp,%eax
    0.00 :   40f970: sar    %eax
         : 892    const T& operator [] (int index) const { return data[index]; }
    0.00 :   40f972: cltq
    0.00 :   40f974: mov    0x4(%rsi,%rax,8),%r9d
         : 895    for (int i = 2; i < out_learnt.size(); i++)/*auto*/{
    0.00 :   40f979: cmp    $0x2,%ebx
    0.00 :   40f97c: jle    40f9cd <Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&)+0x9ed>
    0.00 :   40f97e: lea    0x8(%rdx),%rax
    0.00 :   40f982: mov    $0x2,%edi
         : 900    int max_i = 1;
    0.00 :   40f987: mov    $0x1,%r11d
    0.00 :   40f98d: jmp    40f9a2 <Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&)+0x9c2>
    0.00 :   40f98f: nop
         : 904    T&       operator [] (int index)       { return data[index]; }
    0.00 :   40f990: movslq %r11d,%rcx
         : 906    for (int i = 2; i < out_learnt.size(); i++)/*auto*/{
    0.00 :   40f993: add    $0x1,%edi
    0.00 :   40f996: add    $0x4,%rax
    0.00 :   40f99a: lea    (%rdx,%rcx,4),%r10
    0.00 :   40f99e: cmp    %edi,%ebx
    0.00 :   40f9a0: je     40f9cd <Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&)+0x9ed>
    0.00 :   40f9a2: mov    (%rax),%r8d
    0.00 :   40f9a5: mov    %rax,%r10
    0.00 :   40f9a8: mov    %r8d,%ecx
    0.00 :   40f9ab: sar    %ecx
         : 916    const T& operator [] (int index) const { return data[index]; }
    0.00 :   40f9ad: movslq %ecx,%rcx
    0.00 :   40f9b0: mov    0x4(%rsi,%rcx,8),%ecx
         : 919    if (level(var(out_learnt[i])) > level(var(out_learnt[max_i])))/*auto*/{
    0.00 :   40f9b4: cmp    %ecx,%r9d
    0.00 :   40f9b7: jge    40f990 <Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&)+0x9b0>
    0.00 :   40f9b9: mov    %edi,%r11d
         : 923    for (int i = 2; i < out_learnt.size(); i++)/*auto*/{
    0.00 :   40f9bc: add    $0x1,%edi
         : 925    if (level(var(out_learnt[i])) > level(var(out_learnt[max_i])))/*auto*/{
    0.00 :   40f9bf: mov    %ecx,%r9d
    0.00 :   40f9c2: mov    %r8d,%ebp
         : 928    for (int i = 2; i < out_learnt.size(); i++)/*auto*/{
    0.00 :   40f9c5: add    $0x4,%rax
    0.00 :   40f9c9: cmp    %edi,%ebx
    0.00 :   40f9cb: jne    40f9a2 <Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&)+0x9c2>
         : 932    out_learnt[max_i] = out_learnt[1];
    0.00 :   40f9cd: mov    0x4(%rdx),%eax
    0.00 :   40f9d0: mov    %eax,(%r10)
         : 935    out_learnt[1]     = p;
    0.00 :   40f9d3: mov    %ebp,0x4(%rdx)
         : 937    out_btlevel       = level(var(p));
    0.00 :   40f9d6: mov    0x28(%rsp),%rax
         : 939    }
         :
         : 941    for (int j = 0; j < analyze_toclear.size(); j++)/*auto*/{
    0.00 :   40f9db: xor    %edx,%edx
         : 943    out_btlevel       = level(var(p));
    0.00 :   40f9dd: mov    %r9d,(%rax)
         : 945    for (int j = 0; j < analyze_toclear.size(); j++)/*auto*/{
    0.00 :   40f9e0: mov    0x358(%r15),%eax
    0.00 :   40f9e7: test   %eax,%eax
    0.00 :   40f9e9: jle    40fa16 <Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&)+0xa36>
    0.00 :   40f9eb: nopl   0x0(%rax,%rax,1)
    0.00 :   40f9f0: mov    0x350(%r15),%rax
         : 951    seen[var(analyze_toclear[j])] = 0;
    0.00 :   40f9f7: mov    0x320(%r15),%rcx
    0.00 :   40f9fe: mov    (%rax,%rdx,4),%eax
         : 954    for (int j = 0; j < analyze_toclear.size(); j++)/*auto*/{
    0.00 :   40fa01: add    $0x1,%rdx
    0.00 :   40fa05: sar    %eax
         : 957    T&       operator [] (int index)       { return data[index]; }
    0.00 :   40fa07: cltq
         : 959    seen[var(analyze_toclear[j])] = 0;
    0.00 :   40fa09: movb   $0x0,(%rcx,%rax,1)
         : 961    for (int j = 0; j < analyze_toclear.size(); j++)/*auto*/{
    0.00 :   40fa0d: cmp    %edx,0x358(%r15)
    0.00 :   40fa14: jg     40f9f0 <Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&)+0xa10>
         : 964    }/*auto*/    // ('seen[]' is now cleared)
         : 965    }
    0.00 :   40fa16: add    $0x38,%rsp
    0.00 :   40fa1a: pop    %rbx
    0.00 :   40fa1b: pop    %rbp
    0.00 :   40fa1c: pop    %r12
    0.00 :   40fa1e: pop    %r13
    0.00 :   40fa20: pop    %r14
    0.00 :   40fa22: pop    %r15
    0.00 :   40fa24: ret
    0.00 :   40fa25: mov    0x0(%r13),%rdx
    0.00 :   40fa29: movslq %ebp,%rax
         : 976    int      size     (void) const     { return sz; }
    0.00 :   40fa2c: mov    0x8(%r13),%edi
         : 978    out_learnt[j++] = out_learnt[i];
    0.00 :   40fa30: add    $0x1,%ebp
    0.00 :   40fa33: mov    0x200(%r15),%r8
         : 981    T&       operator [] (int index)       { return data[index]; }
    0.00 :   40fa3a: lea    (%rdx,%r14,1),%rcx
    0.00 :   40fa3e: mov    (%rcx),%ecx
    0.00 :   40fa40: mov    %ecx,(%rdx,%rax,4)
    0.00 :   40fa43: jmp    40f8bc <Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&)+0x8dc>
         : 986    if (sz >= size) return;
    0.00 :   40fa48: mov    0x358(%r14),%eax
    0.00 :   40fa4f: jmp    40f466 <Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&)+0x486>
         : 989    LBD(c);
    0.00 :   40fa54: xor    %r8d,%r8d
    0.00 :   40fa57: jmp    40f5a6 <Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&)+0x5c6>
    0.00 :   40fa5c: mov    %rdx,%rbx
         : 993    void     push  (void)              { if (sz == cap) capacity(sz+1); new (&data[sz]) T(); sz++; }
    0.00 :   40fa5f: lea    0x1(%rax),%esi
    0.00 :   40fa62: mov    %rdx,%rdi
    0.00 :   40fa65: call   4055d0 <Minisat::vec<Minisat::Lit>::capacity(int)>
    0.00 :   40fa6a: mov    0x8(%rbx),%eax
    0.00 :   40fa6d: jmp    40f00d <Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&)+0x2d>
         : 999    void     push  (const T& elem)     { if (sz == cap) capacity(sz+1); data[sz++] = elem; }
    0.00 :   40fa72: lea    0x1(%rax),%esi
         : 1001   lF.push(confl);
    0.00 :   40fa75: lea    0x148(%r14),%rdi
    0.00 :   40fa7c: call   40af10 <Minisat::vec<unsigned int>::capacity(int)>
         : 1004   int          size        ()      const   { return header.size; }
    0.00 :   40fa81: mov    0x0(%r13),%esi
    0.00 :   40fa85: movslq 0x150(%r14),%rax
    0.00 :   40fa8c: movapd 0xe0a0c(%rip),%xmm2        # 4f04a0 <typeinfo name for Minisat::Solver+0x100>
    0.00 :   40fa94: shr    $0x5,%esi
    0.00 :   40fa97: jmp    40f5ca <Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&)+0x5ea>
    0.00 :   40fa9c: movsd  0xe09fc(%rip),%xmm0        # 4f04a0 <typeinfo name for Minisat::Solver+0x100>
    0.00 :   40faa4: jmp    40f33b <Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&)+0x35b>
         : 1012   for (int i = 0; i < nVars(); i++)
    0.00 :   40faa9: xor    %r9d,%r9d
    0.00 :   40faac: jmp    40f31c <Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&)+0x33c>
 Percent |	Source code & Disassembly of minisat_HACK_999ED_CSSC_static for cycles:u (1 samples, percent: local period)
---------------------------------------------------------------------------------------------------------------------------
         :
         :
         :
         : 3      Disassembly of section .text:
         :
         : 5      00000000004bf1b0 <__vfprintf_internal>:
    0.00 :   4bf1b0: endbr64
    0.00 :   4bf1b4: push   %r15
    0.00 :   4bf1b6: push   %r14
    0.00 :   4bf1b8: push   %r13
    0.00 :   4bf1ba: push   %r12
    0.00 :   4bf1bc: push   %rbp
    0.00 :   4bf1bd: mov    %rdi,%rbp
    0.00 :   4bf1c0: push   %rbx
    0.00 :   4bf1c1: sub    $0x538,%rsp
    0.00 :   4bf1c8: mov    %rsi,0x8(%rsp)
    0.00 :   4bf1cd: mov    %rdx,0x20(%rsp)
    0.00 :   4bf1d2: mov    %ecx,0x6c(%rsp)
    0.00 :   4bf1d6: mov    %fs:0x28,%rax
    0.00 :   4bf1df: mov    %rax,0x528(%rsp)
    0.00 :   4bf1e7: mov    $0xffffffffffffffb8,%rax
    0.00 :   4bf1ee: mov    %fs:(%rax),%eax
    0.00 :   4bf1f1: mov    %eax,0x7c(%rsp)
    0.00 :   4bf1f5: mov    0xc0(%rdi),%eax
    0.00 :   4bf1fb: test   %eax,%eax
    0.00 :   4bf1fd: jne    4bf648 <__vfprintf_internal+0x498>
    0.00 :   4bf203: movl   $0xffffffff,0xc0(%rdi)
    0.00 :   4bf20d: mov    0x0(%rbp),%ebx
    0.00 :   4bf210: test   $0x8,%bl
    0.00 :   4bf213: jne    4c1300 <__vfprintf_internal+0x2150>
    0.00 :   4bf219: cmpq   $0x0,0x8(%rsp)
    0.00 :   4bf21f: je     4c13cc <__vfprintf_internal+0x221c>
    0.00 :   4bf225: test   $0x2,%bl
    0.00 :   4bf228: jne    4c06a0 <__vfprintf_internal+0x14f0>
    0.00 :   4bf22e: mov    0x20(%rsp),%rax
    0.00 :   4bf233: mov    0x8(%rsp),%rdi
    0.00 :   4bf238: mov    $0x25,%esi
    0.00 :   4bf23d: movdqu (%rax),%xmm1
    0.00 :   4bf241: movups %xmm1,0x118(%rsp)
    0.00 :   4bf249: mov    0x10(%rax),%rax
    0.00 :   4bf24d: movaps %xmm1,0x10(%rsp)
    0.00 :   4bf252: mov    %rax,0x128(%rsp)
    0.00 :   4bf25a: call   4010a0 <_init+0xa0>
    0.00 :   4bf25f: mov    %rbp,0xf8(%rsp)
    0.00 :   4bf267: mov    %rax,0x48(%rsp)
    0.00 :   4bf26c: movb   $0x0,0xa6(%rsp)
    0.00 :   4bf274: and    $0x80,%bh
    0.00 :   4bf277: je     4bf660 <__vfprintf_internal+0x4b0>
    0.00 :   4bf27d: mov    0xd8(%rbp),%r12
    0.00 :   4bf284: mov    $0x533388,%rsi
    0.00 :   4bf28b: sub    $0x532b60,%rsi
    0.00 :   4bf292: mov    0x48(%rsp),%rbx
    0.00 :   4bf297: mov    %r12,%rax
    0.00 :   4bf29a: sub    $0x532b60,%rax
    0.00 :   4bf2a1: mov    %rsi,0x10(%rsp)
    0.00 :   4bf2a6: sub    0x8(%rsp),%rbx
    0.00 :   4bf2ab: cmp    %rax,%rsi
    0.00 :   4bf2ae: jbe    4c0a20 <__vfprintf_internal+0x1870>
    0.00 :   4bf2b4: mov    0x8(%rsp),%rsi
    0.00 :   4bf2b9: mov    %rbx,%rdx
    0.00 :   4bf2bc: mov    %rbp,%rdi
    0.00 :   4bf2bf: call   *0x38(%r12)
    0.00 :   4bf2c4: cmp    %rax,%rbx
    0.00 :   4bf2c7: jne    4c07a8 <__vfprintf_internal+0x15f8>
    0.00 :   4bf2cd: movslq %ebx,%rdx
    0.00 :   4bf2d0: mov    %rbx,%rax
    0.00 :   4bf2d3: mov    %ebx,%r12d
    0.00 :   4bf2d6: shr    $0x3f,%rax
    0.00 :   4bf2da: cmp    %rdx,%rbx
    0.00 :   4bf2dd: mov    $0x1,%edx
    0.00 :   4bf2e2: cmovne %edx,%eax
    0.00 :   4bf2e5: test   %eax,%eax
    0.00 :   4bf2e7: jne    4bf9f0 <__vfprintf_internal+0x840>
    0.00 :   4bf2ed: test   %ebx,%ebx
    0.00 :   4bf2ef: js     4bf3f8 <__vfprintf_internal+0x248>
    0.00 :   4bf2f5: mov    0x48(%rsp),%r13
    0.00 :   4bf2fa: cmpb   $0x0,0x0(%r13)
    0.00 :   4bf2ff: je     4bf3f8 <__vfprintf_internal+0x248>
    0.00 :   4bf305: mov    0x7a194(%rip),%rsi        # 5394a0 <__printf_function_table>
    0.00 :   4bf30c: mov    %rsi,0x98(%rsp)
    0.00 :   4bf314: test   %rsi,%rsi
    0.00 :   4bf317: jne    4c1078 <__vfprintf_internal+0x1ec8>
    0.00 :   4bf31d: cmpq   $0x0,0x7a18b(%rip)        # 5394b0 <__printf_modifier_table>
    0.00 :   4bf325: jne    4c0a60 <__vfprintf_internal+0x18b0>
    0.00 :   4bf32b: cmpq   $0x0,0x7a2d5(%rip)        # 539608 <__printf_va_arg_table>
    0.00 :   4bf333: jne    4c0a60 <__vfprintf_internal+0x18b0>
    0.00 :   4bf339: mov    0x6c(%rsp),%eax
    0.00 :   4bf33d: movl   $0x0,0xa0(%rsp)
    0.00 :   4bf348: movl   $0x0,0x68(%rsp)
    0.00 :   4bf350: movq   $0xffffffffffffffff,0x80(%rsp)
    0.00 :   4bf35c: mov    %eax,%edi
    0.00 :   4bf35e: and    $0x1,%edi
    0.00 :   4bf361: mov    %dil,0xa7(%rsp)
    0.00 :   4bf369: mov    %eax,%edi
    0.00 :   4bf36b: and    $0x2,%eax
    0.00 :   4bf36e: and    $0x8,%edi
    0.00 :   4bf371: mov    %eax,0xa8(%rsp)
    0.00 :   4bf378: mov    %edi,0xac(%rsp)
    0.00 :   4bf37f: nop
    0.00 :   4bf380: movzbl 0x1(%r13),%ebx
    0.00 :   4bf385: lea    -0x20(%rbx),%eax
    0.00 :   4bf388: cmp    $0x5a,%al
  100.00 :   4bf38a: jbe    4bf470 <__vfprintf_internal+0x2c0>
    0.00 :   4bf390: endbr64
    0.00 :   4bf394: test   %bl,%bl
    0.00 :   4bf396: je     4bf720 <__vfprintf_internal+0x570>
    0.00 :   4bf39c: mov    0x68(%rsp),%eax
    0.00 :   4bf3a0: sub    $0x8,%rsp
    0.00 :   4bf3a4: mov    %r12d,%r9d
    0.00 :   4bf3a7: mov    0x74(%rsp),%edi
    0.00 :   4bf3ab: push   %rdi
    0.00 :   4bf3ac: push   0xa8(%rsp)
    0.00 :   4bf3b3: push   0x98(%rsp)
    0.00 :   4bf3ba: mov    0x9c(%rsp),%edi
    0.00 :   4bf3c1: push   %rdi
    0.00 :   4bf3c2: mov    %rbp,%rdi
    0.00 :   4bf3c5: lea    0x168(%rsp),%rdx
    0.00 :   4bf3cd: push   %rdx
    0.00 :   4bf3ce: push   0x78(%rsp)
    0.00 :   4bf3d2: push   %rax
    0.00 :   4bf3d3: mov    0x60(%rsp),%rcx
    0.00 :   4bf3d8: mov    0xe0(%rsp),%edx
    0.00 :   4bf3df: mov    0x48(%rsp),%rsi
    0.00 :   4bf3e4: lea    0x158(%rsp),%r8
    0.00 :   4bf3ec: call   4bcbf0 <printf_positional>
    0.00 :   4bf3f1: add    $0x40,%rsp
    0.00 :   4bf3f5: mov    %eax,%r12d
    0.00 :   4bf3f8: testl  $0x8000,0x0(%rbp)
    0.00 :   4bf3ff: je     4bf440 <__vfprintf_internal+0x290>
    0.00 :   4bf401: cmpb   $0x0,0xa6(%rsp)
    0.00 :   4bf409: jne    4bf6d0 <__vfprintf_internal+0x520>
    0.00 :   4bf40f: mov    0x528(%rsp),%rax
    0.00 :   4bf417: sub    %fs:0x28,%rax
    0.00 :   4bf420: jne    4c147c <__vfprintf_internal+0x22cc>
    0.00 :   4bf426: add    $0x538,%rsp
    0.00 :   4bf42d: mov    %r12d,%eax
    0.00 :   4bf430: pop    %rbx
    0.00 :   4bf431: pop    %rbp
    0.00 :   4bf432: pop    %r12
    0.00 :   4bf434: pop    %r13
    0.00 :   4bf436: pop    %r14
    0.00 :   4bf438: pop    %r15
    0.00 :   4bf43a: ret
    0.00 :   4bf43b: nopl   0x0(%rax,%rax,1)
    0.00 :   4bf440: mov    0x88(%rbp),%rdi
    0.00 :   4bf447: mov    0x4(%rdi),%eax
    0.00 :   4bf44a: sub    $0x1,%eax
    0.00 :   4bf44d: mov    %eax,0x4(%rdi)
    0.00 :   4bf450: jne    4bf401 <__vfprintf_internal+0x251>
    0.00 :   4bf452: movq   $0x0,0x8(%rdi)
    0.00 :   4bf45a: xchg   %eax,(%rdi)
    0.00 :   4bf45c: cmp    $0x1,%eax
    0.00 :   4bf45f: jle    4bf401 <__vfprintf_internal+0x251>
    0.00 :   4bf461: call   45ed80 <__lll_lock_wake_private>
    0.00 :   4bf466: jmp    4bf401 <__vfprintf_internal+0x251>
    0.00 :   4bf468: nopl   0x0(%rax,%rax,1)
    0.00 :   4bf470: movsbl %bl,%edx
    0.00 :   4bf473: lea    0x506c6(%rip),%rax        # 50fb40 <jump_table>
    0.00 :   4bf47a: xor    %r15d,%r15d
    0.00 :   4bf47d: xor    %r9d,%r9d
    0.00 :   4bf480: sub    $0x20,%edx
    0.00 :   4bf483: mov    $0xffffffffffffff98,%rcx
    0.00 :   4bf48a: xor    %r8d,%r8d
    0.00 :   4bf48d: xor    %r10d,%r10d
    0.00 :   4bf490: movslq %edx,%rdx
    0.00 :   4bf493: lea    0x6e606(%rip),%rdi        # 52daa0 <step0_jumps.9>
    0.00 :   4bf49a: lea    0x1(%r13),%r14
    0.00 :   4bf49e: mov    $0xffffffff,%r13d
    0.00 :   4bf4a4: movzbl (%rax,%rdx,1),%edx
    0.00 :   4bf4a8: mov    %fs:(%rcx),%rsi
    0.00 :   4bf4ac: lea    0x6e1ed(%rip),%r11        # 52d6a0 <step4_jumps.5>
    0.00 :   4bf4b3: movl   $0x0,0x78(%rsp)
    0.00 :   4bf4bb: movl   $0x0,0x28(%rsp)
    0.00 :   4bf4c3: mov    (%rdi,%rdx,8),%rdx
    0.00 :   4bf4c7: mov    %rsi,0x38(%rsp)
    0.00 :   4bf4cc: movl   $0x0,0x70(%rsp)
    0.00 :   4bf4d4: movl   $0x0,0x54(%rsp)
    0.00 :   4bf4dc: movl   $0x0,0x30(%rsp)
    0.00 :   4bf4e4: movl   $0x0,0x5c(%rsp)
    0.00 :   4bf4ec: movl   $0x0,0x58(%rsp)
    0.00 :   4bf4f4: movb   $0x20,0x40(%rsp)
    0.00 :   4bf4f9: jmp    *%rdx
    0.00 :   4bf4fb: nopl   0x0(%rax,%rax,1)
    0.00 :   4bf500: endbr64
    0.00 :   4bf504: endbr64
    0.00 :   4bf508: movzbl 0x1(%r14),%ebx
    0.00 :   4bf50d: lea    0x1(%r14),%rcx
    0.00 :   4bf511: lea    -0x20(%rbx),%edx
    0.00 :   4bf514: cmp    $0x5a,%dl
    0.00 :   4bf517: ja     4bf390 <__vfprintf_internal+0x1e0>
    0.00 :   4bf51d: movsbl %bl,%edx
    0.00 :   4bf520: mov    %rcx,%r14
    0.00 :   4bf523: xor    %r10d,%r10d
    0.00 :   4bf526: mov    $0x1,%r9d
    0.00 :   4bf52c: sub    $0x20,%edx
    0.00 :   4bf52f: movslq %edx,%rdx
    0.00 :   4bf532: movzbl (%rax,%rdx,1),%edx
    0.00 :   4bf536: mov    (%r11,%rdx,8),%rdx
    0.00 :   4bf53a: jmp    *%rdx
    0.00 :   4bf53c: nopl   0x0(%rax)
    0.00 :   4bf540: endbr64
    0.00 :   4bf544: endbr64
    0.00 :   4bf548: cmpb   $0x0,0xa7(%rsp)
    0.00 :   4bf550: jne    4c113b <__vfprintf_internal+0x1f8b>
    0.00 :   4bf556: mov    %r10d,%edx
    0.00 :   4bf559: and    $0x1,%edx
    0.00 :   4bf55c: mov    0x28(%rsp),%eax
    0.00 :   4bf560: movzbl %dl,%edx
    0.00 :   4bf563: movsbl %bl,%ebx
    0.00 :   4bf566: movl   $0x0,0xdc(%rsp)
    0.00 :   4bf571: mov    %r13d,0xd0(%rsp)
    0.00 :   4bf579: mov    %eax,0xd4(%rsp)
    0.00 :   4bf580: lea    (%r8,%r8,1),%eax
    0.00 :   4bf584: or     %edx,%eax
    0.00 :   4bf586: lea    0x0(,%r9,4),%edx
    0.00 :   4bf58e: mov    %ebx,0xd8(%rsp)
    0.00 :   4bf595: or     %edx,%eax
    0.00 :   4bf597: movzwl 0x58(%rsp),%edx
    0.00 :   4bf59c: shl    $0x3,%edx
    0.00 :   4bf59f: or     %edx,%eax
    0.00 :   4bf5a1: movzwl 0x5c(%rsp),%edx
    0.00 :   4bf5a6: shl    $0x4,%edx
    0.00 :   4bf5a9: or     %edx,%eax
    0.00 :   4bf5ab: movzwl 0x30(%rsp),%edx
    0.00 :   4bf5b0: shl    $0x5,%edx
    0.00 :   4bf5b3: or     %edx,%eax
    0.00 :   4bf5b5: movzwl 0x54(%rsp),%edx
    0.00 :   4bf5ba: shl    $0x6,%edx
    0.00 :   4bf5bd: or     %edx,%eax
    0.00 :   4bf5bf: movzwl 0x70(%rsp),%edx
    0.00 :   4bf5c4: shl    $0x7,%edx
    0.00 :   4bf5c7: or     %edx,%eax
    0.00 :   4bf5c9: movzwl 0x78(%rsp),%edx
    0.00 :   4bf5ce: shl    $0xb,%edx
    0.00 :   4bf5d1: or     %edx,%eax
    0.00 :   4bf5d3: mov    %ax,0xdc(%rsp)
    0.00 :   4bf5db: movzbl 0x40(%rsp),%eax
    0.00 :   4bf5e0: mov    %eax,0xe0(%rsp)
    0.00 :   4bf5e7: test   %r10d,%r10d
    0.00 :   4bf5ea: je     4bf6e8 <__vfprintf_internal+0x538>
    0.00 :   4bf5f0: mov    0xac(%rsp),%esi
    0.00 :   4bf5f7: test   %esi,%esi
    0.00 :   4bf5f9: je     4c08e8 <__vfprintf_internal+0x1738>
    0.00 :   4bf5ff: mov    0x20(%rsp),%rcx
    0.00 :   4bf604: orb    $0x10,0xdd(%rsp)
    0.00 :   4bf60c: mov    0x4(%rcx),%edx
    0.00 :   4bf60f: cmp    $0xaf,%edx
    0.00 :   4bf615: jbe    4c0c90 <__vfprintf_internal+0x1ae0>
    0.00 :   4bf61b: mov    0x8(%rcx),%rax
    0.00 :   4bf61f: mov    %rax,0x28(%rsp)
    0.00 :   4bf624: add    $0xf,%rax
    0.00 :   4bf628: and    $0xfffffffffffffff0,%rax
    0.00 :   4bf62c: lea    0x10(%rax),%rdx
    0.00 :   4bf630: mov    %rdx,0x8(%rcx)
    0.00 :   4bf634: movdqa (%rax),%xmm3
    0.00 :   4bf638: movaps %xmm3,0xc0(%rsp)
    0.00 :   4bf640: jmp    4c090f <__vfprintf_internal+0x175f>
    0.00 :   4bf645: nopl   (%rax)
    0.00 :   4bf648: cmp    $0xffffffff,%eax
    0.00 :   4bf64b: je     4bf20d <__vfprintf_internal+0x5d>
    0.00 :   4bf651: mov    $0xffffffff,%r12d
    0.00 :   4bf657: jmp    4bf40f <__vfprintf_internal+0x25f>
    0.00 :   4bf65c: nopl   0x0(%rax)
    0.00 :   4bf660: mov    $0x4bc1e0,%rax
    0.00 :   4bf667: lea    0xf0(%rsp),%rdi
    0.00 :   4bf66f: mov    %rax,0xf0(%rsp)
    0.00 :   4bf677: call   45ec40 <__libc_cleanup_push_defer>
    0.00 :   4bf67c: mov    0x0(%rbp),%eax
    0.00 :   4bf67f: and    $0x8000,%eax
    0.00 :   4bf684: jne    4c14d6 <__vfprintf_internal+0x2326>
    0.00 :   4bf68a: mov    %fs:0x10,%rbx
    0.00 :   4bf693: mov    0x88(%rbp),%rdi
    0.00 :   4bf69a: cmp    %rbx,0x8(%rdi)
    0.00 :   4bf69e: je     4bf6ba <__vfprintf_internal+0x50a>
    0.00 :   4bf6a0: mov    $0x1,%edx
    0.00 :   4bf6a5: lock cmpxchg %edx,(%rdi)
    0.00 :   4bf6a9: jne    4c0de0 <__vfprintf_internal+0x1c30>
    0.00 :   4bf6af: mov    0x88(%rbp),%rdi
    0.00 :   4bf6b6: mov    %rbx,0x8(%rdi)
    0.00 :   4bf6ba: addl   $0x1,0x4(%rdi)
    0.00 :   4bf6be: movb   $0x1,0xa6(%rsp)
    0.00 :   4bf6c6: jmp    4bf27d <__vfprintf_internal+0xcd>
    0.00 :   4bf6cb: nopl   0x0(%rax,%rax,1)
    0.00 :   4bf6d0: lea    0xf0(%rsp),%rdi
    0.00 :   4bf6d8: call   45ec80 <__libc_cleanup_pop_restore>
    0.00 :   4bf6dd: jmp    4bf40f <__vfprintf_internal+0x25f>
    0.00 :   4bf6e2: nopw   0x0(%rax,%rax,1)
    0.00 :   4bf6e8: mov    0x20(%rsp),%rsi
    0.00 :   4bf6ed: mov    0x4(%rsi),%eax
    0.00 :   4bf6f0: cmp    $0xaf,%eax
    0.00 :   4bf6f5: ja     4c0c00 <__vfprintf_internal+0x1a50>
    0.00 :   4bf6fb: mov    %eax,%edx
    0.00 :   4bf6fd: add    $0x10,%eax
    0.00 :   4bf700: add    0x10(%rsi),%rdx
    0.00 :   4bf704: mov    %eax,0x4(%rsi)
    0.00 :   4bf707: movsd  (%rdx),%xmm0
    0.00 :   4bf70b: movsd  %xmm0,0xc0(%rsp)
    0.00 :   4bf714: jmp    4c090f <__vfprintf_internal+0x175f>
    0.00 :   4bf719: nopl   0x0(%rax)
    0.00 :   4bf720: mov    $0xffffffffffffffb8,%rax
    0.00 :   4bf727: mov    $0xffffffff,%r12d
    0.00 :   4bf72d: movl   $0x16,%fs:(%rax)
    0.00 :   4bf734: jmp    4bf3f8 <__vfprintf_internal+0x248>
    0.00 :   4bf739: nopl   0x0(%rax)
    0.00 :   4bf740: endbr64
    0.00 :   4bf744: mov    0x20(%rsp),%rsi
    0.00 :   4bf749: lea    0x110(%rsp),%rdx
    0.00 :   4bf751: movq   $0x0,0x110(%rsp)
    0.00 :   4bf75d: mov    (%rsi),%eax
    0.00 :   4bf75f: cmp    $0x2f,%eax
    0.00 :   4bf762: ja     4c0a30 <__vfprintf_internal+0x1880>
    0.00 :   4bf768: mov    %eax,%ecx
    0.00 :   4bf76a: add    $0x8,%eax
    0.00 :   4bf76d: add    0x10(%rsi),%rcx
    0.00 :   4bf771: mov    %eax,(%rsi)
    0.00 :   4bf773: lea    0x130(%rsp),%r8
    0.00 :   4bf77b: mov    (%rcx),%esi
    0.00 :   4bf77d: mov    %r8,%rdi
    0.00 :   4bf780: mov    %r8,0x38(%rsp)
    0.00 :   4bf785: call   49b4f0 <__wcrtomb>
    0.00 :   4bf78a: mov    %rax,%r13
    0.00 :   4bf78d: cmp    $0xffffffffffffffff,%rax
    0.00 :   4bf791: je     4c07a8 <__vfprintf_internal+0x15f8>
    0.00 :   4bf797: mov    0x28(%rsp),%ebx
    0.00 :   4bf79b: mov    0x30(%rsp),%r10d
    0.00 :   4bf7a0: mov    0x38(%rsp),%r8
    0.00 :   4bf7a5: sub    %eax,%ebx
    0.00 :   4bf7a7: test   %r10d,%r10d
    0.00 :   4bf7aa: jne    4bf7b4 <__vfprintf_internal+0x604>
    0.00 :   4bf7ac: test   %ebx,%ebx
    0.00 :   4bf7ae: jg     4c0c43 <__vfprintf_internal+0x1a93>
    0.00 :   4bf7b4: mov    0xd8(%rbp),%r15
    0.00 :   4bf7bb: mov    %r15,%rax
    0.00 :   4bf7be: sub    $0x532b60,%rax
    0.00 :   4bf7c5: cmp    %rax,0x10(%rsp)
    0.00 :   4bf7ca: jbe    4c11a9 <__vfprintf_internal+0x1ff9>
    0.00 :   4bf7d0: mov    %r13,%rdx
    0.00 :   4bf7d3: mov    %r8,%rsi
    0.00 :   4bf7d6: mov    %rbp,%rdi
    0.00 :   4bf7d9: call   *0x38(%r15)
    0.00 :   4bf7dd: cmp    %rax,%r13
    0.00 :   4bf7e0: jne    4c07a8 <__vfprintf_internal+0x15f8>
    0.00 :   4bf7e6: movslq %r12d,%rax
    0.00 :   4bf7e9: xor    %edx,%edx
    0.00 :   4bf7eb: add    %r13,%rax
    0.00 :   4bf7ee: js     4c14a6 <__vfprintf_internal+0x22f6>
    0.00 :   4bf7f4: cmp    %r13,%rax
    0.00 :   4bf7f7: jb     4c14a6 <__vfprintf_internal+0x22f6>
    0.00 :   4bf7fd: movslq %eax,%rcx
    0.00 :   4bf800: mov    %eax,%r12d
    0.00 :   4bf803: cmp    %rcx,%rax
    0.00 :   4bf806: mov    $0x1,%ecx
    0.00 :   4bf80b: cmovne %ecx,%edx
    0.00 :   4bf80e: test   %edx,%edx
    0.00 :   4bf810: jne    4bf9f0 <__vfprintf_internal+0x840>
    0.00 :   4bf816: test   %eax,%eax
    0.00 :   4bf818: js     4bf3f8 <__vfprintf_internal+0x248>
    0.00 :   4bf81e: mov    0x30(%rsp),%r9d
    0.00 :   4bf823: test   %r9d,%r9d
    0.00 :   4bf826: jne    4c059b <__vfprintf_internal+0x13eb>
    0.00 :   4bf82c: nopl   0x0(%rax)
    0.00 :   4bf830: add    $0x1,%r14
    0.00 :   4bf834: mov    $0x25,%esi
    0.00 :   4bf839: addl   $0x1,0x68(%rsp)
    0.00 :   4bf83e: mov    %r14,%rdi
    0.00 :   4bf841: call   4010a0 <_init+0xa0>
    0.00 :   4bf846: mov    0xd8(%rbp),%r15
    0.00 :   4bf84d: mov    %rax,%rbx
    0.00 :   4bf850: mov    %rax,%r13
    0.00 :   4bf853: sub    %r14,%rbx
    0.00 :   4bf856: mov    %r15,%rax
    0.00 :   4bf859: sub    $0x532b60,%rax
    0.00 :   4bf860: cmp    %rax,0x10(%rsp)
    0.00 :   4bf865: jbe    4c07f0 <__vfprintf_internal+0x1640>
    0.00 :   4bf86b: mov    %rbx,%rdx
    0.00 :   4bf86e: mov    %r14,%rsi
    0.00 :   4bf871: mov    %rbp,%rdi
    0.00 :   4bf874: call   *0x38(%r15)
    0.00 :   4bf878: cmp    %rbx,%rax
    0.00 :   4bf87b: jne    4c07a8 <__vfprintf_internal+0x15f8>
    0.00 :   4bf881: movslq %r12d,%rax
    0.00 :   4bf884: xor    %edx,%edx
    0.00 :   4bf886: add    %rbx,%rax
    0.00 :   4bf889: js     4c1468 <__vfprintf_internal+0x22b8>
    0.00 :   4bf88f: cmp    %rbx,%rax
    0.00 :   4bf892: jb     4c1468 <__vfprintf_internal+0x22b8>
    0.00 :   4bf898: movslq %eax,%rcx
    0.00 :   4bf89b: mov    %eax,%r12d
    0.00 :   4bf89e: cmp    %rcx,%rax
    0.00 :   4bf8a1: mov    $0x1,%ecx
    0.00 :   4bf8a6: cmovne %ecx,%edx
    0.00 :   4bf8a9: test   %edx,%edx
    0.00 :   4bf8ab: jne    4bf9f0 <__vfprintf_internal+0x840>
    0.00 :   4bf8b1: test   %eax,%eax
    0.00 :   4bf8b3: js     4bf3f8 <__vfprintf_internal+0x248>
    0.00 :   4bf8b9: cmpb   $0x0,0x0(%r13)
    0.00 :   4bf8be: jne    4bf380 <__vfprintf_internal+0x1d0>
    0.00 :   4bf8c4: jmp    4bf3f8 <__vfprintf_internal+0x248>
    0.00 :   4bf8c9: nopl   0x0(%rax)
    0.00 :   4bf8d0: endbr64
    0.00 :   4bf8d4: mov    0x20(%rsp),%rsi
    0.00 :   4bf8d9: mov    (%rsi),%eax
    0.00 :   4bf8db: cmp    $0x2f,%eax
    0.00 :   4bf8de: ja     4c0ab0 <__vfprintf_internal+0x1900>
    0.00 :   4bf8e4: mov    %eax,%edx
    0.00 :   4bf8e6: add    $0x8,%eax
    0.00 :   4bf8e9: add    0x10(%rsi),%rdx
    0.00 :   4bf8ed: mov    %eax,(%rsi)
    0.00 :   4bf8ef: mov    (%rdx),%r10
    0.00 :   4bf8f2: mov    %r9d,%eax
    0.00 :   4bf8f5: xor    $0x1,%eax
    0.00 :   4bf8f8: test   %r10,%r10
    0.00 :   4bf8fb: jne    4bfa3c <__vfprintf_internal+0x88c>
    0.00 :   4bf901: cmp    $0xffffffff,%r13d
    0.00 :   4bf905: je     4c0e38 <__vfprintf_internal+0x1c88>
    0.00 :   4bf90b: cmp    $0x5,%r13d
    0.00 :   4bf90f: jg     4c0e38 <__vfprintf_internal+0x1c88>
    0.00 :   4bf915: xor    %eax,%eax
    0.00 :   4bf917: xor    %r13d,%r13d
    0.00 :   4bf91a: lea    0x53114(%rip),%r10        # 512a35 <__PRETTY_FUNCTION__.0+0x145>
    0.00 :   4bf921: jmp    4bfa6f <__vfprintf_internal+0x8bf>
    0.00 :   4bf926: cs nopw 0x0(%rax,%rax,1)
    0.00 :   4bf930: endbr64
    0.00 :   4bf934: test   %r9d,%r9d
    0.00 :   4bf937: jne    4bf740 <__vfprintf_internal+0x590>
    0.00 :   4bf93d: mov    0x28(%rsp),%ebx
    0.00 :   4bf941: mov    0x30(%rsp),%r13d
    0.00 :   4bf946: sub    $0x1,%ebx
    0.00 :   4bf949: test   %r13d,%r13d
    0.00 :   4bf94c: je     4c0d99 <__vfprintf_internal+0x1be9>
    0.00 :   4bf952: mov    0x20(%rsp),%rdi
    0.00 :   4bf957: mov    (%rdi),%eax
    0.00 :   4bf959: cmp    $0x2f,%eax
    0.00 :   4bf95c: ja     4c0c18 <__vfprintf_internal+0x1a68>
    0.00 :   4bf962: mov    %eax,%edx
    0.00 :   4bf964: add    $0x8,%eax
    0.00 :   4bf967: add    0x10(%rdi),%rdx
    0.00 :   4bf96b: mov    %eax,(%rdi)
    0.00 :   4bf96d: mov    (%rdx),%edx
    0.00 :   4bf96f: mov    0x28(%rbp),%rax
    0.00 :   4bf973: cmp    0x30(%rbp),%rax
    0.00 :   4bf977: jae    4c1373 <__vfprintf_internal+0x21c3>
    0.00 :   4bf97d: lea    0x1(%rax),%rcx
    0.00 :   4bf981: mov    %rcx,0x28(%rbp)
    0.00 :   4bf985: mov    %dl,(%rax)
    0.00 :   4bf987: cmp    $0x7fffffff,%r12d
    0.00 :   4bf98e: je     4c07a8 <__vfprintf_internal+0x15f8>
    0.00 :   4bf994: mov    0x30(%rsp),%r11d
    0.00 :   4bf999: add    $0x1,%r12d
    0.00 :   4bf99d: test   %r11d,%r11d
    0.00 :   4bf9a0: je     4bf830 <__vfprintf_internal+0x680>
    0.00 :   4bf9a6: test   %ebx,%ebx
    0.00 :   4bf9a8: jle    4bf830 <__vfprintf_internal+0x680>
    0.00 :   4bf9ae: movslq %ebx,%r13
    0.00 :   4bf9b1: mov    $0x20,%esi
    0.00 :   4bf9b6: mov    %rbp,%rdi
    0.00 :   4bf9b9: mov    %r13,%rdx
    0.00 :   4bf9bc: call   4c8950 <_IO_padn>
    0.00 :   4bf9c1: cmp    %rax,%r13
    0.00 :   4bf9c4: jne    4c07a8 <__vfprintf_internal+0x15f8>
    0.00 :   4bf9ca: xor    %eax,%eax
    0.00 :   4bf9cc: add    %ebx,%r12d
    0.00 :   4bf9cf: js     4c14b8 <__vfprintf_internal+0x2308>
    0.00 :   4bf9d5: cmp    %ebx,%r12d
    0.00 :   4bf9d8: jb     4c14b8 <__vfprintf_internal+0x2308>
    0.00 :   4bf9de: test   %eax,%eax
    0.00 :   4bf9e0: je     4c05cb <__vfprintf_internal+0x141b>
    0.00 :   4bf9e6: cs nopw 0x0(%rax,%rax,1)
    0.00 :   4bf9f0: mov    $0xffffffffffffffb8,%rax
    0.00 :   4bf9f7: mov    $0xffffffff,%r12d
    0.00 :   4bf9fd: movl   $0x4b,%fs:(%rax)
    0.00 :   4bfa04: jmp    4bf3f8 <__vfprintf_internal+0x248>
    0.00 :   4bfa09: nopl   0x0(%rax)
    0.00 :   4bfa10: endbr64
    0.00 :   4bfa14: mov    0x58(%rsp),%r15d
    0.00 :   4bfa19: test   %r15d,%r15d
    0.00 :   4bfa1c: je     4c0ac8 <__vfprintf_internal+0x1918>
    0.00 :   4bfa22: mov    0x7c(%rsp),%edi
    0.00 :   4bfa26: call   4c7040 <__get_errname>
    0.00 :   4bfa2b: mov    %rax,%r10
    0.00 :   4bfa2e: mov    $0x1,%eax
    0.00 :   4bfa33: test   %r10,%r10
    0.00 :   4bfa36: je     4c1102 <__vfprintf_internal+0x1f52>
    0.00 :   4bfa3c: cmp    $0x53,%bl
    0.00 :   4bfa3f: je     4c0bd4 <__vfprintf_internal+0x1a24>
    0.00 :   4bfa45: test   %al,%al
    0.00 :   4bfa47: je     4c0bd4 <__vfprintf_internal+0x1a24>
    0.00 :   4bfa4d: cmp    $0xffffffff,%r13d
    0.00 :   4bfa51: je     4c0c29 <__vfprintf_internal+0x1a79>
    0.00 :   4bfa57: movslq %r13d,%rsi
    0.00 :   4bfa5a: mov    %r10,%rdi
    0.00 :   4bfa5d: mov    %r10,0x38(%rsp)
    0.00 :   4bfa62: call   401030 <_init+0x30>
    0.00 :   4bfa67: mov    0x38(%rsp),%r10
    0.00 :   4bfa6c: mov    %rax,%r13
    0.00 :   4bfa6f: mov    0x28(%rsp),%ebx
    0.00 :   4bfa73: sub    %eax,%ebx
    0.00 :   4bfa75: js     4c0ee0 <__vfprintf_internal+0x1d30>
    0.00 :   4bfa7b: mov    0x30(%rsp),%r8d
    0.00 :   4bfa80: test   %r8d,%r8d
    0.00 :   4bfa83: jne    4bfa8d <__vfprintf_internal+0x8dd>
    0.00 :   4bfa85: test   %ebx,%ebx
    0.00 :   4bfa87: jne    4c0cf8 <__vfprintf_internal+0x1b48>
    0.00 :   4bfa8d: mov    0xd8(%rbp),%r15
    0.00 :   4bfa94: mov    %r15,%rax
    0.00 :   4bfa97: sub    $0x532b60,%rax
    0.00 :   4bfa9e: cmp    %rax,0x10(%rsp)
    0.00 :   4bfaa3: jbe    4c128c <__vfprintf_internal+0x20dc>
    0.00 :   4bfaa9: mov    %r13,%rdx
    0.00 :   4bfaac: mov    %r10,%rsi
    0.00 :   4bfaaf: mov    %rbp,%rdi
    0.00 :   4bfab2: call   *0x38(%r15)
    0.00 :   4bfab6: cmp    %r13,%rax
    0.00 :   4bfab9: jne    4c07a8 <__vfprintf_internal+0x15f8>
    0.00 :   4bfabf: movslq %r12d,%rax
    0.00 :   4bfac2: xor    %edx,%edx
    0.00 :   4bfac4: add    %r13,%rax
    0.00 :   4bfac7: js     4c148b <__vfprintf_internal+0x22db>
    0.00 :   4bfacd: cmp    %r13,%rax
    0.00 :   4bfad0: jb     4c148b <__vfprintf_internal+0x22db>
    0.00 :   4bfad6: movslq %eax,%rcx
    0.00 :   4bfad9: mov    %eax,%r12d
    0.00 :   4bfadc: cmp    %rcx,%rax
    0.00 :   4bfadf: mov    $0x1,%ecx
    0.00 :   4bfae4: cmovne %ecx,%edx
    0.00 :   4bfae7: test   %edx,%edx
    0.00 :   4bfae9: jne    4bf9f0 <__vfprintf_internal+0x840>
    0.00 :   4bfaef: test   %eax,%eax
    0.00 :   4bfaf1: js     4bf3f8 <__vfprintf_internal+0x248>
    0.00 :   4bfaf7: mov    0x30(%rsp),%edi
    0.00 :   4bfafb: test   %edi,%edi
    0.00 :   4bfafd: je     4bf830 <__vfprintf_internal+0x680>
    0.00 :   4bfb03: test   %ebx,%ebx
    0.00 :   4bfb05: je     4bf830 <__vfprintf_internal+0x680>
    0.00 :   4bfb0b: jmp    4c05a3 <__vfprintf_internal+0x13f3>
    0.00 :   4bfb10: endbr64
    0.00 :   4bfb14: mov    0xa8(%rsp),%eax
    0.00 :   4bfb1b: test   %eax,%eax
    0.00 :   4bfb1d: je     4bfb2e <__vfprintf_internal+0x97e>
    0.00 :   4bfb1f: mov    0xa0(%rsp),%eax
    0.00 :   4bfb26: test   %eax,%eax
    0.00 :   4bfb28: je     4c0dea <__vfprintf_internal+0x1c3a>
    0.00 :   4bfb2e: mov    0x20(%rsp),%rdi
    0.00 :   4bfb33: mov    (%rdi),%eax
    0.00 :   4bfb35: cmp    $0x2f,%eax
    0.00 :   4bfb38: ja     4c0b90 <__vfprintf_internal+0x19e0>
    0.00 :   4bfb3e: mov    %eax,%edx
    0.00 :   4bfb40: add    $0x8,%eax
    0.00 :   4bfb43: add    0x10(%rdi),%rdx
    0.00 :   4bfb47: mov    %eax,(%rdi)
    0.00 :   4bfb49: mov    (%rdx),%rax
    0.00 :   4bfb4c: test   %r9d,%r9d
    0.00 :   4bfb4f: je     4c0b70 <__vfprintf_internal+0x19c0>
    0.00 :   4bfb55: movslq %r12d,%rdx
    0.00 :   4bfb58: mov    %rdx,(%rax)
    0.00 :   4bfb5b: jmp    4bf830 <__vfprintf_internal+0x680>
    0.00 :   4bfb60: endbr64
    0.00 :   4bfb64: mov    0x20(%rsp),%rsi
    0.00 :   4bfb69: mov    (%rsi),%eax
    0.00 :   4bfb6b: cmp    $0x2f,%eax
    0.00 :   4bfb6e: ja     4c0a98 <__vfprintf_internal+0x18e8>
    0.00 :   4bfb74: mov    %eax,%edx
    0.00 :   4bfb76: add    $0x8,%eax
    0.00 :   4bfb79: add    0x10(%rsi),%rdx
    0.00 :   4bfb7d: mov    %eax,(%rsi)
    0.00 :   4bfb7f: mov    (%rdx),%r9
    0.00 :   4bfb82: test   %r9,%r9
    0.00 :   4bfb85: je     4c0bb8 <__vfprintf_internal+0x1a08>
    0.00 :   4bfb8b: movl   $0x0,0x70(%rsp)
    0.00 :   4bfb93: mov    %r9,%r11
    0.00 :   4bfb96: mov    $0x78,%ebx
    0.00 :   4bfb9b: xor    %r9d,%r9d
    0.00 :   4bfb9e: movl   $0x1,0x58(%rsp)
    0.00 :   4bfba6: mov    $0x10,%r10d
    0.00 :   4bfbac: nopl   0x0(%rax)
    0.00 :   4bfbb0: cmp    $0xffffffff,%r13d
    0.00 :   4bfbb4: je     4bfeba <__vfprintf_internal+0xd0a>
    0.00 :   4bfbba: test   %r13d,%r13d
    0.00 :   4bfbbd: je     4c05e0 <__vfprintf_internal+0x1430>
    0.00 :   4bfbc3: movslq %r13d,%rax
    0.00 :   4bfbc6: movb   $0x20,0x40(%rsp)
    0.00 :   4bfbcb: mov    %rax,0x60(%rsp)
    0.00 :   4bfbd0: xor    %ecx,%ecx
    0.00 :   4bfbd2: lea    0x528(%rsp),%r13
    0.00 :   4bfbda: cmp    $0x58,%bl
    0.00 :   4bfbdd: mov    %r10d,%edx
    0.00 :   4bfbe0: sete   %cl
    0.00 :   4bfbe3: mov    %r11,%rdi
    0.00 :   4bfbe6: mov    %r13,%rsi
    0.00 :   4bfbe9: mov    %r9d,0x94(%rsp)
    0.00 :   4bfbf1: mov    %r10d,0x90(%rsp)
    0.00 :   4bfbf9: lea    0x140(%rsp),%r15
    0.00 :   4bfc01: mov    %r11,0x88(%rsp)
    0.00 :   4bfc09: call   4db3c0 <_itoa_word>
    0.00 :   4bfc0e: mov    0x80(%rsp),%rcx
    0.00 :   4bfc16: mov    0x88(%rsp),%r11
    0.00 :   4bfc1e: mov    %rax,0x38(%rsp)
    0.00 :   4bfc23: mov    0x90(%rsp),%r10d
    0.00 :   4bfc2b: test   %rcx,%rcx
    0.00 :   4bfc2e: mov    0x94(%rsp),%r9d
    0.00 :   4bfc36: je     4bfc85 <__vfprintf_internal+0xad5>
    0.00 :   4bfc38: mov    0x70(%rsp),%edx
    0.00 :   4bfc3c: test   %edx,%edx
    0.00 :   4bfc3e: je     4bfc85 <__vfprintf_internal+0xad5>
    0.00 :   4bfc40: mov    %r13,%rdx
    0.00 :   4bfc43: mov    %rax,%rsi
    0.00 :   4bfc46: mov    %r15,%rdi
    0.00 :   4bfc49: mov    %r11,0x70(%rsp)
    0.00 :   4bfc4e: mov    0x98(%rsp),%r8
    0.00 :   4bfc56: mov    %r9d,0x90(%rsp)
    0.00 :   4bfc5e: mov    %r10d,0x88(%rsp)
    0.00 :   4bfc66: call   4bc220 <group_number>
    0.00 :   4bfc6b: mov    0x90(%rsp),%r9d
    0.00 :   4bfc73: mov    0x70(%rsp),%r11
    0.00 :   4bfc78: mov    %rax,0x38(%rsp)
    0.00 :   4bfc7d: mov    0x88(%rsp),%r10d
    0.00 :   4bfc85: cmp    $0xa,%r10d
    0.00 :   4bfc89: jne    4bfccc <__vfprintf_internal+0xb1c>
    0.00 :   4bfc8b: mov    0x78(%rsp),%eax
    0.00 :   4bfc8f: test   %eax,%eax
    0.00 :   4bfc91: je     4bfccc <__vfprintf_internal+0xb1c>
    0.00 :   4bfc93: mov    0x38(%rsp),%rdi
    0.00 :   4bfc98: mov    %r13,%rdx
    0.00 :   4bfc9b: mov    %r13,%rsi
    0.00 :   4bfc9e: mov    %r10d,0x78(%rsp)
    0.00 :   4bfca3: mov    %r9d,0x88(%rsp)
    0.00 :   4bfcab: mov    %r11,0x70(%rsp)
    0.00 :   4bfcb0: call   4bc420 <_i18n_number_rewrite>
    0.00 :   4bfcb5: mov    0x78(%rsp),%r10d
    0.00 :   4bfcba: mov    0x70(%rsp),%r11
    0.00 :   4bfcbf: mov    %rax,0x38(%rsp)
    0.00 :   4bfcc4: mov    0x88(%rsp),%r9d
    0.00 :   4bfccc: mov    %r13,%r15
    0.00 :   4bfccf: sub    0x38(%rsp),%r15
    0.00 :   4bfcd4: cmp    0x60(%rsp),%r15
    0.00 :   4bfcd9: jge    4c0640 <__vfprintf_internal+0x1490>
    0.00 :   4bfcdf: mov    0x60(%rsp),%rdx
    0.00 :   4bfce4: mov    $0x0,%eax
    0.00 :   4bfce9: mov    0x30(%rsp),%r8d
    0.00 :   4bfcee: sub    %r15,%rdx
    0.00 :   4bfcf1: cmovs  %rax,%rdx
    0.00 :   4bfcf5: mov    %edx,%r13d
    0.00 :   4bfcf8: test   %r8d,%r8d
    0.00 :   4bfcfb: jne    4c0490 <__vfprintf_internal+0x12e0>
    0.00 :   4bfd01: mov    0x28(%rsp),%r8d
    0.00 :   4bfd06: sub    %r15d,%r8d
    0.00 :   4bfd09: sub    %edx,%r8d
    0.00 :   4bfd0c: test   %r11,%r11
    0.00 :   4bfd0f: je     4bfd2e <__vfprintf_internal+0xb7e>
    0.00 :   4bfd11: mov    0x58(%rsp),%edi
    0.00 :   4bfd15: test   %edi,%edi
    0.00 :   4bfd17: je     4bfd2e <__vfprintf_internal+0xb7e>
    0.00 :   4bfd19: mov    $0x10004,%eax
    0.00 :   4bfd1e: mov    %r10d,%ecx
    0.00 :   4bfd21: lea    -0x2(%r8),%edx
    0.00 :   4bfd25: shr    %cl,%rax
    0.00 :   4bfd28: test   $0x1,%al
    0.00 :   4bfd2a: cmovne %edx,%r8d
    0.00 :   4bfd2e: mov    0x5c(%rsp),%eax
    0.00 :   4bfd32: or     %r9d,%eax
    0.00 :   4bfd35: or     0x54(%rsp),%eax
    0.00 :   4bfd39: je     4c06e0 <__vfprintf_internal+0x1530>
    0.00 :   4bfd3f: sub    $0x1,%r8d
    0.00 :   4bfd43: cmpb   $0x20,0x40(%rsp)
    0.00 :   4bfd48: je     4c1495 <__vfprintf_internal+0x22e5>
    0.00 :   4bfd4e: test   %r9d,%r9d
    0.00 :   4bfd51: je     4c0848 <__vfprintf_internal+0x1698>
    0.00 :   4bfd57: mov    0x28(%rbp),%rax
    0.00 :   4bfd5b: cmp    0x30(%rbp),%rax
    0.00 :   4bfd5f: jae    4c1158 <__vfprintf_internal+0x1fa8>
    0.00 :   4bfd65: lea    0x1(%rax),%rdx
    0.00 :   4bfd69: mov    %rdx,0x28(%rbp)
    0.00 :   4bfd6d: movb   $0x2d,(%rax)
    0.00 :   4bfd70: cmp    $0x7fffffff,%r12d
    0.00 :   4bfd77: je     4c07a8 <__vfprintf_internal+0x15f8>
    0.00 :   4bfd7d: add    $0x1,%r12d
    0.00 :   4bfd81: test   %r11,%r11
    0.00 :   4bfd84: je     4bfdf0 <__vfprintf_internal+0xc40>
    0.00 :   4bfd86: mov    0x58(%rsp),%edx
    0.00 :   4bfd8a: test   %edx,%edx
    0.00 :   4bfd8c: je     4bfdf0 <__vfprintf_internal+0xc40>
    0.00 :   4bfd8e: mov    $0x10004,%eax
    0.00 :   4bfd93: bt     %r10,%rax
    0.00 :   4bfd97: jae    4bfdf0 <__vfprintf_internal+0xc40>
    0.00 :   4bfd99: mov    0x28(%rbp),%rax
    0.00 :   4bfd9d: cmp    0x30(%rbp),%rax
    0.00 :   4bfda1: jae    4c0e4f <__vfprintf_internal+0x1c9f>
    0.00 :   4bfda7: lea    0x1(%rax),%rdx
    0.00 :   4bfdab: mov    %rdx,0x28(%rbp)
    0.00 :   4bfdaf: movb   $0x30,(%rax)
    0.00 :   4bfdb2: cmp    $0x7fffffff,%r12d
    0.00 :   4bfdb9: je     4c07a8 <__vfprintf_internal+0x15f8>
    0.00 :   4bfdbf: mov    0x28(%rbp),%rax
    0.00 :   4bfdc3: cmp    0x30(%rbp),%rax
    0.00 :   4bfdc7: jae    4c1390 <__vfprintf_internal+0x21e0>
    0.00 :   4bfdcd: lea    0x1(%rax),%rdx
    0.00 :   4bfdd1: mov    %rdx,0x28(%rbp)
    0.00 :   4bfdd5: mov    %bl,(%rax)
    0.00 :   4bfdd7: cmp    $0x7ffffffe,%r12d
    0.00 :   4bfdde: je     4c07a8 <__vfprintf_internal+0x15f8>
    0.00 :   4bfde4: add    $0x2,%r12d
    0.00 :   4bfde8: nopl   0x0(%rax,%rax,1)
    0.00 :   4bfdf0: lea    (%r8,%r13,1),%ebx
    0.00 :   4bfdf4: test   %ebx,%ebx
    0.00 :   4bfdf6: jg     4c0800 <__vfprintf_internal+0x1650>
    0.00 :   4bfdfc: mov    0xd8(%rbp),%rbx
    0.00 :   4bfe03: mov    %rbx,%rax
    0.00 :   4bfe06: sub    $0x532b60,%rax
    0.00 :   4bfe0d: cmp    %rax,0x10(%rsp)
    0.00 :   4bfe12: jbe    4c1131 <__vfprintf_internal+0x1f81>
    0.00 :   4bfe18: mov    0x38(%rsp),%rsi
    0.00 :   4bfe1d: mov    %r15,%rdx
    0.00 :   4bfe20: mov    %rbp,%rdi
    0.00 :   4bfe23: call   *0x38(%rbx)
    0.00 :   4bfe26: cmp    %rax,%r15
    0.00 :   4bfe29: jne    4c07a8 <__vfprintf_internal+0x15f8>
    0.00 :   4bfe2f: movslq %r12d,%rax
    0.00 :   4bfe32: xor    %edx,%edx
    0.00 :   4bfe34: add    %r15,%rax
    0.00 :   4bfe37: js     4c0f24 <__vfprintf_internal+0x1d74>
    0.00 :   4bfe3d: cmp    %r15,%rax
    0.00 :   4bfe40: jb     4c0f24 <__vfprintf_internal+0x1d74>
    0.00 :   4bfe46: movslq %eax,%rcx
    0.00 :   4bfe49: mov    %eax,%r12d
    0.00 :   4bfe4c: cmp    %rcx,%rax
    0.00 :   4bfe4f: mov    $0x1,%ecx
    0.00 :   4bfe54: cmovne %ecx,%edx
    0.00 :   4bfe57: test   %edx,%edx
    0.00 :   4bfe59: jne    4bf9f0 <__vfprintf_internal+0x840>
    0.00 :   4bfe5f: test   %eax,%eax
    0.00 :   4bfe61: jns    4bf830 <__vfprintf_internal+0x680>
    0.00 :   4bfe67: jmp    4bf3f8 <__vfprintf_internal+0x248>
    0.00 :   4bfe6c: nopl   0x0(%rax)
    0.00 :   4bfe70: endbr64
    0.00 :   4bfe74: mov    $0x2,%r10d
    0.00 :   4bfe7a: mov    0x20(%rsp),%rdi
    0.00 :   4bfe7f: mov    (%rdi),%eax
    0.00 :   4bfe81: test   %r9d,%r9d
    0.00 :   4bfe84: je     4bfee6 <__vfprintf_internal+0xd36>
    0.00 :   4bfe86: cmp    $0x2f,%eax
    0.00 :   4bfe89: ja     4c08d0 <__vfprintf_internal+0x1720>
    0.00 :   4bfe8f: mov    %eax,%edx
    0.00 :   4bfe91: add    $0x8,%eax
    0.00 :   4bfe94: add    0x10(%rdi),%rdx
    0.00 :   4bfe98: mov    %eax,(%rdi)
    0.00 :   4bfe9a: movl   $0x0,0x54(%rsp)
    0.00 :   4bfea2: mov    (%rdx),%r11
    0.00 :   4bfea5: xor    %r9d,%r9d
    0.00 :   4bfea8: movl   $0x0,0x5c(%rsp)
    0.00 :   4bfeb0: cmp    $0xffffffff,%r13d
    0.00 :   4bfeb4: jne    4bfbba <__vfprintf_internal+0xa0a>
    0.00 :   4bfeba: movq   $0x1,0x60(%rsp)
    0.00 :   4bfec3: jmp    4bfbd0 <__vfprintf_internal+0xa20>
    0.00 :   4bfec8: nopl   0x0(%rax,%rax,1)
    0.00 :   4bfed0: endbr64
    0.00 :   4bfed4: mov    0x20(%rsp),%rdi
    0.00 :   4bfed9: mov    $0x10,%r10d
    0.00 :   4bfedf: mov    (%rdi),%eax
    0.00 :   4bfee1: test   %r9d,%r9d
    0.00 :   4bfee4: jne    4bfe86 <__vfprintf_internal+0xcd6>
    0.00 :   4bfee6: test   %r15d,%r15d
    0.00 :   4bfee9: je     4c0890 <__vfprintf_internal+0x16e0>
    0.00 :   4bfeef: cmp    $0x2f,%eax
    0.00 :   4bfef2: ja     4c0a80 <__vfprintf_internal+0x18d0>
    0.00 :   4bfef8: mov    %eax,%edx
    0.00 :   4bfefa: add    $0x8,%eax
    0.00 :   4bfefd: add    0x10(%rdi),%rdx
    0.00 :   4bff01: mov    %eax,(%rdi)
    0.00 :   4bff03: movl   $0x0,0x54(%rsp)
    0.00 :   4bff0b: movzbl (%rdx),%r11d
    0.00 :   4bff0f: movl   $0x0,0x5c(%rsp)
    0.00 :   4bff17: jmp    4bfbb0 <__vfprintf_internal+0xa00>
    0.00 :   4bff1c: nopl   0x0(%rax)
    0.00 :   4bff20: endbr64
    0.00 :   4bff24: mov    $0x8,%r10d
    0.00 :   4bff2a: jmp    4bfe7a <__vfprintf_internal+0xcca>
    0.00 :   4bff2f: nop
    0.00 :   4bff30: endbr64
    0.00 :   4bff34: mov    $0xa,%r10d
    0.00 :   4bff3a: jmp    4bfe7a <__vfprintf_internal+0xcca>
    0.00 :   4bff3f: nop
    0.00 :   4bff40: endbr64
    0.00 :   4bff44: test   %r9d,%r9d
    0.00 :   4bff47: je     4c0af0 <__vfprintf_internal+0x1940>
    0.00 :   4bff4d: mov    0x20(%rsp),%rdi
    0.00 :   4bff52: mov    (%rdi),%eax
    0.00 :   4bff54: cmp    $0x2f,%eax
    0.00 :   4bff57: jbe    4c0ce8 <__vfprintf_internal+0x1b38>
    0.00 :   4bff5d: mov    0x8(%rdi),%rdx
    0.00 :   4bff61: lea    0x8(%rdx),%rax
    0.00 :   4bff65: mov    %rax,0x8(%rdi)
    0.00 :   4bff69: mov    (%rdx),%r9
    0.00 :   4bff6c: jmp    4c0b20 <__vfprintf_internal+0x1970>
    0.00 :   4bff71: nopl   0x0(%rax)
    0.00 :   4bff78: endbr64
    0.00 :   4bff7c: mov    0x28(%rbp),%rax
    0.00 :   4bff80: cmp    0x30(%rbp),%rax
    0.00 :   4bff84: jae    4c12e0 <__vfprintf_internal+0x2130>
    0.00 :   4bff8a: lea    0x1(%rax),%rdx
    0.00 :   4bff8e: mov    %rdx,0x28(%rbp)
    0.00 :   4bff92: movb   $0x25,(%rax)
    0.00 :   4bff95: cmp    $0x7fffffff,%r12d
    0.00 :   4bff9c: je     4c07a8 <__vfprintf_internal+0x15f8>
    0.00 :   4bffa2: add    $0x1,%r12d
    0.00 :   4bffa6: jmp    4bf830 <__vfprintf_internal+0x680>
    0.00 :   4bffab: nopl   0x0(%rax,%rax,1)
    0.00 :   4bffb0: endbr64
    0.00 :   4bffb4: jmp    4bf504 <__vfprintf_internal+0x354>
    0.00 :   4bffb9: nopl   0x0(%rax)
    0.00 :   4bffc0: endbr64
    0.00 :   4bffc4: movzbl 0x1(%r14),%ebx
    0.00 :   4bffc9: lea    0x1(%r14),%rcx
    0.00 :   4bffcd: lea    -0x20(%rbx),%edx
    0.00 :   4bffd0: cmp    $0x5a,%dl
    0.00 :   4bffd3: ja     4bf390 <__vfprintf_internal+0x1e0>
    0.00 :   4bffd9: movsbl %bl,%edx
    0.00 :   4bffdc: mov    %rcx,%r14
    0.00 :   4bffdf: mov    $0x1,%r9d
    0.00 :   4bffe5: mov    $0x1,%r10d
    0.00 :   4bffeb: sub    $0x20,%edx
    0.00 :   4bffee: movslq %edx,%rdx
    0.00 :   4bfff1: movzbl (%rax,%rdx,1),%edx
    0.00 :   4bfff5: mov    (%r11,%rdx,8),%rdx
    0.00 :   4bfff9: jmp    *%rdx
    0.00 :   4bfffb: nopl   0x0(%rax,%rax,1)
    0.00 :   4c0000: endbr64
    0.00 :   4c0004: movzbl 0x1(%r14),%ebx
    0.00 :   4c0009: lea    0x1(%r14),%rcx
    0.00 :   4c000d: lea    -0x20(%rbx),%edx
    0.00 :   4c0010: cmp    $0x5a,%dl
    0.00 :   4c0013: ja     4bf390 <__vfprintf_internal+0x1e0>
    0.00 :   4c0019: movsbl %bl,%edx
    0.00 :   4c001c: lea    0x6d57d(%rip),%rsi        # 52d5a0 <step3b_jumps.4>
    0.00 :   4c0023: mov    %rcx,%r14
    0.00 :   4c0026: mov    $0x1,%r9d
    0.00 :   4c002c: sub    $0x20,%edx
    0.00 :   4c002f: movslq %edx,%rdx
    0.00 :   4c0032: movzbl (%rax,%rdx,1),%edx
    0.00 :   4c0036: mov    (%rsi,%rdx,8),%rdx
    0.00 :   4c003a: jmp    *%rdx
    0.00 :   4c003c: nopl   0x0(%rax)
    0.00 :   4c0040: endbr64
    0.00 :   4c0044: movzbl 0x1(%r14),%ebx
    0.00 :   4c0049: lea    0x1(%r14),%rcx
    0.00 :   4c004d: lea    -0x20(%rbx),%edx
    0.00 :   4c0050: cmp    $0x5a,%dl
    0.00 :   4c0053: ja     4bf390 <__vfprintf_internal+0x1e0>
    0.00 :   4c0059: movsbl %bl,%edx
    0.00 :   4c005c: lea    0x6da3d(%rip),%rdi        # 52daa0 <step0_jumps.9>
    0.00 :   4c0063: movl   $0x1,0x58(%rsp)
    0.00 :   4c006b: mov    %rcx,%r14
    0.00 :   4c006e: sub    $0x20,%edx
    0.00 :   4c0071: movslq %edx,%rdx
    0.00 :   4c0074: movzbl (%rax,%rdx,1),%edx
    0.00 :   4c0078: mov    (%rdi,%rdx,8),%rdx
    0.00 :   4c007c: jmp    *%rdx
    0.00 :   4c007e: xchg   %ax,%ax
    0.00 :   4c0080: endbr64
    0.00 :   4c0084: movzbl 0x1(%r14),%ebx
    0.00 :   4c0089: lea    0x1(%r14),%rcx
    0.00 :   4c008d: lea    -0x20(%rbx),%edx
    0.00 :   4c0090: cmp    $0x5a,%dl
    0.00 :   4c0093: ja     4bf390 <__vfprintf_internal+0x1e0>
    0.00 :   4c0099: movsbl %bl,%edx
    0.00 :   4c009c: movb   $0x20,0x40(%rsp)
    0.00 :   4c00a1: mov    %rcx,%r14
    0.00 :   4c00a4: lea    0x6d9f5(%rip),%rsi        # 52daa0 <step0_jumps.9>
    0.00 :   4c00ab: sub    $0x20,%edx
    0.00 :   4c00ae: movl   $0x1,0x30(%rsp)
    0.00 :   4c00b6: movslq %edx,%rdx
    0.00 :   4c00b9: movzbl (%rax,%rdx,1),%edx
    0.00 :   4c00bd: mov    (%rsi,%rdx,8),%rdx
    0.00 :   4c00c1: jmp    *%rdx
    0.00 :   4c00c3: nopl   0x0(%rax,%rax,1)
    0.00 :   4c00c8: endbr64
    0.00 :   4c00cc: movzbl 0x1(%r14),%ebx
    0.00 :   4c00d1: lea    0x1(%r14),%rcx
    0.00 :   4c00d5: lea    -0x20(%rbx),%edx
    0.00 :   4c00d8: cmp    $0x5a,%dl
    0.00 :   4c00db: ja     4bf390 <__vfprintf_internal+0x1e0>
    0.00 :   4c00e1: movsbl %bl,%edx
    0.00 :   4c00e4: lea    0x6d9b5(%rip),%rdi        # 52daa0 <step0_jumps.9>
    0.00 :   4c00eb: movl   $0x1,0x54(%rsp)
    0.00 :   4c00f3: mov    %rcx,%r14
    0.00 :   4c00f6: sub    $0x20,%edx
    0.00 :   4c00f9: movslq %edx,%rdx
    0.00 :   4c00fc: movzbl (%rax,%rdx,1),%edx
    0.00 :   4c0100: mov    (%rdi,%rdx,8),%rdx
    0.00 :   4c0104: jmp    *%rdx
    0.00 :   4c0106: cs nopw 0x0(%rax,%rax,1)
    0.00 :   4c0110: endbr64
    0.00 :   4c0114: movzbl 0x1(%r14),%ebx
    0.00 :   4c0119: lea    0x1(%r14),%rcx
    0.00 :   4c011d: lea    -0x20(%rbx),%edx
    0.00 :   4c0120: cmp    $0x5a,%dl
    0.00 :   4c0123: ja     4bf390 <__vfprintf_internal+0x1e0>
    0.00 :   4c0129: movsbl %bl,%edx
    0.00 :   4c012c: lea    0x6d96d(%rip),%rsi        # 52daa0 <step0_jumps.9>
    0.00 :   4c0133: movl   $0x1,0x5c(%rsp)
    0.00 :   4c013b: mov    %rcx,%r14
    0.00 :   4c013e: sub    $0x20,%edx
    0.00 :   4c0141: movslq %edx,%rdx
    0.00 :   4c0144: movzbl (%rax,%rdx,1),%edx
    0.00 :   4c0148: mov    (%rsi,%rdx,8),%rdx
    0.00 :   4c014c: jmp    *%rdx
    0.00 :   4c014e: xchg   %ax,%ax
    0.00 :   4c0150: endbr64
    0.00 :   4c0154: movzbl 0x1(%r14),%ebx
    0.00 :   4c0159: lea    0x1(%r14),%rcx
    0.00 :   4c015d: lea    -0x20(%rbx),%edx
    0.00 :   4c0160: cmp    $0x5a,%dl
    0.00 :   4c0163: ja     4bf390 <__vfprintf_internal+0x1e0>
    0.00 :   4c0169: movsbl %bl,%edx
    0.00 :   4c016c: mov    %rcx,%r14
    0.00 :   4c016f: xor    %r8d,%r8d
    0.00 :   4c0172: mov    $0x1,%r15d
    0.00 :   4c0178: sub    $0x20,%edx
    0.00 :   4c017b: movslq %edx,%rdx
    0.00 :   4c017e: movzbl (%rax,%rdx,1),%edx
    0.00 :   4c0182: mov    (%r11,%rdx,8),%rdx
    0.00 :   4c0186: jmp    *%rdx
    0.00 :   4c0188: nopl   0x0(%rax,%rax,1)
    0.00 :   4c0190: endbr64
    0.00 :   4c0194: movzbl 0x1(%r14),%ebx
    0.00 :   4c0199: lea    0x1(%r14),%rcx
    0.00 :   4c019d: lea    -0x20(%rbx),%edx
    0.00 :   4c01a0: cmp    $0x5a,%dl
    0.00 :   4c01a3: ja     4bf390 <__vfprintf_internal+0x1e0>
    0.00 :   4c01a9: movsbl %bl,%edx
    0.00 :   4c01ac: lea    0x6d5ed(%rip),%rdi        # 52d7a0 <step3a_jumps.6>
    0.00 :   4c01b3: mov    %rcx,%r14
    0.00 :   4c01b6: mov    $0x1,%r8d
    0.00 :   4c01bc: sub    $0x20,%edx
    0.00 :   4c01bf: movslq %edx,%rdx
    0.00 :   4c01c2: movzbl (%rax,%rdx,1),%edx
    0.00 :   4c01c6: mov    (%rdi,%rdx,8),%rdx
    0.00 :   4c01ca: jmp    *%rdx
    0.00 :   4c01cc: nopl   0x0(%rax)
    0.00 :   4c01d0: endbr64
    0.00 :   4c01d4: movzbl 0x1(%r14),%ecx
    0.00 :   4c01d9: lea    0x1(%r14),%rdx
    0.00 :   4c01dd: cmp    $0x2a,%cl
    0.00 :   4c01e0: je     4c0f80 <__vfprintf_internal+0x1dd0>
    0.00 :   4c01e6: lea    -0x30(%rcx),%r13d
    0.00 :   4c01ea: cmp    $0x9,%r13d
    0.00 :   4c01ee: jbe    4c0d40 <__vfprintf_internal+0x1b90>
    0.00 :   4c01f4: movzbl (%rdx),%ebx
    0.00 :   4c01f7: mov    %rdx,%r14
    0.00 :   4c01fa: xor    %r13d,%r13d
    0.00 :   4c01fd: lea    -0x20(%rbx),%edx
    0.00 :   4c0200: cmp    $0x5a,%dl
    0.00 :   4c0203: ja     4bf390 <__vfprintf_internal+0x1e0>
    0.00 :   4c0209: movsbl %bl,%edx
    0.00 :   4c020c: lea    0x6d68d(%rip),%rcx        # 52d8a0 <step2_jumps.7>
    0.00 :   4c0213: sub    $0x20,%edx
    0.00 :   4c0216: movslq %edx,%rdx
    0.00 :   4c0219: movzbl (%rax,%rdx,1),%edx
    0.00 :   4c021d: jmp    *(%rcx,%rdx,8)
    0.00 :   4c0220: endbr64
    0.00 :   4c0224: movzbl (%r14),%edx
    0.00 :   4c0228: movzbl 0x1(%r14),%ecx
    0.00 :   4c022d: lea    -0x30(%rdx),%esi
    0.00 :   4c0230: mov    %ecx,%ebx
    0.00 :   4c0232: lea    0x1(%r14),%rdx
    0.00 :   4c0236: sub    $0x30,%ecx
    0.00 :   4c0239: mov    %esi,0x28(%rsp)
    0.00 :   4c023d: cmp    $0x9,%ecx
    0.00 :   4c0240: ja     4c12c4 <__vfprintf_internal+0x2114>
    0.00 :   4c0246: movzbl 0x1(%rdx),%ebx
    0.00 :   4c024a: mov    %ecx,%edi
    0.00 :   4c024c: add    $0x1,%rdx
    0.00 :   4c0250: movzbl %bl,%ecx
    0.00 :   4c0253: sub    $0x30,%ecx
    0.00 :   4c0256: test   %esi,%esi
    0.00 :   4c0258: js     4c12b7 <__vfprintf_internal+0x2107>
    0.00 :   4c025e: cmp    $0xccccccc,%esi
    0.00 :   4c0264: jg     4c0430 <__vfprintf_internal+0x1280>
    0.00 :   4c026a: lea    (%rsi,%rsi,4),%esi
    0.00 :   4c026d: mov    $0x7fffffff,%r14d
    0.00 :   4c0273: add    %esi,%esi
    0.00 :   4c0275: sub    %edi,%r14d
    0.00 :   4c0278: cmp    %r14d,%esi
    0.00 :   4c027b: jg     4c0430 <__vfprintf_internal+0x1280>
    0.00 :   4c0281: add    %edi,%esi
    0.00 :   4c0283: cmp    $0x9,%ecx
    0.00 :   4c0286: jbe    4c0246 <__vfprintf_internal+0x1096>
    0.00 :   4c0288: mov    %esi,0x28(%rsp)
    0.00 :   4c028c: mov    %rdx,%r14
    0.00 :   4c028f: nop
    0.00 :   4c0290: cmp    $0x24,%bl
    0.00 :   4c0293: je     4bf39c <__vfprintf_internal+0x1ec>
    0.00 :   4c0299: lea    -0x20(%rbx),%edx
    0.00 :   4c029c: cmp    $0x5a,%dl
    0.00 :   4c029f: ja     4bf390 <__vfprintf_internal+0x1e0>
    0.00 :   4c02a5: movsbl %bl,%edx
    0.00 :   4c02a8: lea    0x6d6f1(%rip),%rcx        # 52d9a0 <step1_jumps.8>
    0.00 :   4c02af: sub    $0x20,%edx
    0.00 :   4c02b2: movslq %edx,%rdx
    0.00 :   4c02b5: movzbl (%rax,%rdx,1),%edx
    0.00 :   4c02b9: jmp    *(%rcx,%rdx,8)
    0.00 :   4c02bc: nopl   0x0(%rax)
    0.00 :   4c02c0: endbr64
    0.00 :   4c02c4: movzbl 0x1(%r14),%ecx
    0.00 :   4c02c9: lea    0x1(%r14),%rdi
    0.00 :   4c02cd: mov    %rdi,0x60(%rsp)
    0.00 :   4c02d2: sub    $0x30,%ecx
    0.00 :   4c02d5: cmp    $0x9,%ecx
    0.00 :   4c02d8: jbe    4c0fe0 <__vfprintf_internal+0x1e30>
    0.00 :   4c02de: mov    0x20(%rsp),%rsi
    0.00 :   4c02e3: mov    (%rsi),%edx
    0.00 :   4c02e5: cmp    $0x2f,%edx
    0.00 :   4c02e8: jbe    4c0ba8 <__vfprintf_internal+0x19f8>
    0.00 :   4c02ee: mov    0x8(%rsi),%rcx
    0.00 :   4c02f2: lea    0x8(%rcx),%rdx
    0.00 :   4c02f6: mov    %rdx,0x8(%rsi)
    0.00 :   4c02fa: mov    (%rcx),%edi
    0.00 :   4c02fc: mov    %edi,0x28(%rsp)
    0.00 :   4c0300: test   %edi,%edi
    0.00 :   4c0302: jns    4c0317 <__vfprintf_internal+0x1167>
    0.00 :   4c0304: neg    %edi
    0.00 :   4c0306: movb   $0x20,0x40(%rsp)
    0.00 :   4c030b: mov    %edi,0x28(%rsp)
    0.00 :   4c030f: movl   $0x1,0x30(%rsp)
    0.00 :   4c0317: movzbl 0x1(%r14),%ebx
    0.00 :   4c031c: lea    -0x20(%rbx),%edx
    0.00 :   4c031f: cmp    $0x5a,%dl
    0.00 :   4c0322: ja     4bf390 <__vfprintf_internal+0x1e0>
    0.00 :   4c0328: movsbl %bl,%edx
    0.00 :   4c032b: lea    0x6d66e(%rip),%rcx        # 52d9a0 <step1_jumps.8>
    0.00 :   4c0332: mov    0x60(%rsp),%r14
    0.00 :   4c0337: sub    $0x20,%edx
    0.00 :   4c033a: movslq %edx,%rdx
    0.00 :   4c033d: movzbl (%rax,%rdx,1),%edx
    0.00 :   4c0341: mov    (%rcx,%rdx,8),%rdx
    0.00 :   4c0345: jmp    *%rdx
    0.00 :   4c0347: nopw   0x0(%rax,%rax,1)
    0.00 :   4c0350: endbr64
    0.00 :   4c0354: cmpq   $0xffffffffffffffff,0x80(%rsp)
    0.00 :   4c035d: je     4c10c0 <__vfprintf_internal+0x1f10>
    0.00 :   4c0363: movzbl 0x1(%r14),%ebx
    0.00 :   4c0368: lea    0x1(%r14),%rcx
    0.00 :   4c036c: lea    -0x20(%rbx),%edx
    0.00 :   4c036f: cmp    $0x5a,%dl
    0.00 :   4c0372: ja     4bf390 <__vfprintf_internal+0x1e0>
    0.00 :   4c0378: movsbl %bl,%edx
    0.00 :   4c037b: lea    0x6d71e(%rip),%rdi        # 52daa0 <step0_jumps.9>
    0.00 :   4c0382: movl   $0x1,0x70(%rsp)
    0.00 :   4c038a: mov    %rcx,%r14
    0.00 :   4c038d: sub    $0x20,%edx
    0.00 :   4c0390: movslq %edx,%rdx
    0.00 :   4c0393: movzbl (%rax,%rdx,1),%edx
    0.00 :   4c0397: mov    (%rdi,%rdx,8),%rdx
    0.00 :   4c039b: jmp    *%rdx
    0.00 :   4c039d: nopl   (%rax)
    0.00 :   4c03a0: endbr64
    0.00 :   4c03a4: mov    0x30(%rsp),%esi
    0.00 :   4c03a8: mov    $0x30,%edx
    0.00 :   4c03ad: movzbl 0x1(%r14),%ebx
    0.00 :   4c03b2: lea    0x1(%r14),%rcx
    0.00 :   4c03b6: test   %esi,%esi
    0.00 :   4c03b8: movzbl 0x40(%rsp),%esi
    0.00 :   4c03bd: cmove  %edx,%esi
    0.00 :   4c03c0: lea    -0x20(%rbx),%edx
    0.00 :   4c03c3: mov    %sil,0x40(%rsp)
    0.00 :   4c03c8: cmp    $0x5a,%dl
    0.00 :   4c03cb: ja     4bf390 <__vfprintf_internal+0x1e0>
    0.00 :   4c03d1: movsbl %bl,%edx
    0.00 :   4c03d4: lea    0x6d6c5(%rip),%rsi        # 52daa0 <step0_jumps.9>
    0.00 :   4c03db: mov    %rcx,%r14
    0.00 :   4c03de: sub    $0x20,%edx
    0.00 :   4c03e1: movslq %edx,%rdx
    0.00 :   4c03e4: movzbl (%rax,%rdx,1),%edx
    0.00 :   4c03e8: mov    (%rsi,%rdx,8),%rdx
    0.00 :   4c03ec: jmp    *%rdx
    0.00 :   4c03ee: xchg   %ax,%ax
    0.00 :   4c03f0: endbr64
    0.00 :   4c03f4: movzbl 0x1(%r14),%ebx
    0.00 :   4c03f9: lea    0x1(%r14),%rcx
    0.00 :   4c03fd: lea    -0x20(%rbx),%edx
    0.00 :   4c0400: cmp    $0x5a,%dl
    0.00 :   4c0403: ja     4bf390 <__vfprintf_internal+0x1e0>
    0.00 :   4c0409: movsbl %bl,%edx
    0.00 :   4c040c: lea    0x6d68d(%rip),%rsi        # 52daa0 <step0_jumps.9>
    0.00 :   4c0413: movl   $0x1,0x78(%rsp)
    0.00 :   4c041b: mov    %rcx,%r14
    0.00 :   4c041e: sub    $0x20,%edx
    0.00 :   4c0421: movslq %edx,%rdx
    0.00 :   4c0424: movzbl (%rax,%rdx,1),%edx
    0.00 :   4c0428: mov    (%rsi,%rdx,8),%rdx
    0.00 :   4c042c: jmp    *%rdx
    0.00 :   4c042e: xchg   %ax,%ax
    0.00 :   4c0430: cmp    $0x9,%ecx
    0.00 :   4c0433: ja     4bf9f0 <__vfprintf_internal+0x840>
    0.00 :   4c0439: movzbl 0x1(%rdx),%ecx
    0.00 :   4c043d: sub    $0x30,%ecx
    0.00 :   4c0440: cmp    $0x9,%ecx
    0.00 :   4c0443: ja     4bf9f0 <__vfprintf_internal+0x840>
    0.00 :   4c0449: movzbl 0x2(%rdx),%ecx
    0.00 :   4c044d: add    $0x2,%rdx
    0.00 :   4c0451: sub    $0x30,%ecx
    0.00 :   4c0454: cmp    $0x9,%ecx
    0.00 :   4c0457: ja     4bf9f0 <__vfprintf_internal+0x840>
    0.00 :   4c045d: movl   $0xffffffff,0x28(%rsp)
    0.00 :   4c0465: add    $0x1,%rdx
    0.00 :   4c0469: nopl   0x0(%rax)
    0.00 :   4c0470: movzbl (%rdx),%ecx
    0.00 :   4c0473: mov    %rdx,%r14
    0.00 :   4c0476: add    $0x1,%rdx
    0.00 :   4c047a: mov    %ecx,%ebx
    0.00 :   4c047c: sub    $0x30,%ecx
    0.00 :   4c047f: cmp    $0x9,%ecx
    0.00 :   4c0482: jbe    4c0470 <__vfprintf_internal+0x12c0>
    0.00 :   4c0484: jmp    4c12d0 <__vfprintf_internal+0x2120>
    0.00 :   4c0489: nopl   0x0(%rax)
    0.00 :   4c0490: test   %r9d,%r9d
    0.00 :   4c0493: je     4c07c0 <__vfprintf_internal+0x1610>
    0.00 :   4c0499: mov    0x28(%rbp),%rax
    0.00 :   4c049d: cmp    0x30(%rbp),%rax
    0.00 :   4c04a1: jae    4c0770 <__vfprintf_internal+0x15c0>
    0.00 :   4c04a7: lea    0x1(%rax),%rcx
    0.00 :   4c04ab: mov    %rcx,0x28(%rbp)
    0.00 :   4c04af: movb   $0x2d,(%rax)
    0.00 :   4c04b2: cmp    $0x7fffffff,%r12d
    0.00 :   4c04b9: je     4c07a8 <__vfprintf_internal+0x15f8>
    0.00 :   4c04bf: subl   $0x1,0x28(%rsp)
    0.00 :   4c04c4: add    $0x1,%r12d
    0.00 :   4c04c8: test   %r11,%r11
    0.00 :   4c04cb: je     4c04d9 <__vfprintf_internal+0x1329>
    0.00 :   4c04cd: mov    0x58(%rsp),%eax
    0.00 :   4c04d1: test   %eax,%eax
    0.00 :   4c04d3: jne    4c09b0 <__vfprintf_internal+0x1800>
    0.00 :   4c04d9: mov    0x28(%rsp),%ebx
    0.00 :   4c04dd: add    %r15d,%edx
    0.00 :   4c04e0: sub    %edx,%ebx
    0.00 :   4c04e2: test   %r13d,%r13d
    0.00 :   4c04e5: jle    4c052f <__vfprintf_internal+0x137f>
    0.00 :   4c04e7: movslq %r13d,%rdx
    0.00 :   4c04ea: mov    $0x30,%esi
    0.00 :   4c04ef: mov    %rbp,%rdi
    0.00 :   4c04f2: mov    %rdx,0x28(%rsp)
    0.00 :   4c04f7: call   4c8950 <_IO_padn>
    0.00 :   4c04fc: mov    0x28(%rsp),%rdx
    0.00 :   4c0501: cmp    %rax,%rdx
    0.00 :   4c0504: jne    4c07a8 <__vfprintf_internal+0x15f8>
    0.00 :   4c050a: xor    %eax,%eax
    0.00 :   4c050c: add    %r13d,%r12d
    0.00 :   4c050f: js     4c14cc <__vfprintf_internal+0x231c>
    0.00 :   4c0515: cmp    %edx,%r12d
    0.00 :   4c0518: jb     4c14cc <__vfprintf_internal+0x231c>
    0.00 :   4c051e: test   %eax,%eax
    0.00 :   4c0520: jne    4bf9f0 <__vfprintf_internal+0x840>
    0.00 :   4c0526: test   %r12d,%r12d
    0.00 :   4c0529: js     4bf3f8 <__vfprintf_internal+0x248>
    0.00 :   4c052f: mov    0xd8(%rbp),%r13
    0.00 :   4c0536: mov    %r13,%rax
    0.00 :   4c0539: sub    $0x532b60,%rax
    0.00 :   4c0540: cmp    %rax,0x10(%rsp)
    0.00 :   4c0545: jbe    4c1127 <__vfprintf_internal+0x1f77>
    0.00 :   4c054b: mov    0x38(%rsp),%rsi
    0.00 :   4c0550: mov    %r15,%rdx
    0.00 :   4c0553: mov    %rbp,%rdi
    0.00 :   4c0556: call   *0x38(%r13)
    0.00 :   4c055a: cmp    %r15,%rax
    0.00 :   4c055d: jne    4c07a8 <__vfprintf_internal+0x15f8>
    0.00 :   4c0563: movslq %r12d,%rax
    0.00 :   4c0566: xor    %edx,%edx
    0.00 :   4c0568: add    %r15,%rax
    0.00 :   4c056b: js     4c1472 <__vfprintf_internal+0x22c2>
    0.00 :   4c0571: cmp    %r15,%rax
    0.00 :   4c0574: jb     4c1472 <__vfprintf_internal+0x22c2>
    0.00 :   4c057a: movslq %eax,%rcx
    0.00 :   4c057d: mov    %eax,%r12d
    0.00 :   4c0580: cmp    %rcx,%rax
    0.00 :   4c0583: mov    $0x1,%ecx
    0.00 :   4c0588: cmovne %ecx,%edx
    0.00 :   4c058b: test   %edx,%edx
    0.00 :   4c058d: jne    4bf9f0 <__vfprintf_internal+0x840>
    0.00 :   4c0593: test   %eax,%eax
    0.00 :   4c0595: js     4bf3f8 <__vfprintf_internal+0x248>
    0.00 :   4c059b: test   %ebx,%ebx
    0.00 :   4c059d: jle    4bf830 <__vfprintf_internal+0x680>
    0.00 :   4c05a3: movslq %ebx,%rbx
    0.00 :   4c05a6: mov    $0x20,%esi
    0.00 :   4c05ab: mov    %rbp,%rdi
    0.00 :   4c05ae: mov    %rbx,%rdx
    0.00 :   4c05b1: call   4c8950 <_IO_padn>
    0.00 :   4c05b6: cmp    %rax,%rbx
    0.00 :   4c05b9: jne    4c07a8 <__vfprintf_internal+0x15f8>
    0.00 :   4c05bf: add    %r12d,%ebx
    0.00 :   4c05c2: mov    %ebx,%r12d
    0.00 :   4c05c5: jo     4bf9f0 <__vfprintf_internal+0x840>
    0.00 :   4c05cb: test   %r12d,%r12d
    0.00 :   4c05ce: jns    4bf830 <__vfprintf_internal+0x680>
    0.00 :   4c05d4: jmp    4bf3f8 <__vfprintf_internal+0x248>
    0.00 :   4c05d9: nopl   0x0(%rax)
    0.00 :   4c05e0: test   %r11,%r11
    0.00 :   4c05e3: jne    4c0878 <__vfprintf_internal+0x16c8>
    0.00 :   4c05e9: cmp    $0x8,%r10d
    0.00 :   4c05ed: jne    4c0a48 <__vfprintf_internal+0x1898>
    0.00 :   4c05f3: mov    0x58(%rsp),%ecx
    0.00 :   4c05f7: test   %ecx,%ecx
    0.00 :   4c05f9: je     4c0a48 <__vfprintf_internal+0x1898>
    0.00 :   4c05ff: lea    0x527(%rsp),%rax
    0.00 :   4c0607: movb   $0x30,0x527(%rsp)
    0.00 :   4c060f: mov    $0x1,%r15d
    0.00 :   4c0615: mov    %rax,0x38(%rsp)
    0.00 :   4c061a: movb   $0x20,0x40(%rsp)
    0.00 :   4c061f: xor    %edx,%edx
    0.00 :   4c0621: mov    0x30(%rsp),%eax
    0.00 :   4c0625: test   %eax,%eax
    0.00 :   4c0627: jne    4c0490 <__vfprintf_internal+0x12e0>
    0.00 :   4c062d: mov    0x28(%rsp),%r8d
    0.00 :   4c0632: add    %r15d,%edx
    0.00 :   4c0635: sub    %edx,%r8d
    0.00 :   4c0638: jmp    4bfd2e <__vfprintf_internal+0xb7e>
    0.00 :   4c063d: nopl   (%rax)
    0.00 :   4c0640: test   %r11,%r11
    0.00 :   4c0643: je     4c0f30 <__vfprintf_internal+0x1d80>
    0.00 :   4c0649: cmp    $0x8,%r10d
    0.00 :   4c064d: jne    4c066f <__vfprintf_internal+0x14bf>
    0.00 :   4c064f: mov    0x58(%rsp),%eax
    0.00 :   4c0653: test   %eax,%eax
    0.00 :   4c0655: je     4c066f <__vfprintf_internal+0x14bf>
    0.00 :   4c0657: mov    0x38(%rsp),%rsi
    0.00 :   4c065c: mov    %r13,%r15
    0.00 :   4c065f: lea    -0x1(%rsi),%rax
    0.00 :   4c0663: movb   $0x30,-0x1(%rsi)
    0.00 :   4c0667: mov    %rax,0x38(%rsp)
    0.00 :   4c066c: sub    %rax,%r15
    0.00 :   4c066f: mov    0x60(%rsp),%rdx
    0.00 :   4c0674: mov    $0x0,%eax
    0.00 :   4c0679: mov    0x30(%rsp),%ecx
    0.00 :   4c067d: sub    %r15,%rdx
    0.00 :   4c0680: cmovs  %rax,%rdx
    0.00 :   4c0684: mov    %edx,%r13d
    0.00 :   4c0687: test   %ecx,%ecx
    0.00 :   4c0689: jne    4c0490 <__vfprintf_internal+0x12e0>
    0.00 :   4c068f: mov    0x28(%rsp),%r8d
    0.00 :   4c0694: sub    %r15d,%r8d
    0.00 :   4c0697: sub    %edx,%r8d
    0.00 :   4c069a: jmp    4bfd11 <__vfprintf_internal+0xb61>
    0.00 :   4c069f: nop
    0.00 :   4c06a0: mov    0x528(%rsp),%rax
    0.00 :   4c06a8: sub    %fs:0x28,%rax
    0.00 :   4c06b1: jne    4c147c <__vfprintf_internal+0x22cc>
    0.00 :   4c06b7: mov    0x6c(%rsp),%ecx
    0.00 :   4c06bb: mov    0x20(%rsp),%rdx
    0.00 :   4c06c0: mov    %rbp,%rdi
    0.00 :   4c06c3: mov    0x8(%rsp),%rsi
    0.00 :   4c06c8: add    $0x538,%rsp
    0.00 :   4c06cf: pop    %rbx
    0.00 :   4c06d0: pop    %rbp
    0.00 :   4c06d1: pop    %r12
    0.00 :   4c06d3: pop    %r13
    0.00 :   4c06d5: pop    %r14
    0.00 :   4c06d7: pop    %r15
    0.00 :   4c06d9: jmp    4c14f0 <buffered_vfprintf>
    0.00 :   4c06de: xchg   %ax,%ax
    0.00 :   4c06e0: cmpb   $0x20,0x40(%rsp)
    0.00 :   4c06e5: jne    4bfd81 <__vfprintf_internal+0xbd1>
    0.00 :   4c06eb: test   %r8d,%r8d
    0.00 :   4c06ee: jle    4c14b0 <__vfprintf_internal+0x2300>
    0.00 :   4c06f4: movslq %r8d,%rdx
    0.00 :   4c06f7: mov    $0x20,%esi
    0.00 :   4c06fc: mov    %rbp,%rdi
    0.00 :   4c06ff: mov    %r9d,0x70(%rsp)
    0.00 :   4c0704: mov    %rdx,0x28(%rsp)
    0.00 :   4c0709: mov    %r10d,0x60(%rsp)
    0.00 :   4c070e: mov    %r11,0x40(%rsp)
    0.00 :   4c0713: mov    %r8d,0x30(%rsp)
    0.00 :   4c0718: call   4c8950 <_IO_padn>
    0.00 :   4c071d: mov    0x28(%rsp),%rdx
    0.00 :   4c0722: cmp    %rax,%rdx
    0.00 :   4c0725: jne    4c07a8 <__vfprintf_internal+0x15f8>
    0.00 :   4c072b: mov    0x30(%rsp),%r8d
    0.00 :   4c0730: xor    %eax,%eax
    0.00 :   4c0732: mov    0x40(%rsp),%r11
    0.00 :   4c0737: mov    0x60(%rsp),%r10d
    0.00 :   4c073c: mov    0x70(%rsp),%r9d
    0.00 :   4c0741: add    %r8d,%r12d
    0.00 :   4c0744: js     4c14e3 <__vfprintf_internal+0x2333>
    0.00 :   4c074a: cmp    %edx,%r12d
    0.00 :   4c074d: jb     4c14e3 <__vfprintf_internal+0x2333>
    0.00 :   4c0753: mov    %eax,%r8d
    0.00 :   4c0756: test   %eax,%eax
    0.00 :   4c0758: jne    4bf9f0 <__vfprintf_internal+0x840>
    0.00 :   4c075e: test   %r12d,%r12d
    0.00 :   4c0761: jns    4bfd4e <__vfprintf_internal+0xb9e>
    0.00 :   4c0767: jmp    4bf3f8 <__vfprintf_internal+0x248>
    0.00 :   4c076c: nopl   0x0(%rax)
    0.00 :   4c0770: mov    %r10d,0x54(%rsp)
    0.00 :   4c0775: mov    $0x2d,%esi
    0.00 :   4c077a: mov    %rdx,0x40(%rsp)
    0.00 :   4c077f: mov    %r11,0x30(%rsp)
    0.00 :   4c0784: mov    %rbp,%rdi
    0.00 :   4c0787: call   45c390 <__overflow>
    0.00 :   4c078c: mov    0x30(%rsp),%r11
    0.00 :   4c0791: mov    0x40(%rsp),%rdx
    0.00 :   4c0796: cmp    $0xffffffff,%eax
    0.00 :   4c0799: mov    0x54(%rsp),%r10d
    0.00 :   4c079e: jne    4c04b2 <__vfprintf_internal+0x1302>
    0.00 :   4c07a4: nopl   0x0(%rax)
    0.00 :   4c07a8: mov    $0xffffffff,%r12d
    0.00 :   4c07ae: testl  $0x8000,0x0(%rbp)
    0.00 :   4c07b5: jne    4bf401 <__vfprintf_internal+0x251>
    0.00 :   4c07bb: jmp    4bf440 <__vfprintf_internal+0x290>
    0.00 :   4c07c0: mov    0x54(%rsp),%eax
    0.00 :   4c07c4: test   %eax,%eax
    0.00 :   4c07c6: je     4c0980 <__vfprintf_internal+0x17d0>
    0.00 :   4c07cc: mov    0x28(%rbp),%rax
    0.00 :   4c07d0: cmp    0x30(%rbp),%rax
    0.00 :   4c07d4: jae    4c1338 <__vfprintf_internal+0x2188>
    0.00 :   4c07da: lea    0x1(%rax),%rcx
    0.00 :   4c07de: mov    %rcx,0x28(%rbp)
    0.00 :   4c07e2: movb   $0x2b,(%rax)
    0.00 :   4c07e5: jmp    4c04b2 <__vfprintf_internal+0x1302>
    0.00 :   4c07ea: nopw   0x0(%rax,%rax,1)
    0.00 :   4c07f0: call   458f50 <_IO_vtable_check>
    0.00 :   4c07f5: jmp    4bf86b <__vfprintf_internal+0x6bb>
    0.00 :   4c07fa: nopw   0x0(%rax,%rax,1)
    0.00 :   4c0800: movslq %ebx,%r13
    0.00 :   4c0803: mov    $0x30,%esi
    0.00 :   4c0808: mov    %rbp,%rdi
    0.00 :   4c080b: mov    %r13,%rdx
    0.00 :   4c080e: call   4c8950 <_IO_padn>
    0.00 :   4c0813: cmp    %rax,%r13
    0.00 :   4c0816: jne    4c07a8 <__vfprintf_internal+0x15f8>
    0.00 :   4c0818: xor    %eax,%eax
    0.00 :   4c081a: add    %ebx,%r12d
    0.00 :   4c081d: js     4c14c2 <__vfprintf_internal+0x2312>
    0.00 :   4c0823: cmp    %ebx,%r12d
    0.00 :   4c0826: jb     4c14c2 <__vfprintf_internal+0x2312>
    0.00 :   4c082c: test   %eax,%eax
    0.00 :   4c082e: jne    4bf9f0 <__vfprintf_internal+0x840>
    0.00 :   4c0834: test   %r12d,%r12d
    0.00 :   4c0837: jns    4bfdfc <__vfprintf_internal+0xc4c>
    0.00 :   4c083d: jmp    4bf3f8 <__vfprintf_internal+0x248>
    0.00 :   4c0842: nopw   0x0(%rax,%rax,1)
    0.00 :   4c0848: mov    0x54(%rsp),%esi
    0.00 :   4c084c: test   %esi,%esi
    0.00 :   4c084e: je     4c0f50 <__vfprintf_internal+0x1da0>
    0.00 :   4c0854: mov    0x28(%rbp),%rax
    0.00 :   4c0858: cmp    0x30(%rbp),%rax
    0.00 :   4c085c: jae    4c131f <__vfprintf_internal+0x216f>
    0.00 :   4c0862: lea    0x1(%rax),%rdx
    0.00 :   4c0866: mov    %rdx,0x28(%rbp)
    0.00 :   4c086a: movb   $0x2b,(%rax)
    0.00 :   4c086d: jmp    4bfd70 <__vfprintf_internal+0xbc0>
    0.00 :   4c0872: nopw   0x0(%rax,%rax,1)
    0.00 :   4c0878: movq   $0x0,0x60(%rsp)
    0.00 :   4c0881: movb   $0x20,0x40(%rsp)
    0.00 :   4c0886: jmp    4bfbd0 <__vfprintf_internal+0xa20>
    0.00 :   4c088b: nopl   0x0(%rax,%rax,1)
    0.00 :   4c0890: test   %r8d,%r8d
    0.00 :   4c0893: jne    4c0b40 <__vfprintf_internal+0x1990>
    0.00 :   4c0899: cmp    $0x2f,%eax
    0.00 :   4c089c: ja     4c0cbe <__vfprintf_internal+0x1b0e>
    0.00 :   4c08a2: mov    %eax,%edx
    0.00 :   4c08a4: add    $0x8,%eax
    0.00 :   4c08a7: add    0x10(%rdi),%rdx
    0.00 :   4c08ab: mov    %eax,(%rdi)
    0.00 :   4c08ad: movl   $0x0,0x54(%rsp)
    0.00 :   4c08b5: mov    (%rdx),%r11d
    0.00 :   4c08b8: xor    %r9d,%r9d
    0.00 :   4c08bb: movl   $0x0,0x5c(%rsp)
    0.00 :   4c08c3: jmp    4bfbb0 <__vfprintf_internal+0xa00>
    0.00 :   4c08c8: nopl   0x0(%rax,%rax,1)
    0.00 :   4c08d0: mov    0x8(%rdi),%rdx
    0.00 :   4c08d4: lea    0x8(%rdx),%rax
    0.00 :   4c08d8: mov    %rax,0x8(%rdi)
    0.00 :   4c08dc: jmp    4bfe9a <__vfprintf_internal+0xcea>
    0.00 :   4c08e1: nopl   0x0(%rax)
    0.00 :   4c08e8: mov    0x20(%rsp),%rdi
    0.00 :   4c08ed: mov    0x8(%rdi),%rax
    0.00 :   4c08f1: mov    %rax,0x28(%rsp)
    0.00 :   4c08f6: add    $0xf,%rax
    0.00 :   4c08fa: and    $0xfffffffffffffff0,%rax
    0.00 :   4c08fe: lea    0x10(%rax),%rdx
    0.00 :   4c0902: mov    %rdx,0x8(%rdi)
    0.00 :   4c0906: fldt   (%rax)
    0.00 :   4c0908: fstpt  0xc0(%rsp)
    0.00 :   4c090f: lea    0xc0(%rsp),%rax
    0.00 :   4c0917: and    $0xffffffdf,%ebx
    0.00 :   4c091a: mov    %rbp,%rdi
    0.00 :   4c091d: mov    %rax,0xb8(%rsp)
    0.00 :   4c0925: lea    0xb8(%rsp),%rdx
    0.00 :   4c092d: lea    0xd0(%rsp),%rsi
    0.00 :   4c0935: cmp    $0x41,%ebx
    0.00 :   4c0938: jne    4c0970 <__vfprintf_internal+0x17c0>
    0.00 :   4c093a: call   4de8d0 <__printf_fphex>
    0.00 :   4c093f: test   %eax,%eax
    0.00 :   4c0941: js     4c07a8 <__vfprintf_internal+0x15f8>
    0.00 :   4c0947: xor    %edx,%edx
    0.00 :   4c0949: add    %eax,%r12d
    0.00 :   4c094c: js     4c1481 <__vfprintf_internal+0x22d1>
    0.00 :   4c0952: cmp    %eax,%r12d
    0.00 :   4c0955: jb     4c1481 <__vfprintf_internal+0x22d1>
    0.00 :   4c095b: test   %edx,%edx
    0.00 :   4c095d: je     4c05cb <__vfprintf_internal+0x141b>
    0.00 :   4c0963: jmp    4bf9f0 <__vfprintf_internal+0x840>
    0.00 :   4c0968: nopl   0x0(%rax,%rax,1)
    0.00 :   4c0970: call   4de680 <___printf_fp>
    0.00 :   4c0975: jmp    4c093f <__vfprintf_internal+0x178f>
    0.00 :   4c0977: nopw   0x0(%rax,%rax,1)
    0.00 :   4c0980: mov    0x5c(%rsp),%eax
    0.00 :   4c0984: test   %eax,%eax
    0.00 :   4c0986: je     4c04c8 <__vfprintf_internal+0x1318>
    0.00 :   4c098c: mov    0x28(%rbp),%rax
    0.00 :   4c0990: cmp    0x30(%rbp),%rax
    0.00 :   4c0994: jae    4c13e5 <__vfprintf_internal+0x2235>
    0.00 :   4c099a: lea    0x1(%rax),%rcx
    0.00 :   4c099e: mov    %rcx,0x28(%rbp)
    0.00 :   4c09a2: movb   $0x20,(%rax)
    0.00 :   4c09a5: jmp    4c04b2 <__vfprintf_internal+0x1302>
    0.00 :   4c09aa: nopw   0x0(%rax,%rax,1)
    0.00 :   4c09b0: mov    $0x10004,%eax
    0.00 :   4c09b5: bt     %r10,%rax
    0.00 :   4c09b9: jae    4c04d9 <__vfprintf_internal+0x1329>
    0.00 :   4c09bf: mov    0x28(%rbp),%rax
    0.00 :   4c09c3: cmp    0x30(%rbp),%rax
    0.00 :   4c09c7: jae    4c1440 <__vfprintf_internal+0x2290>
    0.00 :   4c09cd: lea    0x1(%rax),%rcx
    0.00 :   4c09d1: mov    %rcx,0x28(%rbp)
    0.00 :   4c09d5: movb   $0x30,(%rax)
    0.00 :   4c09d8: cmp    $0x7fffffff,%r12d
    0.00 :   4c09df: je     4c07a8 <__vfprintf_internal+0x15f8>
    0.00 :   4c09e5: mov    0x28(%rbp),%rax
    0.00 :   4c09e9: cmp    0x30(%rbp),%rax
    0.00 :   4c09ed: jae    4c1417 <__vfprintf_internal+0x2267>
    0.00 :   4c09f3: lea    0x1(%rax),%rcx
    0.00 :   4c09f7: mov    %rcx,0x28(%rbp)
    0.00 :   4c09fb: mov    %bl,(%rax)
    0.00 :   4c09fd: cmp    $0x7ffffffe,%r12d
    0.00 :   4c0a04: je     4c07a8 <__vfprintf_internal+0x15f8>
    0.00 :   4c0a0a: subl   $0x2,0x28(%rsp)
    0.00 :   4c0a0f: add    $0x2,%r12d
    0.00 :   4c0a13: jmp    4c04d9 <__vfprintf_internal+0x1329>
    0.00 :   4c0a18: nopl   0x0(%rax,%rax,1)
    0.00 :   4c0a20: call   458f50 <_IO_vtable_check>
    0.00 :   4c0a25: jmp    4bf2b4 <__vfprintf_internal+0x104>
    0.00 :   4c0a2a: nopw   0x0(%rax,%rax,1)
    0.00 :   4c0a30: mov    0x8(%rsi),%rcx
    0.00 :   4c0a34: lea    0x8(%rcx),%rax
    0.00 :   4c0a38: mov    %rax,0x8(%rsi)
    0.00 :   4c0a3c: jmp    4bf773 <__vfprintf_internal+0x5c3>
    0.00 :   4c0a41: nopl   0x0(%rax)
    0.00 :   4c0a48: lea    0x528(%rsp),%rax
    0.00 :   4c0a50: xor    %r15d,%r15d
    0.00 :   4c0a53: mov    %rax,0x38(%rsp)
    0.00 :   4c0a58: jmp    4c061a <__vfprintf_internal+0x146a>
    0.00 :   4c0a5d: nopl   (%rax)
    0.00 :   4c0a60: movl   $0x0,0xa0(%rsp)
    0.00 :   4c0a6b: movq   $0xffffffffffffffff,0x80(%rsp)
    0.00 :   4c0a77: jmp    4bf3a0 <__vfprintf_internal+0x1f0>
    0.00 :   4c0a7c: nopl   0x0(%rax)
    0.00 :   4c0a80: mov    0x8(%rdi),%rdx
    0.00 :   4c0a84: lea    0x8(%rdx),%rax
    0.00 :   4c0a88: mov    %rax,0x8(%rdi)
    0.00 :   4c0a8c: jmp    4bff03 <__vfprintf_internal+0xd53>
    0.00 :   4c0a91: nopl   0x0(%rax)
    0.00 :   4c0a98: mov    0x8(%rsi),%rdx
    0.00 :   4c0a9c: lea    0x8(%rdx),%rax
    0.00 :   4c0aa0: mov    %rax,0x8(%rsi)
    0.00 :   4c0aa4: jmp    4bfb7f <__vfprintf_internal+0x9cf>
    0.00 :   4c0aa9: nopl   0x0(%rax)
    0.00 :   4c0ab0: mov    0x8(%rsi),%rdx
    0.00 :   4c0ab4: lea    0x8(%rdx),%rax
    0.00 :   4c0ab8: mov    %rax,0x8(%rsi)
    0.00 :   4c0abc: jmp    4bf8ef <__vfprintf_internal+0x73f>
    0.00 :   4c0ac1: nopl   0x0(%rax)
    0.00 :   4c0ac8: mov    0x7c(%rsp),%edi
    0.00 :   4c0acc: lea    0x140(%rsp),%rsi
    0.00 :   4c0ad4: mov    $0x3e8,%edx
    0.00 :   4c0ad9: call   4caa40 <__strerror_r>
    0.00 :   4c0ade: mov    %rax,%r10
    0.00 :   4c0ae1: jmp    4bfa2e <__vfprintf_internal+0x87e>
    0.00 :   4c0ae6: cs nopw 0x0(%rax,%rax,1)
    0.00 :   4c0af0: mov    0x20(%rsp),%rsi
    0.00 :   4c0af5: mov    (%rsi),%eax
    0.00 :   4c0af7: test   %r15d,%r15d
    0.00 :   4c0afa: jne    4c0ca1 <__vfprintf_internal+0x1af1>
    0.00 :   4c0b00: test   %r8d,%r8d
    0.00 :   4c0b03: jne    4c11ce <__vfprintf_internal+0x201e>
    0.00 :   4c0b09: cmp    $0x2f,%eax
    0.00 :   4c0b0c: ja     4c1362 <__vfprintf_internal+0x21b2>
    0.00 :   4c0b12: mov    %eax,%edx
    0.00 :   4c0b14: add    $0x8,%eax
    0.00 :   4c0b17: add    0x10(%rsi),%rdx
    0.00 :   4c0b1b: mov    %eax,(%rsi)
    0.00 :   4c0b1d: movslq (%rdx),%r9
    0.00 :   4c0b20: mov    %r9,%r11
    0.00 :   4c0b23: test   %r9,%r9
    0.00 :   4c0b26: js     4c0ec8 <__vfprintf_internal+0x1d18>
    0.00 :   4c0b2c: xor    %r9d,%r9d
    0.00 :   4c0b2f: mov    $0xa,%r10d
    0.00 :   4c0b35: jmp    4bfbb0 <__vfprintf_internal+0xa00>
    0.00 :   4c0b3a: nopw   0x0(%rax,%rax,1)
    0.00 :   4c0b40: cmp    $0x2f,%eax
    0.00 :   4c0b43: ja     4c0cd7 <__vfprintf_internal+0x1b27>
    0.00 :   4c0b49: mov    %eax,%edx
    0.00 :   4c0b4b: add    $0x8,%eax
    0.00 :   4c0b4e: add    0x10(%rdi),%rdx
    0.00 :   4c0b52: mov    %eax,(%rdi)
    0.00 :   4c0b54: movl   $0x0,0x54(%rsp)
    0.00 :   4c0b5c: movzwl (%rdx),%r11d
    0.00 :   4c0b60: xor    %r9d,%r9d
    0.00 :   4c0b63: movl   $0x0,0x5c(%rsp)
    0.00 :   4c0b6b: jmp    4bfbb0 <__vfprintf_internal+0xa00>
    0.00 :   4c0b70: test   %r15d,%r15d
    0.00 :   4c0b73: jne    4c0ccf <__vfprintf_internal+0x1b1f>
    0.00 :   4c0b79: test   %r8d,%r8d
    0.00 :   4c0b7c: jne    4c11eb <__vfprintf_internal+0x203b>
    0.00 :   4c0b82: mov    %r12d,(%rax)
    0.00 :   4c0b85: jmp    4bf830 <__vfprintf_internal+0x680>
    0.00 :   4c0b8a: nopw   0x0(%rax,%rax,1)
    0.00 :   4c0b90: mov    0x8(%rdi),%rdx
    0.00 :   4c0b94: lea    0x8(%rdx),%rax
    0.00 :   4c0b98: mov    %rax,0x8(%rdi)
    0.00 :   4c0b9c: jmp    4bfb49 <__vfprintf_internal+0x999>
    0.00 :   4c0ba1: nopl   0x0(%rax)
    0.00 :   4c0ba8: mov    %edx,%ecx
    0.00 :   4c0baa: add    $0x8,%edx
    0.00 :   4c0bad: add    0x10(%rsi),%rcx
    0.00 :   4c0bb1: mov    %edx,(%rsi)
    0.00 :   4c0bb3: jmp    4c02fa <__vfprintf_internal+0x114a>
    0.00 :   4c0bb8: mov    $0x5,%eax
    0.00 :   4c0bbd: lea    0x4ee8c(%rip),%r10        # 50fa50 <__PRETTY_FUNCTION__.0+0xd0>
    0.00 :   4c0bc4: cmp    %eax,%r13d
    0.00 :   4c0bc7: cmovl  %eax,%r13d
    0.00 :   4c0bcb: cmp    $0x53,%bl
    0.00 :   4c0bce: jne    4bfa57 <__vfprintf_internal+0x8a7>
    0.00 :   4c0bd4: mov    0x30(%rsp),%r8d
    0.00 :   4c0bd9: mov    0x28(%rsp),%ecx
    0.00 :   4c0bdd: mov    %r12d,%r9d
    0.00 :   4c0be0: mov    %r13d,%edx
    0.00 :   4c0be3: mov    %r10,%rsi
    0.00 :   4c0be6: mov    %rbp,%rdi
    0.00 :   4c0be9: call   4bc760 <outstring_converted_wide_string>
    0.00 :   4c0bee: mov    %eax,%r12d
    0.00 :   4c0bf1: test   %eax,%eax
    0.00 :   4c0bf3: jns    4bf830 <__vfprintf_internal+0x680>
    0.00 :   4c0bf9: jmp    4bf3f8 <__vfprintf_internal+0x248>
    0.00 :   4c0bfe: xchg   %ax,%ax
    0.00 :   4c0c00: mov    0x8(%rsi),%rdx
    0.00 :   4c0c04: lea    0x8(%rdx),%rax
    0.00 :   4c0c08: mov    %rax,0x8(%rsi)
    0.00 :   4c0c0c: jmp    4bf707 <__vfprintf_internal+0x557>
    0.00 :   4c0c11: nopl   0x0(%rax)
    0.00 :   4c0c18: mov    0x8(%rdi),%rdx
    0.00 :   4c0c1c: lea    0x8(%rdx),%rax
    0.00 :   4c0c20: mov    %rax,0x8(%rdi)
    0.00 :   4c0c24: jmp    4bf96d <__vfprintf_internal+0x7bd>
    0.00 :   4c0c29: mov    %r10,%rdi
    0.00 :   4c0c2c: mov    %r10,0x38(%rsp)
    0.00 :   4c0c31: call   4011a0 <_init+0x1a0>
    0.00 :   4c0c36: mov    0x38(%rsp),%r10
    0.00 :   4c0c3b: mov    %rax,%r13
    0.00 :   4c0c3e: jmp    4bfa6f <__vfprintf_internal+0x8bf>
    0.00 :   4c0c43: movslq %ebx,%r15
    0.00 :   4c0c46: mov    $0x20,%esi
    0.00 :   4c0c4b: mov    %rbp,%rdi
    0.00 :   4c0c4e: mov    %r8,0x28(%rsp)
    0.00 :   4c0c53: mov    %r15,%rdx
    0.00 :   4c0c56: call   4c8950 <_IO_padn>
    0.00 :   4c0c5b: cmp    %rax,%r15
    0.00 :   4c0c5e: jne    4c07a8 <__vfprintf_internal+0x15f8>
    0.00 :   4c0c64: add    %ebx,%r12d
    0.00 :   4c0c67: js     4bf9f0 <__vfprintf_internal+0x840>
    0.00 :   4c0c6d: cmp    %ebx,%r12d
    0.00 :   4c0c70: jb     4bf9f0 <__vfprintf_internal+0x840>
    0.00 :   4c0c76: test   %r12d,%r12d
    0.00 :   4c0c79: mov    0x28(%rsp),%r8
    0.00 :   4c0c7e: jns    4bf7b4 <__vfprintf_internal+0x604>
    0.00 :   4c0c84: jmp    4bf3f8 <__vfprintf_internal+0x248>
    0.00 :   4c0c89: nopl   0x0(%rax)
    0.00 :   4c0c90: mov    %edx,%eax
    0.00 :   4c0c92: add    $0x10,%edx
    0.00 :   4c0c95: add    0x10(%rcx),%rax
    0.00 :   4c0c99: mov    %edx,0x4(%rcx)
    0.00 :   4c0c9c: jmp    4bf634 <__vfprintf_internal+0x484>
    0.00 :   4c0ca1: cmp    $0x2f,%eax
    0.00 :   4c0ca4: ja     4c11bd <__vfprintf_internal+0x200d>
    0.00 :   4c0caa: mov    %eax,%edx
    0.00 :   4c0cac: add    $0x8,%eax
    0.00 :   4c0caf: add    0x10(%rsi),%rdx
    0.00 :   4c0cb3: mov    %eax,(%rsi)
    0.00 :   4c0cb5: movsbq (%rdx),%r9
    0.00 :   4c0cb9: jmp    4c0b20 <__vfprintf_internal+0x1970>
    0.00 :   4c0cbe: mov    0x8(%rdi),%rdx
    0.00 :   4c0cc2: lea    0x8(%rdx),%rax
    0.00 :   4c0cc6: mov    %rax,0x8(%rdi)
    0.00 :   4c0cca: jmp    4c08ad <__vfprintf_internal+0x16fd>
    0.00 :   4c0ccf: mov    %r12b,(%rax)
    0.00 :   4c0cd2: jmp    4bf830 <__vfprintf_internal+0x680>
    0.00 :   4c0cd7: mov    0x8(%rdi),%rdx
    0.00 :   4c0cdb: lea    0x8(%rdx),%rax
    0.00 :   4c0cdf: mov    %rax,0x8(%rdi)
    0.00 :   4c0ce3: jmp    4c0b54 <__vfprintf_internal+0x19a4>
    0.00 :   4c0ce8: mov    %eax,%edx
    0.00 :   4c0cea: add    $0x8,%eax
    0.00 :   4c0ced: add    0x10(%rdi),%rdx
    0.00 :   4c0cf1: mov    %eax,(%rdi)
    0.00 :   4c0cf3: jmp    4bff69 <__vfprintf_internal+0xdb9>
    0.00 :   4c0cf8: movslq %ebx,%r15
    0.00 :   4c0cfb: mov    $0x20,%esi
    0.00 :   4c0d00: mov    %rbp,%rdi
    0.00 :   4c0d03: mov    %r10,0x28(%rsp)
    0.00 :   4c0d08: mov    %r15,%rdx
    0.00 :   4c0d0b: call   4c8950 <_IO_padn>
    0.00 :   4c0d10: cmp    %rax,%r15
    0.00 :   4c0d13: jne    4c07a8 <__vfprintf_internal+0x15f8>
    0.00 :   4c0d19: add    %ebx,%r12d
    0.00 :   4c0d1c: js     4bf9f0 <__vfprintf_internal+0x840>
    0.00 :   4c0d22: cmp    %ebx,%r12d
    0.00 :   4c0d25: jb     4bf9f0 <__vfprintf_internal+0x840>
    0.00 :   4c0d2b: test   %r12d,%r12d
    0.00 :   4c0d2e: mov    0x28(%rsp),%r10
    0.00 :   4c0d33: jns    4bfa8d <__vfprintf_internal+0x8dd>
    0.00 :   4c0d39: jmp    4bf3f8 <__vfprintf_internal+0x248>
    0.00 :   4c0d3e: xchg   %ax,%ax
    0.00 :   4c0d40: movzbl 0x1(%rdx),%esi
    0.00 :   4c0d44: add    $0x2,%r14
    0.00 :   4c0d48: mov    %esi,%ebx
    0.00 :   4c0d4a: sub    $0x30,%esi
    0.00 :   4c0d4d: cmp    $0x9,%esi
    0.00 :   4c0d50: ja     4c01fd <__vfprintf_internal+0x104d>
    0.00 :   4c0d56: movzbl 0x1(%r14),%edx
    0.00 :   4c0d5b: add    $0x1,%r14
    0.00 :   4c0d5f: mov    %edx,%ebx
    0.00 :   4c0d61: sub    $0x30,%edx
    0.00 :   4c0d64: cmp    $0xccccccc,%r13d
    0.00 :   4c0d6b: jg     4c0e78 <__vfprintf_internal+0x1cc8>
    0.00 :   4c0d71: lea    0x0(%r13,%r13,4),%r13d
    0.00 :   4c0d76: mov    $0x7fffffff,%ecx
    0.00 :   4c0d7b: add    %r13d,%r13d
    0.00 :   4c0d7e: sub    %esi,%ecx
    0.00 :   4c0d80: cmp    %ecx,%r13d
    0.00 :   4c0d83: jg     4c0e78 <__vfprintf_internal+0x1cc8>
    0.00 :   4c0d89: add    %esi,%r13d
    0.00 :   4c0d8c: cmp    $0x9,%edx
    0.00 :   4c0d8f: ja     4c01fd <__vfprintf_internal+0x104d>
    0.00 :   4c0d95: mov    %edx,%esi
    0.00 :   4c0d97: jmp    4c0d56 <__vfprintf_internal+0x1ba6>
    0.00 :   4c0d99: test   %ebx,%ebx
    0.00 :   4c0d9b: jle    4bf952 <__vfprintf_internal+0x7a2>
    0.00 :   4c0da1: movslq %ebx,%r13
    0.00 :   4c0da4: mov    $0x20,%esi
    0.00 :   4c0da9: mov    %rbp,%rdi
    0.00 :   4c0dac: mov    %r13,%rdx
    0.00 :   4c0daf: call   4c8950 <_IO_padn>
    0.00 :   4c0db4: cmp    %rax,%r13
    0.00 :   4c0db7: jne    4c07a8 <__vfprintf_internal+0x15f8>
    0.00 :   4c0dbd: add    %ebx,%r12d
    0.00 :   4c0dc0: js     4bf9f0 <__vfprintf_internal+0x840>
    0.00 :   4c0dc6: cmp    %ebx,%r12d
    0.00 :   4c0dc9: jb     4bf9f0 <__vfprintf_internal+0x840>
    0.00 :   4c0dcf: test   %r12d,%r12d
    0.00 :   4c0dd2: jns    4bf952 <__vfprintf_internal+0x7a2>
    0.00 :   4c0dd8: jmp    4bf3f8 <__vfprintf_internal+0x248>
    0.00 :   4c0ddd: nopl   (%rax)
    0.00 :   4c0de0: call   45ecb0 <__lll_lock_wait_private>
    0.00 :   4c0de5: jmp    4bf6af <__vfprintf_internal+0x4ff>
    0.00 :   4c0dea: mov    0x8(%rsp),%rbx
    0.00 :   4c0def: mov    %r9d,0x30(%rsp)
    0.00 :   4c0df4: mov    %r8d,0x28(%rsp)
    0.00 :   4c0df9: mov    %rbx,%rdi
    0.00 :   4c0dfc: call   4011a0 <_init+0x1a0>
    0.00 :   4c0e01: mov    %rbx,%rdi
    0.00 :   4c0e04: lea    0x1(%rax),%rsi
    0.00 :   4c0e08: call   4ceed0 <__readonly_area>
    0.00 :   4c0e0d: mov    0x28(%rsp),%r8d
    0.00 :   4c0e12: mov    0x30(%rsp),%r9d
    0.00 :   4c0e17: test   %eax,%eax
    0.00 :   4c0e19: mov    %eax,0xa0(%rsp)
    0.00 :   4c0e20: jns    4bfb2e <__vfprintf_internal+0x97e>
    0.00 :   4c0e26: lea    0x4ecab(%rip),%rdi        # 50fad8 <null+0x82>
    0.00 :   4c0e2d: call   458f30 <__libc_fatal>
    0.00 :   4c0e32: nopw   0x0(%rax,%rax,1)
    0.00 :   4c0e38: mov    $0x6,%eax
    0.00 :   4c0e3d: mov    $0x6,%r13d
    0.00 :   4c0e43: lea    0x4ec0c(%rip),%r10        # 50fa56 <null>
    0.00 :   4c0e4a: jmp    4bfa6f <__vfprintf_internal+0x8bf>
    0.00 :   4c0e4f: mov    $0x30,%esi
    0.00 :   4c0e54: mov    %rbp,%rdi
    0.00 :   4c0e57: mov    %r8d,0x28(%rsp)
    0.00 :   4c0e5c: call   45c390 <__overflow>
    0.00 :   4c0e61: mov    0x28(%rsp),%r8d
    0.00 :   4c0e66: cmp    $0xffffffff,%eax
    0.00 :   4c0e69: jne    4bfdb2 <__vfprintf_internal+0xc02>
    0.00 :   4c0e6f: jmp    4c07a8 <__vfprintf_internal+0x15f8>
    0.00 :   4c0e74: nopl   0x0(%rax)
    0.00 :   4c0e78: cmp    $0x9,%edx
    0.00 :   4c0e7b: ja     4bf9f0 <__vfprintf_internal+0x840>
    0.00 :   4c0e81: movzbl 0x1(%r14),%eax
    0.00 :   4c0e86: sub    $0x30,%eax
    0.00 :   4c0e89: cmp    $0x9,%eax
    0.00 :   4c0e8c: ja     4bf9f0 <__vfprintf_internal+0x840>
    0.00 :   4c0e92: movzbl 0x2(%r14),%eax
    0.00 :   4c0e97: sub    $0x30,%eax
    0.00 :   4c0e9a: cmp    $0x9,%eax
    0.00 :   4c0e9d: ja     4bf9f0 <__vfprintf_internal+0x840>
    0.00 :   4c0ea3: lea    0x3(%r14),%rdx
    0.00 :   4c0ea7: nopw   0x0(%rax,%rax,1)
    0.00 :   4c0eb0: movzbl (%rdx),%eax
    0.00 :   4c0eb3: add    $0x1,%rdx
    0.00 :   4c0eb7: sub    $0x30,%eax
    0.00 :   4c0eba: cmp    $0x9,%eax
    0.00 :   4c0ebd: jbe    4c0eb0 <__vfprintf_internal+0x1d00>
    0.00 :   4c0ebf: jmp    4bf9f0 <__vfprintf_internal+0x840>
    0.00 :   4c0ec4: nopl   0x0(%rax)
    0.00 :   4c0ec8: neg    %r11
    0.00 :   4c0ecb: mov    $0xa,%r10d
    0.00 :   4c0ed1: mov    $0x1,%r9d
    0.00 :   4c0ed7: jmp    4bfbb0 <__vfprintf_internal+0xa00>
    0.00 :   4c0edc: nopl   0x0(%rax)
    0.00 :   4c0ee0: mov    0xd8(%rbp),%rbx
    0.00 :   4c0ee7: mov    %rbx,%rax
    0.00 :   4c0eea: sub    $0x532b60,%rax
    0.00 :   4c0ef1: cmp    %rax,0x10(%rsp)
    0.00 :   4c0ef6: jbe    4c13b8 <__vfprintf_internal+0x2208>
    0.00 :   4c0efc: mov    %r13,%rdx
    0.00 :   4c0eff: mov    %r10,%rsi
    0.00 :   4c0f02: mov    %rbp,%rdi
    0.00 :   4c0f05: call   *0x38(%rbx)
    0.00 :   4c0f08: cmp    %r13,%rax
    0.00 :   4c0f0b: jne    4c07a8 <__vfprintf_internal+0x15f8>
    0.00 :   4c0f11: movslq %r12d,%rax
    0.00 :   4c0f14: xor    %edx,%edx
    0.00 :   4c0f16: add    %r13,%rax
    0.00 :   4c0f19: js     4c0f24 <__vfprintf_internal+0x1d74>
    0.00 :   4c0f1b: cmp    %r13,%rax
    0.00 :   4c0f1e: jae    4bfe46 <__vfprintf_internal+0xc96>
    0.00 :   4c0f24: mov    $0x1,%edx
    0.00 :   4c0f29: jmp    4bfe46 <__vfprintf_internal+0xc96>
    0.00 :   4c0f2e: xchg   %ax,%ax
    0.00 :   4c0f30: mov    0x60(%rsp),%rdx
    0.00 :   4c0f35: mov    $0x0,%eax
    0.00 :   4c0f3a: sub    %r15,%rdx
    0.00 :   4c0f3d: cmovs  %rax,%rdx
    0.00 :   4c0f41: mov    %edx,%r13d
    0.00 :   4c0f44: jmp    4c0621 <__vfprintf_internal+0x1471>
    0.00 :   4c0f49: nopl   0x0(%rax)
    0.00 :   4c0f50: mov    0x5c(%rsp),%ecx
    0.00 :   4c0f54: test   %ecx,%ecx
    0.00 :   4c0f56: je     4bfd81 <__vfprintf_internal+0xbd1>
    0.00 :   4c0f5c: mov    0x28(%rbp),%rax
    0.00 :   4c0f60: cmp    0x30(%rbp),%rax
    0.00 :   4c0f64: jae    4c13fe <__vfprintf_internal+0x224e>
    0.00 :   4c0f6a: lea    0x1(%rax),%rdx
    0.00 :   4c0f6e: mov    %rdx,0x28(%rbp)
    0.00 :   4c0f72: movb   $0x20,(%rax)
    0.00 :   4c0f75: jmp    4bfd70 <__vfprintf_internal+0xbc0>
    0.00 :   4c0f7a: nopw   0x0(%rax,%rax,1)
    0.00 :   4c0f80: lea    0x2(%r14),%rcx
    0.00 :   4c0f84: mov    %rcx,0x60(%rsp)
    0.00 :   4c0f89: movzbl 0x2(%r14),%ecx
    0.00 :   4c0f8e: sub    $0x30,%ecx
    0.00 :   4c0f91: cmp    $0x9,%ecx
    0.00 :   4c0f94: jbe    4c11f4 <__vfprintf_internal+0x2044>
    0.00 :   4c0f9a: mov    0x20(%rsp),%rcx
    0.00 :   4c0f9f: mov    (%rcx),%edx
    0.00 :   4c0fa1: cmp    $0x2f,%edx
    0.00 :   4c0fa4: jbe    4c1145 <__vfprintf_internal+0x1f95>
    0.00 :   4c0faa: mov    %rcx,%rdi
    0.00 :   4c0fad: mov    0x8(%rcx),%rcx
    0.00 :   4c0fb1: lea    0x8(%rcx),%rdx
    0.00 :   4c0fb5: mov    %rdx,0x8(%rdi)
    0.00 :   4c0fb9: mov    (%rcx),%edx
    0.00 :   4c0fbb: mov    $0xffffffff,%ecx
    0.00 :   4c0fc0: mov    0x60(%rsp),%r14
    0.00 :   4c0fc5: test   %edx,%edx
    0.00 :   4c0fc7: movzbl (%r14),%ebx
    0.00 :   4c0fcb: cmovns %edx,%ecx
    0.00 :   4c0fce: mov    %ecx,%r13d
    0.00 :   4c0fd1: jmp    4c01fd <__vfprintf_internal+0x104d>
    0.00 :   4c0fd6: cs nopw 0x0(%rax,%rax,1)
    0.00 :   4c0fe0: movzbl 0x1(%rdi),%esi
    0.00 :   4c0fe4: lea    0x2(%r14),%rdx
    0.00 :   4c0fe8: lea    -0x30(%rsi),%ebx
    0.00 :   4c0feb: mov    %esi,%edi
    0.00 :   4c0fed: cmp    $0x9,%ebx
    0.00 :   4c0ff0: ja     4c10a5 <__vfprintf_internal+0x1ef5>
    0.00 :   4c0ff6: mov    %r14,0x28(%rsp)
    0.00 :   4c0ffb: movzbl 0x1(%rdx),%esi
    0.00 :   4c0fff: add    $0x1,%rdx
    0.00 :   4c1003: mov    %esi,%edi
    0.00 :   4c1005: sub    $0x30,%esi
    0.00 :   4c1008: cmp    $0xccccccc,%ecx
    0.00 :   4c100e: jg     4c1030 <__vfprintf_internal+0x1e80>
    0.00 :   4c1010: lea    (%rcx,%rcx,4),%ecx
    0.00 :   4c1013: mov    $0x7fffffff,%r14d
    0.00 :   4c1019: add    %ecx,%ecx
    0.00 :   4c101b: sub    %ebx,%r14d
    0.00 :   4c101e: cmp    %r14d,%ecx
    0.00 :   4c1021: jg     4c1030 <__vfprintf_internal+0x1e80>
    0.00 :   4c1023: add    %ebx,%ecx
    0.00 :   4c1025: cmp    $0x9,%esi
    0.00 :   4c1028: ja     4c10a0 <__vfprintf_internal+0x1ef0>
    0.00 :   4c102a: mov    %esi,%ebx
    0.00 :   4c102c: jmp    4c0ffb <__vfprintf_internal+0x1e4b>
    0.00 :   4c102e: xchg   %ax,%ax
    0.00 :   4c1030: cmp    $0x9,%esi
    0.00 :   4c1033: ja     4bf9f0 <__vfprintf_internal+0x840>
    0.00 :   4c1039: movzbl 0x1(%rdx),%eax
    0.00 :   4c103d: sub    $0x30,%eax
    0.00 :   4c1040: cmp    $0x9,%eax
    0.00 :   4c1043: ja     4bf9f0 <__vfprintf_internal+0x840>
    0.00 :   4c1049: movzbl 0x2(%rdx),%eax
    0.00 :   4c104d: sub    $0x30,%eax
    0.00 :   4c1050: cmp    $0x9,%eax
    0.00 :   4c1053: ja     4bf9f0 <__vfprintf_internal+0x840>
    0.00 :   4c1059: add    $0x3,%rdx
    0.00 :   4c105d: nopl   (%rax)
    0.00 :   4c1060: movzbl (%rdx),%eax
    0.00 :   4c1063: add    $0x1,%rdx
    0.00 :   4c1067: sub    $0x30,%eax
    0.00 :   4c106a: cmp    $0x9,%eax
    0.00 :   4c106d: jbe    4c1060 <__vfprintf_internal+0x1eb0>
    0.00 :   4c106f: jmp    4bf9f0 <__vfprintf_internal+0x840>
    0.00 :   4c1074: nopl   0x0(%rax)
    0.00 :   4c1078: movl   $0x0,0xa0(%rsp)
    0.00 :   4c1083: movq   $0xffffffffffffffff,0x80(%rsp)
    0.00 :   4c108f: movq   $0x0,0x98(%rsp)
    0.00 :   4c109b: jmp    4bf3a0 <__vfprintf_internal+0x1f0>
    0.00 :   4c10a0: mov    0x28(%rsp),%r14
    0.00 :   4c10a5: cmp    $0x24,%dil
    0.00 :   4c10a9: jne    4c02de <__vfprintf_internal+0x112e>
    0.00 :   4c10af: test   %ecx,%ecx
    0.00 :   4c10b1: je     4c02de <__vfprintf_internal+0x112e>
    0.00 :   4c10b7: jmp    4bf39c <__vfprintf_internal+0x1ec>
    0.00 :   4c10bc: nopl   0x0(%rax)
    0.00 :   4c10c0: mov    0x38(%rsp),%rdi
    0.00 :   4c10c5: mov    (%rdi),%rdx
    0.00 :   4c10c8: mov    0x50(%rdx),%rcx
    0.00 :   4c10cc: mov    0x48(%rdx),%rsi
    0.00 :   4c10d0: movzbl (%rcx),%edx
    0.00 :   4c10d3: mov    %rsi,0x98(%rsp)
    0.00 :   4c10db: test   %dl,%dl
    0.00 :   4c10dd: je     4c1198 <__vfprintf_internal+0x1fe8>
    0.00 :   4c10e3: cmp    $0x7f,%dl
    0.00 :   4c10e6: je     4c1198 <__vfprintf_internal+0x1fe8>
    0.00 :   4c10ec: xor    %edx,%edx
    0.00 :   4c10ee: cmpb   $0x0,(%rsi)
    0.00 :   4c10f1: cmovne %rcx,%rdx
    0.00 :   4c10f5: mov    %rdx,0x80(%rsp)
    0.00 :   4c10fd: jmp    4c0363 <__vfprintf_internal+0x11b3>
    0.00 :   4c1102: movslq 0x7c(%rsp),%r11
    0.00 :   4c1107: xor    %r9d,%r9d
    0.00 :   4c110a: mov    $0xa,%r10d
    0.00 :   4c1110: test   %r11d,%r11d
    0.00 :   4c1113: jns    4bfbb0 <__vfprintf_internal+0xa00>
    0.00 :   4c1119: neg    %r11
    0.00 :   4c111c: mov    $0x1,%r9d
    0.00 :   4c1122: jmp    4bfbb0 <__vfprintf_internal+0xa00>
    0.00 :   4c1127: call   458f50 <_IO_vtable_check>
    0.00 :   4c112c: jmp    4c054b <__vfprintf_internal+0x139b>
    0.00 :   4c1131: call   458f50 <_IO_vtable_check>
    0.00 :   4c1136: jmp    4bfe18 <__vfprintf_internal+0xc68>
    0.00 :   4c113b: xor    %r10d,%r10d
    0.00 :   4c113e: xor    %edx,%edx
    0.00 :   4c1140: jmp    4bf55c <__vfprintf_internal+0x3ac>
    0.00 :   4c1145: mov    %rcx,%rsi
    0.00 :   4c1148: mov    %edx,%ecx
    0.00 :   4c114a: add    $0x8,%edx
    0.00 :   4c114d: mov    %edx,(%rsi)
    0.00 :   4c114f: add    0x10(%rsi),%rcx
    0.00 :   4c1153: jmp    4c0fb9 <__vfprintf_internal+0x1e09>
    0.00 :   4c1158: mov    %r8d,0x40(%rsp)
    0.00 :   4c115d: mov    $0x2d,%esi
    0.00 :   4c1162: mov    %r10d,0x30(%rsp)
    0.00 :   4c1167: mov    %r11,0x28(%rsp)
    0.00 :   4c116c: mov    %rbp,%rdi
    0.00 :   4c116f: call   45c390 <__overflow>
    0.00 :   4c1174: mov    0x28(%rsp),%r11
    0.00 :   4c1179: mov    0x30(%rsp),%r10d
    0.00 :   4c117e: cmp    $0xffffffff,%eax
    0.00 :   4c1181: mov    0x40(%rsp),%r8d
    0.00 :   4c1186: jne    4bfd70 <__vfprintf_internal+0xbc0>
    0.00 :   4c118c: jmp    4c07a8 <__vfprintf_internal+0x15f8>
    0.00 :   4c1191: nopl   0x0(%rax)
    0.00 :   4c1198: movq   $0x0,0x80(%rsp)
    0.00 :   4c11a4: jmp    4c0363 <__vfprintf_internal+0x11b3>
    0.00 :   4c11a9: mov    %r8,0x28(%rsp)
    0.00 :   4c11ae: call   458f50 <_IO_vtable_check>
    0.00 :   4c11b3: mov    0x28(%rsp),%r8
    0.00 :   4c11b8: jmp    4bf7d0 <__vfprintf_internal+0x620>
    0.00 :   4c11bd: mov    0x8(%rsi),%rdx
    0.00 :   4c11c1: lea    0x8(%rdx),%rax
    0.00 :   4c11c5: mov    %rax,0x8(%rsi)
    0.00 :   4c11c9: jmp    4c0cb5 <__vfprintf_internal+0x1b05>
    0.00 :   4c11ce: cmp    $0x2f,%eax
    0.00 :   4c11d1: ja     4c1351 <__vfprintf_internal+0x21a1>
    0.00 :   4c11d7: mov    %eax,%edx
    0.00 :   4c11d9: add    $0x8,%eax
    0.00 :   4c11dc: add    0x10(%rsi),%rdx
    0.00 :   4c11e0: mov    %eax,(%rsi)
    0.00 :   4c11e2: movswq (%rdx),%r9
    0.00 :   4c11e6: jmp    4c0b20 <__vfprintf_internal+0x1970>
    0.00 :   4c11eb: mov    %r12w,(%rax)
    0.00 :   4c11ef: jmp    4bf830 <__vfprintf_internal+0x680>
    0.00 :   4c11f4: mov    0x60(%rsp),%rsi
    0.00 :   4c11f9: lea    0x3(%r14),%rdx
    0.00 :   4c11fd: movzbl 0x1(%rsi),%esi
    0.00 :   4c1201: lea    -0x30(%rsi),%ebx
    0.00 :   4c1204: mov    %esi,%edi
    0.00 :   4c1206: cmp    $0x9,%ebx
    0.00 :   4c1209: ja     4c12a0 <__vfprintf_internal+0x20f0>
    0.00 :   4c120f: movzbl 0x1(%rdx),%esi
    0.00 :   4c1213: add    $0x1,%rdx
    0.00 :   4c1217: mov    %esi,%edi
    0.00 :   4c1219: sub    $0x30,%esi
    0.00 :   4c121c: cmp    $0xccccccc,%ecx
    0.00 :   4c1222: jg     4c1248 <__vfprintf_internal+0x2098>
    0.00 :   4c1224: lea    (%rcx,%rcx,4),%ecx
    0.00 :   4c1227: mov    $0x7fffffff,%r13d
    0.00 :   4c122d: add    %ecx,%ecx
    0.00 :   4c122f: sub    %ebx,%r13d
    0.00 :   4c1232: cmp    %r13d,%ecx
    0.00 :   4c1235: jg     4c1248 <__vfprintf_internal+0x2098>
    0.00 :   4c1237: add    %ebx,%ecx
    0.00 :   4c1239: cmp    $0x9,%esi
    0.00 :   4c123c: ja     4c12a0 <__vfprintf_internal+0x20f0>
    0.00 :   4c123e: mov    %esi,%ebx
    0.00 :   4c1240: jmp    4c120f <__vfprintf_internal+0x205f>
    0.00 :   4c1242: nopw   0x0(%rax,%rax,1)
    0.00 :   4c1248: cmp    $0x9,%esi
    0.00 :   4c124b: ja     4bf9f0 <__vfprintf_internal+0x840>
    0.00 :   4c1251: movzbl 0x1(%rdx),%eax
    0.00 :   4c1255: sub    $0x30,%eax
    0.00 :   4c1258: cmp    $0x9,%eax
    0.00 :   4c125b: ja     4bf9f0 <__vfprintf_internal+0x840>
    0.00 :   4c1261: movzbl 0x2(%rdx),%eax
    0.00 :   4c1265: sub    $0x30,%eax
    0.00 :   4c1268: cmp    $0x9,%eax
    0.00 :   4c126b: ja     4bf9f0 <__vfprintf_internal+0x840>
    0.00 :   4c1271: add    $0x3,%rdx
    0.00 :   4c1275: nopl   (%rax)
    0.00 :   4c1278: movzbl (%rdx),%eax
    0.00 :   4c127b: add    $0x1,%rdx
    0.00 :   4c127f: sub    $0x30,%eax
    0.00 :   4c1282: cmp    $0x9,%eax
    0.00 :   4c1285: jbe    4c1278 <__vfprintf_internal+0x20c8>
    0.00 :   4c1287: jmp    4bf9f0 <__vfprintf_internal+0x840>
    0.00 :   4c128c: mov    %r10,0x28(%rsp)
    0.00 :   4c1291: call   458f50 <_IO_vtable_check>
    0.00 :   4c1296: mov    0x28(%rsp),%r10
    0.00 :   4c129b: jmp    4bfaa9 <__vfprintf_internal+0x8f9>
    0.00 :   4c12a0: test   %ecx,%ecx
    0.00 :   4c12a2: je     4c0f9a <__vfprintf_internal+0x1dea>
    0.00 :   4c12a8: cmp    $0x24,%dil
    0.00 :   4c12ac: jne    4c0f9a <__vfprintf_internal+0x1dea>
    0.00 :   4c12b2: jmp    4bf39c <__vfprintf_internal+0x1ec>
    0.00 :   4c12b7: mov    %esi,0x28(%rsp)
    0.00 :   4c12bb: cmp    $0x9,%ecx
    0.00 :   4c12be: jbe    4c0465 <__vfprintf_internal+0x12b5>
    0.00 :   4c12c4: mov    %rdx,%r14
    0.00 :   4c12c7: nopw   0x0(%rax,%rax,1)
    0.00 :   4c12d0: cmpl   $0xffffffff,0x28(%rsp)
    0.00 :   4c12d5: jne    4c0290 <__vfprintf_internal+0x10e0>
    0.00 :   4c12db: jmp    4bf9f0 <__vfprintf_internal+0x840>
    0.00 :   4c12e0: mov    $0x25,%esi
    0.00 :   4c12e5: mov    %rbp,%rdi
    0.00 :   4c12e8: call   45c390 <__overflow>
    0.00 :   4c12ed: cmp    $0xffffffff,%eax
    0.00 :   4c12f0: jne    4bff95 <__vfprintf_internal+0xde5>
    0.00 :   4c12f6: jmp    4c07a8 <__vfprintf_internal+0x15f8>
    0.00 :   4c12fb: nopl   0x0(%rax,%rax,1)
    0.00 :   4c1300: mov    $0xffffffffffffffb8,%rax
    0.00 :   4c1307: or     $0x20,%ebx
    0.00 :   4c130a: mov    $0xffffffff,%r12d
    0.00 :   4c1310: mov    %ebx,0x0(%rbp)
    0.00 :   4c1313: movl   $0x9,%fs:(%rax)
    0.00 :   4c131a: jmp    4bf40f <__vfprintf_internal+0x25f>
    0.00 :   4c131f: mov    %r8d,0x40(%rsp)
    0.00 :   4c1324: mov    $0x2b,%esi
    0.00 :   4c1329: mov    %r10d,0x30(%rsp)
    0.00 :   4c132e: mov    %r11,0x28(%rsp)
    0.00 :   4c1333: jmp    4c116c <__vfprintf_internal+0x1fbc>
    0.00 :   4c1338: mov    %r10d,0x54(%rsp)
    0.00 :   4c133d: mov    $0x2b,%esi
    0.00 :   4c1342: mov    %rdx,0x40(%rsp)
    0.00 :   4c1347: mov    %r11,0x30(%rsp)
    0.00 :   4c134c: jmp    4c0784 <__vfprintf_internal+0x15d4>
    0.00 :   4c1351: mov    0x8(%rsi),%rdx
    0.00 :   4c1355: lea    0x8(%rdx),%rax
    0.00 :   4c1359: mov    %rax,0x8(%rsi)
    0.00 :   4c135d: jmp    4c11e2 <__vfprintf_internal+0x2032>
    0.00 :   4c1362: mov    0x8(%rsi),%rdx
    0.00 :   4c1366: lea    0x8(%rdx),%rax
    0.00 :   4c136a: mov    %rax,0x8(%rsi)
    0.00 :   4c136e: jmp    4c0b1d <__vfprintf_internal+0x196d>
    0.00 :   4c1373: movzbl %dl,%esi
    0.00 :   4c1376: mov    %rbp,%rdi
    0.00 :   4c1379: call   45c390 <__overflow>
    0.00 :   4c137e: cmp    $0xffffffff,%eax
    0.00 :   4c1381: jne    4bf987 <__vfprintf_internal+0x7d7>
    0.00 :   4c1387: jmp    4c07a8 <__vfprintf_internal+0x15f8>
    0.00 :   4c138c: nopl   0x0(%rax)
    0.00 :   4c1390: movzbl %bl,%esi
    0.00 :   4c1393: mov    %rbp,%rdi
    0.00 :   4c1396: mov    %r8d,0x28(%rsp)
    0.00 :   4c139b: call   45c390 <__overflow>
    0.00 :   4c13a0: mov    0x28(%rsp),%r8d
    0.00 :   4c13a5: cmp    $0xffffffff,%eax
    0.00 :   4c13a8: jne    4bfdd7 <__vfprintf_internal+0xc27>
    0.00 :   4c13ae: jmp    4c07a8 <__vfprintf_internal+0x15f8>
    0.00 :   4c13b3: nopl   0x0(%rax,%rax,1)
    0.00 :   4c13b8: mov    %r10,0x28(%rsp)
    0.00 :   4c13bd: call   458f50 <_IO_vtable_check>
    0.00 :   4c13c2: mov    0x28(%rsp),%r10
    0.00 :   4c13c7: jmp    4c0efc <__vfprintf_internal+0x1d4c>
    0.00 :   4c13cc: mov    $0xffffffffffffffb8,%rax
    0.00 :   4c13d3: mov    $0xffffffff,%r12d
    0.00 :   4c13d9: movl   $0x16,%fs:(%rax)
    0.00 :   4c13e0: jmp    4bf40f <__vfprintf_internal+0x25f>
    0.00 :   4c13e5: mov    %r10d,0x54(%rsp)
    0.00 :   4c13ea: mov    $0x20,%esi
    0.00 :   4c13ef: mov    %rdx,0x40(%rsp)
    0.00 :   4c13f4: mov    %r11,0x30(%rsp)
    0.00 :   4c13f9: jmp    4c0784 <__vfprintf_internal+0x15d4>
    0.00 :   4c13fe: mov    %r8d,0x40(%rsp)
    0.00 :   4c1403: mov    $0x20,%esi
    0.00 :   4c1408: mov    %r10d,0x30(%rsp)
    0.00 :   4c140d: mov    %r11,0x28(%rsp)
    0.00 :   4c1412: jmp    4c116c <__vfprintf_internal+0x1fbc>
    0.00 :   4c1417: movzbl %bl,%esi
    0.00 :   4c141a: mov    %rbp,%rdi
    0.00 :   4c141d: mov    %rdx,0x30(%rsp)
    0.00 :   4c1422: call   45c390 <__overflow>
    0.00 :   4c1427: mov    0x30(%rsp),%rdx
    0.00 :   4c142c: cmp    $0xffffffff,%eax
    0.00 :   4c142f: jne    4c09fd <__vfprintf_internal+0x184d>
    0.00 :   4c1435: jmp    4c07a8 <__vfprintf_internal+0x15f8>
    0.00 :   4c143a: nopw   0x0(%rax,%rax,1)
    0.00 :   4c1440: mov    $0x30,%esi
    0.00 :   4c1445: mov    %rbp,%rdi
    0.00 :   4c1448: mov    %rdx,0x30(%rsp)
    0.00 :   4c144d: call   45c390 <__overflow>
    0.00 :   4c1452: mov    0x30(%rsp),%rdx
    0.00 :   4c1457: cmp    $0xffffffff,%eax
    0.00 :   4c145a: jne    4c09d8 <__vfprintf_internal+0x1828>
    0.00 :   4c1460: jmp    4c07a8 <__vfprintf_internal+0x15f8>
    0.00 :   4c1465: nopl   (%rax)
    0.00 :   4c1468: mov    $0x1,%edx
    0.00 :   4c146d: jmp    4bf898 <__vfprintf_internal+0x6e8>
    0.00 :   4c1472: mov    $0x1,%edx
    0.00 :   4c1477: jmp    4c057a <__vfprintf_internal+0x13ca>
    0.00 :   4c147c: call   49fd70 <__stack_chk_fail>
    0.00 :   4c1481: mov    $0x1,%edx
    0.00 :   4c1486: jmp    4c095b <__vfprintf_internal+0x17ab>
    0.00 :   4c148b: mov    $0x1,%edx
    0.00 :   4c1490: jmp    4bfad6 <__vfprintf_internal+0x926>
    0.00 :   4c1495: test   %r8d,%r8d
    0.00 :   4c1498: jg     4c06f4 <__vfprintf_internal+0x1544>
    0.00 :   4c149e: xor    %r8d,%r8d
    0.00 :   4c14a1: jmp    4bfd4e <__vfprintf_internal+0xb9e>
    0.00 :   4c14a6: mov    $0x1,%edx
    0.00 :   4c14ab: jmp    4bf7fd <__vfprintf_internal+0x64d>
    0.00 :   4c14b0: xor    %r8d,%r8d
    0.00 :   4c14b3: jmp    4bfd81 <__vfprintf_internal+0xbd1>
    0.00 :   4c14b8: mov    $0x1,%eax
    0.00 :   4c14bd: jmp    4bf9de <__vfprintf_internal+0x82e>
    0.00 :   4c14c2: mov    $0x1,%eax
    0.00 :   4c14c7: jmp    4c082c <__vfprintf_internal+0x167c>
    0.00 :   4c14cc: mov    $0x1,%eax
    0.00 :   4c14d1: jmp    4c051e <__vfprintf_internal+0x136e>
    0.00 :   4c14d6: movb   $0x1,0xa6(%rsp)
    0.00 :   4c14de: jmp    4bf27d <__vfprintf_internal+0xcd>
    0.00 :   4c14e3: mov    $0x1,%eax
    0.00 :   4c14e8: jmp    4c0753 <__vfprintf_internal+0x15a3>
 Percent |	Source code & Disassembly of minisat_HACK_999ED_CSSC_static for cycles:u (1 samples, percent: local period)
---------------------------------------------------------------------------------------------------------------------------
         :
         :
         :
         : 3      Disassembly of section .text:
         :
         : 5      000000000040e070 <Minisat::Solver::rebuildOrderHeap()>:
         : 6      cs.shrink(i - j);
         : 7      }
         :
         :
         : 10     void Solver::rebuildOrderHeap()
         : 11     {
    0.00 :   40e070: endbr64
    0.00 :   40e074: push   %r15
    0.00 :   40e076: push   %r14
    0.00 :   40e078: push   %r13
    0.00 :   40e07a: push   %r12
         : 17     vec<Var> vs;
         : 18     for (Var v = 0; v < nVars(); v++)/*auto*/{
    0.00 :   40e07c: xor    %r12d,%r12d
         : 20     {
    0.00 :   40e07f: push   %rbp
    0.00 :   40e080: xor    %ebp,%ebp
    0.00 :   40e082: push   %rbx
    0.00 :   40e083: mov    %rdi,%rbx
    0.00 :   40e086: sub    $0x48,%rsp
         :
         : 27     // Pointer to first element:
         : 28     operator T*       (void)           { return data; }
         :
         : 30     // Size operations:
         : 31     int      size     (void) const     { return sz; }
    0.00 :   40e08a: mov    0x208(%rdi),%edx
    0.00 :   40e090: mov    %fs:0x28,%rax
    0.00 :   40e099: mov    %rax,0x38(%rsp)
    0.00 :   40e09e: xor    %eax,%eax
         : 36     vec()                       : data(NULL) , sz(0)   , cap(0)    { }
    0.00 :   40e0a0: lea    0x20(%rsp),%r14
    0.00 :   40e0a5: movq   $0x0,0x20(%rsp)
    0.00 :   40e0ae: movq   $0x0,0x28(%rsp)
         : 40     for (Var v = 0; v < nVars(); v++)/*auto*/{
    0.00 :   40e0b7: test   %edx,%edx
    0.00 :   40e0b9: jg     40e0c8 <Minisat::Solver::rebuildOrderHeap()+0x58>
    0.00 :   40e0bb: jmp    40e3bf <Minisat::Solver::rebuildOrderHeap()+0x34f>
    0.00 :   40e0c0: add    $0x1,%rbp
    0.00 :   40e0c4: cmp    %ebp,%edx
    0.00 :   40e0c6: jle    40e118 <Minisat::Solver::rebuildOrderHeap()+0xa8>
         :
         : 48     if (decision[v] && value(v) == l_Undef)/*auto*/{
    0.00 :   40e0c8: mov    0x1d0(%rbx),%rax
    0.00 :   40e0cf: mov    %ebp,%r13d
    0.00 :   40e0d2: cmpb   $0x0,(%rax,%rbp,1)
    0.00 :   40e0d6: je     40e0c0 <Minisat::Solver::rebuildOrderHeap()+0x50>
         : 53     inline bool     Solver::locked          (const Clause& c) const { return value(c[0]) == l_True && reason(var(c[0])) != CRef_Undef && ca.lea(reason(var(c[0]))) == &c; }
         : 54     inline void     Solver::newDecisionLevel()                      { trail_lim.push(trail.size()); }
         :
         : 56     inline int      Solver::decisionLevel ()      const   { return trail_lim.size(); }
         : 57     inline uint32_t Solver::abstractLevel (Var x) const   { return 1 << (level(x) & 31); }
         : 58     inline lbool    Solver::value         (Var x) const   { return assigns[x]; }
    0.00 :   40e0d8: mov    0x1b0(%rbx),%rax
    0.00 :   40e0df: testb  $0x2,(%rax,%rbp,1)
    0.00 :   40e0e3: je     40e0c0 <Minisat::Solver::rebuildOrderHeap()+0x50>
         : 62     void     growTo   (int size, const T& pad);
         : 63     void     clear    (bool dealloc = false);
         :
         : 65     // Stack interface:
         : 66     void     push  (void)              { if (sz == cap) capacity(sz+1); new (&data[sz]) T(); sz++; }
         : 67     void     push  (const T& elem)     { if (sz == cap) capacity(sz+1); data[sz++] = elem; }
    0.00 :   40e0e5: cmp    %r12d,0x2c(%rsp)
    0.00 :   40e0ea: je     40e3a8 <Minisat::Solver::rebuildOrderHeap()+0x338>
    0.00 :   40e0f0: mov    0x20(%rsp),%rdx
    0.00 :   40e0f5: lea    0x1(%r12),%eax
         : 72     for (Var v = 0; v < nVars(); v++)/*auto*/{
    0.00 :   40e0fa: add    $0x1,%rbp
    0.00 :   40e0fe: mov    %eax,0x28(%rsp)
    0.00 :   40e102: mov    %r13d,(%rdx,%r12,4)
         : 76     int      size     (void) const     { return sz; }
    0.00 :   40e106: mov    0x208(%rbx),%edx
         : 78     void     push  (const T& elem)     { if (sz == cap) capacity(sz+1); data[sz++] = elem; }
    0.00 :   40e10c: movslq %eax,%r12
    0.00 :   40e10f: cmp    %ebp,%edx
    0.00 :   40e111: jg     40e0c8 <Minisat::Solver::rebuildOrderHeap()+0x58>
    0.00 :   40e113: nopl   0x0(%rax,%rax,1)
         : 83     sz = size; }
         :
         :
         : 86     template<class T>
         : 87     void vec<T>::clear(bool dealloc) {
         : 88     if (data != NULL){
    0.00 :   40e118: mov    0x20(%rsp),%rax
    0.00 :   40e11d: mov    0x238(%rbx),%r8
    0.00 :   40e124: mov    %rax,0x8(%rsp)
         : 92     }
         :
         :
         : 95     // Rebuild the heap from scratch, using the elements in 'ns':
         : 96     void build(vec<int>& ns) {
         : 97     for (int i = 0; i < heap.size(); i++)
    0.00 :   40e129: mov    0x240(%rbx),%eax
    0.00 :   40e12f: test   %eax,%eax
    0.00 :   40e131: jle    40e369 <Minisat::Solver::rebuildOrderHeap()+0x2f9>
         : 101    T&       operator [] (int index)       { return data[index]; }
    0.00 :   40e137: mov    0x248(%rbx),%rcx
    0.00 :   40e13e: xor    %eax,%eax
    0.00 :   40e140: movslq (%r8,%rax,4),%rdx
    0.00 :   40e144: add    $0x1,%rax
         : 106    indices[heap[i]] = -1;
    0.00 :   40e148: movl   $0xffffffff,(%rcx,%rdx,4)
         : 108    for (int i = 0; i < heap.size(); i++)
  100.00 :   40e14f: cmp    %eax,0x240(%rbx)
    0.00 :   40e155: jg     40e140 <Minisat::Solver::rebuildOrderHeap()+0xd0>
         : 111    heap.clear();
    0.00 :   40e157: lea    0x238(%rbx),%r13
         : 113    for (int i = 0; i < sz; i++) data[i].~T();
         : 114    sz = 0;
    0.00 :   40e15e: movl   $0x0,0x240(%rbx)
         :
         : 117    for (int i = 0; i < ns.size(); i++){
    0.00 :   40e168: test   %r12d,%r12d
    0.00 :   40e16b: jle    40e1d8 <Minisat::Solver::rebuildOrderHeap()+0x168>
         : 120    T&       operator [] (int index)       { return data[index]; }
    0.00 :   40e16d: xor    %ebp,%ebp
    0.00 :   40e16f: jmp    40e196 <Minisat::Solver::rebuildOrderHeap()+0x126>
    0.00 :   40e171: nopl   0x0(%rax)
         : 124    void     push  (const T& elem)     { if (sz == cap) capacity(sz+1); data[sz++] = elem; }
    0.00 :   40e178: mov    0x8(%rsp),%rax
    0.00 :   40e17d: lea    0x1(%rsi),%edx
    0.00 :   40e180: mov    (%rax,%rbp,4),%eax
    0.00 :   40e183: add    $0x1,%rbp
    0.00 :   40e187: mov    %edx,0x240(%rbx)
    0.00 :   40e18d: mov    %eax,(%r8,%rsi,4)
    0.00 :   40e191: cmp    %r12,%rbp
    0.00 :   40e194: je     40e210 <Minisat::Solver::rebuildOrderHeap()+0x1a0>
         : 133    T&       operator [] (int index)       { return data[index]; }
    0.00 :   40e196: mov    0x8(%rsp),%rax
    0.00 :   40e19b: movslq (%rax,%rbp,4),%rdx
         : 136    indices[ns[i]] = i;
    0.00 :   40e19f: mov    0x248(%rbx),%rax
    0.00 :   40e1a6: mov    %ebp,(%rax,%rdx,4)
         : 139    void     push  (const T& elem)     { if (sz == cap) capacity(sz+1); data[sz++] = elem; }
    0.00 :   40e1a9: movslq 0x240(%rbx),%rsi
    0.00 :   40e1b0: cmp    0x244(%rbx),%esi
    0.00 :   40e1b6: jne    40e178 <Minisat::Solver::rebuildOrderHeap()+0x108>
    0.00 :   40e1b8: add    $0x1,%esi
    0.00 :   40e1bb: mov    %r13,%rdi
    0.00 :   40e1be: call   40adf0 <Minisat::vec<int>::capacity(int)>
    0.00 :   40e1c3: mov    0x238(%rbx),%r8
    0.00 :   40e1ca: movslq 0x240(%rbx),%rsi
    0.00 :   40e1d1: jmp    40e178 <Minisat::Solver::rebuildOrderHeap()+0x108>
    0.00 :   40e1d3: nopl   0x0(%rax,%rax,1)
         : 150    if (data != NULL){
    0.00 :   40e1d8: cmpq   $0x0,0x8(%rsp)
    0.00 :   40e1de: je     40e346 <Minisat::Solver::rebuildOrderHeap()+0x2d6>
         : 153    if (dealloc) free(data), data = NULL, cap = 0; } }
    0.00 :   40e1e4: mov    0x38(%rsp),%rax
    0.00 :   40e1e9: sub    %fs:0x28,%rax
    0.00 :   40e1f2: jne    40e405 <Minisat::Solver::rebuildOrderHeap()+0x395>
    0.00 :   40e1f8: mov    0x8(%rsp),%rdi
         :
         : 159    vs.push(v);
         : 160    }/*auto*/
         : 161    }/*auto*/
         : 162    order_heap.build(vs);
         : 163    }
    0.00 :   40e1fd: add    $0x48,%rsp
    0.00 :   40e201: pop    %rbx
    0.00 :   40e202: pop    %rbp
    0.00 :   40e203: pop    %r12
    0.00 :   40e205: pop    %r13
    0.00 :   40e207: pop    %r14
    0.00 :   40e209: pop    %r15
    0.00 :   40e20b: jmp    4657f0 <__free>
         : 172    int      size     (void) const     { return sz; }
    0.00 :   40e210: mov    0x240(%rbx),%r11d
         : 174    heap.push(ns[i]); }
         :
         : 176    for (int i = heap.size() / 2 - 1; i >= 0; i--)
    0.00 :   40e217: mov    %r11d,%eax
    0.00 :   40e21a: shr    $0x1f,%eax
    0.00 :   40e21d: add    %r11d,%eax
    0.00 :   40e220: sar    %eax
    0.00 :   40e222: sub    $0x1,%eax
    0.00 :   40e225: mov    %eax,%r14d
    0.00 :   40e228: js     40e1e4 <Minisat::Solver::rebuildOrderHeap()+0x174>
    0.00 :   40e22a: movslq %r14d,%rax
         : 185    T&       operator [] (int index)       { return data[index]; }
    0.00 :   40e22d: mov    0x248(%rbx),%r13
    0.00 :   40e234: lea    (%r8,%rax,4),%r15
    0.00 :   40e238: lea    0x1(%r14,%r14,1),%eax
    0.00 :   40e23d: mov    %eax,0x10(%rsp)
    0.00 :   40e241: nopl   0x0(%rax)
         : 191    int x = heap[i];
    0.00 :   40e248: movslq (%r15),%rdx
         : 193    static inline int left  (int i) { return i*2+1; }
    0.00 :   40e24b: mov    0x10(%rsp),%edi
    0.00 :   40e24f: mov    %r15,%rbp
         : 196    int x = heap[i];
    0.00 :   40e252: mov    %edx,0x14(%rsp)
         : 198    static inline int left  (int i) { return i*2+1; }
    0.00 :   40e256: mov    %edi,%ecx
    0.00 :   40e258: mov    %rdx,0x18(%rsp)
         : 201    while (left(i) < heap.size()){
    0.00 :   40e25d: cmp    %r11d,%edi
    0.00 :   40e260: jge    40e337 <Minisat::Solver::rebuildOrderHeap()+0x2c7>
         : 204    const T& operator [] (int index) const { return data[index]; }
    0.00 :   40e266: mov    0x230(%rbx),%rax
    0.00 :   40e26d: mov    (%rax),%r10
         : 207    bool operator () (Var x, Var y) const { return activity[x] > activity[y]; }
    0.00 :   40e270: movsd  (%r10,%rdx,8),%xmm2
    0.00 :   40e276: mov    %r14d,%edx
    0.00 :   40e279: jmp    40e2ca <Minisat::Solver::rebuildOrderHeap()+0x25a>
    0.00 :   40e27b: nopl   0x0(%rax,%rax,1)
         : 212    T&       operator [] (int index)       { return data[index]; }
    0.00 :   40e280: movslq %eax,%r11
    0.00 :   40e283: lea    (%r8,%r11,4),%r11
         : 215    int child = right(i) < heap.size() && lt(heap[right(i)], heap[left(i)]) ? right(i) : left(i);
    0.00 :   40e287: movslq (%r11),%r12
    0.00 :   40e28a: movsd  (%r10,%r12,8),%xmm1
    0.00 :   40e290: comisd %xmm0,%xmm1
    0.00 :   40e294: jbe    40e2e6 <Minisat::Solver::rebuildOrderHeap()+0x276>
    0.00 :   40e296: movapd %xmm1,%xmm0
    0.00 :   40e29a: movslq %edx,%rcx
    0.00 :   40e29d: mov    %r12,%rsi
    0.00 :   40e2a0: mov    %r12d,%edi
         : 224    if (!lt(heap[child], x)) break;
    0.00 :   40e2a3: comisd %xmm2,%xmm0
    0.00 :   40e2a7: mov    %r11,%r9
    0.00 :   40e2aa: lea    (%r8,%rcx,4),%rbp
    0.00 :   40e2ae: jbe    40e2f5 <Minisat::Solver::rebuildOrderHeap()+0x285>
         : 229    heap[i]          = heap[child];
    0.00 :   40e2b0: mov    %edi,0x0(%rbp)
         : 231    static inline int left  (int i) { return i*2+1; }
    0.00 :   40e2b3: lea    0x1(%rax,%rax,1),%ecx
         : 233    indices[heap[i]] = i;
    0.00 :   40e2b7: mov    %edx,0x0(%r13,%rsi,4)
         : 235    int      size     (void) const     { return sz; }
    0.00 :   40e2bc: mov    0x240(%rbx),%r11d
         : 237    while (left(i) < heap.size()){
    0.00 :   40e2c3: cmp    %ecx,%r11d
    0.00 :   40e2c6: jle    40e330 <Minisat::Solver::rebuildOrderHeap()+0x2c0>
    0.00 :   40e2c8: mov    %eax,%edx
         : 241    T&       operator [] (int index)       { return data[index]; }
    0.00 :   40e2ca: movslq %ecx,%rsi
         : 243    static inline int right (int i) { return (i+1)*2; }
    0.00 :   40e2cd: lea    0x2(%rdx,%rdx,1),%eax
    0.00 :   40e2d1: lea    (%r8,%rsi,4),%r9
         : 246    int child = right(i) < heap.size() && lt(heap[right(i)], heap[left(i)]) ? right(i) : left(i);
    0.00 :   40e2d5: movslq (%r9),%rsi
    0.00 :   40e2d8: movsd  (%r10,%rsi,8),%xmm0
    0.00 :   40e2de: mov    %rsi,%rdi
    0.00 :   40e2e1: cmp    %r11d,%eax
    0.00 :   40e2e4: jl     40e280 <Minisat::Solver::rebuildOrderHeap()+0x210>
         : 252    if (!lt(heap[child], x)) break;
    0.00 :   40e2e6: comisd %xmm2,%xmm0
    0.00 :   40e2ea: mov    %ecx,%eax
    0.00 :   40e2ec: movslq %edx,%rcx
    0.00 :   40e2ef: lea    (%r8,%rcx,4),%rbp
    0.00 :   40e2f3: ja     40e2b0 <Minisat::Solver::rebuildOrderHeap()+0x240>
         : 258    heap   [i] = x;
    0.00 :   40e2f5: mov    0x14(%rsp),%eax
         : 260    for (int i = heap.size() / 2 - 1; i >= 0; i--)
    0.00 :   40e2f9: sub    $0x1,%r14d
    0.00 :   40e2fd: subl   $0x2,0x10(%rsp)
    0.00 :   40e302: sub    $0x4,%r15
         : 264    heap   [i] = x;
    0.00 :   40e306: mov    %eax,0x0(%rbp)
         : 266    indices[x] = i;
    0.00 :   40e309: mov    0x18(%rsp),%rax
    0.00 :   40e30e: mov    %edx,0x0(%r13,%rax,4)
         : 269    for (int i = heap.size() / 2 - 1; i >= 0; i--)
    0.00 :   40e313: cmp    $0xffffffff,%r14d
    0.00 :   40e317: je     40e1d8 <Minisat::Solver::rebuildOrderHeap()+0x168>
         : 272    int      size     (void) const     { return sz; }
    0.00 :   40e31d: mov    0x240(%rbx),%r11d
    0.00 :   40e324: jmp    40e248 <Minisat::Solver::rebuildOrderHeap()+0x1d8>
    0.00 :   40e329: nopl   0x0(%rax)
    0.00 :   40e330: mov    %r9,%rbp
    0.00 :   40e333: mov    %eax,%edx
    0.00 :   40e335: jmp    40e2f5 <Minisat::Solver::rebuildOrderHeap()+0x285>
         : 279    while (left(i) < heap.size()){
    0.00 :   40e337: mov    %r14d,%edx
    0.00 :   40e33a: jmp    40e2f5 <Minisat::Solver::rebuildOrderHeap()+0x285>
         : 282    sz = 0;
    0.00 :   40e33c: movl   $0x0,0x240(%rdi)
    0.00 :   40e346: mov    0x38(%rsp),%rax
    0.00 :   40e34b: sub    %fs:0x28,%rax
    0.00 :   40e354: jne    40e405 <Minisat::Solver::rebuildOrderHeap()+0x395>
    0.00 :   40e35a: add    $0x48,%rsp
    0.00 :   40e35e: pop    %rbx
    0.00 :   40e35f: pop    %rbp
    0.00 :   40e360: pop    %r12
    0.00 :   40e362: pop    %r13
    0.00 :   40e364: pop    %r14
    0.00 :   40e366: pop    %r15
    0.00 :   40e368: ret
         : 295    heap.clear();
    0.00 :   40e369: lea    0x238(%rbx),%r13
         : 297    if (data != NULL){
    0.00 :   40e370: test   %r8,%r8
    0.00 :   40e373: jne    40e15e <Minisat::Solver::rebuildOrderHeap()+0xee>
         : 300    for (int i = 0; i < ns.size(); i++){
    0.00 :   40e379: test   %r12d,%r12d
    0.00 :   40e37c: jg     40e16d <Minisat::Solver::rebuildOrderHeap()+0xfd>
         : 303    int      size     (void) const     { return sz; }
    0.00 :   40e382: mov    0x240(%rbx),%r11d
         : 305    for (int i = heap.size() / 2 - 1; i >= 0; i--)
    0.00 :   40e389: mov    %r11d,%eax
    0.00 :   40e38c: shr    $0x1f,%eax
    0.00 :   40e38f: add    %r11d,%eax
    0.00 :   40e392: sar    %eax
    0.00 :   40e394: sub    $0x1,%eax
    0.00 :   40e397: mov    %eax,%r14d
    0.00 :   40e39a: js     40e1d8 <Minisat::Solver::rebuildOrderHeap()+0x168>
    0.00 :   40e3a0: xor    %r8d,%r8d
    0.00 :   40e3a3: jmp    40e22a <Minisat::Solver::rebuildOrderHeap()+0x1ba>
         : 315    void     push  (const T& elem)     { if (sz == cap) capacity(sz+1); data[sz++] = elem; }
    0.00 :   40e3a8: lea    0x1(%r12),%esi
    0.00 :   40e3ad: mov    %r14,%rdi
    0.00 :   40e3b0: call   40adf0 <Minisat::vec<int>::capacity(int)>
    0.00 :   40e3b5: movslq 0x28(%rsp),%r12
    0.00 :   40e3ba: jmp    40e0f0 <Minisat::Solver::rebuildOrderHeap()+0x80>
         : 321    for (int i = 0; i < heap.size(); i++)
    0.00 :   40e3bf: mov    0x240(%rdi),%edx
         : 323    if (data != NULL){
    0.00 :   40e3c5: mov    0x238(%rdi),%r8
    0.00 :   40e3cc: movq   $0x0,0x8(%rsp)
    0.00 :   40e3d5: test   %edx,%edx
    0.00 :   40e3d7: jg     40e137 <Minisat::Solver::rebuildOrderHeap()+0xc7>
    0.00 :   40e3dd: test   %r8,%r8
    0.00 :   40e3e0: jne    40e33c <Minisat::Solver::rebuildOrderHeap()+0x2cc>
         : 330    int      size     (void) const     { return sz; }
    0.00 :   40e3e6: mov    0x240(%rdi),%r11d
         : 332    for (int i = heap.size() / 2 - 1; i >= 0; i--)
    0.00 :   40e3ed: mov    %r11d,%eax
    0.00 :   40e3f0: shr    $0x1f,%eax
    0.00 :   40e3f3: add    %r11d,%eax
    0.00 :   40e3f6: sar    %eax
    0.00 :   40e3f8: sub    $0x1,%eax
    0.00 :   40e3fb: mov    %eax,%r14d
    0.00 :   40e3fe: jns    40e3a0 <Minisat::Solver::rebuildOrderHeap()+0x330>
    0.00 :   40e400: jmp    40e346 <Minisat::Solver::rebuildOrderHeap()+0x2d6>
    0.00 :   40e405: call   49fd70 <__stack_chk_fail>
    0.00 :   40e40a: endbr64
         : 343    if (data != NULL){
    0.00 :   40e40e: mov    %rax,%rbp
    0.00 :   40e411: jmp    4014dc <Minisat::Solver::rebuildOrderHeap() [clone .cold]>
 Percent |	Source code & Disassembly of minisat_HACK_999ED_CSSC_static for cycles:u (1 samples, percent: local period)
---------------------------------------------------------------------------------------------------------------------------
         :
         :
         :
         : 3      Disassembly of section .text:
         :
         : 5      000000000040fac0 <Minisat::Solver::propagate()>:
         : 6      |
         : 7      |    Post-conditions:
         : 8      |      * the propagation queue is empty, even if there was a conflict.
         : 9      |________________________________________________________________________________________________@*/
         : 10     CRef Solver::propagate()
         : 11     {
    0.00 :   40fac0: endbr64
    0.00 :   40fac4: push   %r15
    0.00 :   40fac6: mov    %rdi,%r9
         : 15     CRef    confl     = CRef_Undef;
         : 16     int     num_props = 0;
         : 17     watches.cleanAll();
    0.00 :   40fac9: add    $0x178,%rdi
         : 19     {
    0.00 :   40fad0: push   %r14
    0.00 :   40fad2: push   %r13
    0.00 :   40fad4: push   %r12
    0.00 :   40fad6: push   %rbp
    0.00 :   40fad7: push   %rbx
    0.00 :   40fad8: sub    $0x28,%rsp
         : 26     watches.cleanAll();
    0.00 :   40fadc: mov    %r9,(%rsp)
    0.00 :   40fae0: call   4120a0 <Minisat::OccLists<Minisat::Lit, Minisat::vec<Minisat::Solver::Watcher>, Minisat::Solver::WatcherDeleted>::cleanAll()>
         :
         : 30     while (qhead < trail.size()){
    0.00 :   40fae5: mov    (%rsp),%r9
    0.00 :   40fae9: movslq 0x210(%r9),%rax
         :
         : 34     // Pointer to first element:
         : 35     operator T*       (void)           { return data; }
         :
         : 37     // Size operations:
         : 38     int      size     (void) const     { return sz; }
    0.00 :   40faf0: mov    0x1e8(%r9),%edx
    0.00 :   40faf7: cmp    %edx,%eax
    0.00 :   40faf9: jge    40fdc8 <Minisat::Solver::propagate()+0x308>
         : 42     int     num_props = 0;
    0.00 :   40faff: movl   $0x0,0xc(%rsp)
         : 44     CRef    confl     = CRef_Undef;
    0.00 :   40fb07: mov    %r9,%r12
    0.00 :   40fb0a: movl   $0xffffffff,0x18(%rsp)
    0.00 :   40fb12: nopw   0x0(%rax,%rax,1)
         : 48     Lit            p   = trail[qhead++];     // 'p' is enqueued fact to propagate.
    0.00 :   40fb18: mov    0x1e0(%r12),%rsi
    0.00 :   40fb20: lea    0x1(%rax),%ecx
         : 51     vec<Watcher>&  ws  = watches[p];
         : 52     Watcher        *i, *j, *end;
         : 53     num_props++;
    0.00 :   40fb23: addl   $0x1,0xc(%rsp)
         : 55     Lit            p   = trail[qhead++];     // 'p' is enqueued fact to propagate.
    0.00 :   40fb28: mov    %ecx,0x210(%r12)
    0.00 :   40fb30: movslq (%rsi,%rax,4),%rax
    0.00 :   40fb34: mov    %rax,%r9
         : 59     const T& last  (void) const        { return data[sz-1]; }
         : 60     T&       last  (void)              { return data[sz-1]; }
         :
         : 62     // Vector interface:
         : 63     const T& operator [] (int index) const { return data[index]; }
         : 64     T&       operator [] (int index)       { return data[index]; }
    0.00 :   40fb37: shl    $0x4,%rax
    0.00 :   40fb3b: add    0x178(%r12),%rax
         : 67     operator T*       (void)           { return data; }
    0.00 :   40fb43: mov    (%rax),%rbp
         : 69     T&       operator [] (int index)       { return data[index]; }
    0.00 :   40fb46: mov    %rax,(%rsp)
         :
         : 72     for (i = j = (Watcher*)ws, end = i + ws.size();  i != end;){
    0.00 :   40fb4a: movslq 0x8(%rax),%rax
    0.00 :   40fb4e: lea    0x0(%rbp,%rax,8),%r13
    0.00 :   40fb53: cmp    %rbp,%r13
    0.00 :   40fb56: je     40fdb0 <Minisat::Solver::propagate()+0x2f0>
    0.00 :   40fb5c: mov    %rbp,%r8
         : 78     bool operator <  (Lit p) const { return x < p.x;  } // '<' makes p, ~p adjacent in the ordering.
         : 79     };
         :
         :
         : 82     inline  Lit  mkLit     (Var var, bool sign=false) { Lit p; p.x = var + var + (int)sign; return p; }
         : 83     inline  Lit  operator ~(Lit p)              { Lit q; q.x = p.x ^ 1; return q; }
    0.00 :   40fb5f: xor    $0x1,%r9d
    0.00 :   40fb63: jmp    40fbb7 <Minisat::Solver::propagate()+0xf7>
    0.00 :   40fb65: nopl   (%rax)
         : 87     Lit blocker = i->blocker;
         : 88     if (value(blocker) == l_True){
         : 89     *j++ = *i++; continue; }
         :
         : 91     // Make sure the false literal is data[1]:
         : 92     CRef     cr        = i->cref;
    0.00 :   40fb68: mov    (%r8),%esi
         :
         : 95     Ref      alloc     (int size);
         : 96     void     free      (int size)    { wasted_ += size; }
         :
         : 98     // Deref, Load Effective Address (LEA), Inverse of LEA (AEL):
         : 99     T&       operator[](Ref r)       { assert(r >= 0 && r < sz); return memory[r]; }
    0.00 :   40fb6b: mov    0x308(%r12),%rax
    0.00 :   40fb73: mov    %rsi,%r14
    0.00 :   40fb76: lea    (%rax,%rsi,4),%rsi
         : 103    bool operator == (Lit p) const { return x == p.x; }
    0.00 :   40fb7a: mov    0x4(%rsi),%ebx
         : 105    Clause&  c         = ca[cr];
         : 106    Lit      false_lit = ~p;
         : 107    if (c[0] == false_lit)/*auto*/{
    0.00 :   40fb7d: cmp    %r9d,%ebx
    0.00 :   40fb80: jne    40fb8c <Minisat::Solver::propagate()+0xcc>
         :
         : 111    c[0] = c[1], c[1] = false_lit;
    0.00 :   40fb82: mov    0x8(%rsi),%ebx
    0.00 :   40fb85: mov    %r9d,0x8(%rsi)
    0.00 :   40fb89: mov    %ebx,0x4(%rsi)
         : 115    i++;
         :
         : 117    // If 0th watch is true, then clause is already satisfied.
         : 118    Lit     first = c[0];
         : 119    Watcher w     = Watcher(cr, first);
         : 120    if (first != blocker && value(first) == l_True){
    0.00 :   40fb8c: cmp    %ebx,%edx
    0.00 :   40fb8e: je     40fbe8 <Minisat::Solver::propagate()+0x128>
         : 123    inline  Lit  operator ^(Lit p, bool b)      { Lit q; q.x = p.x ^ (unsigned int)b; return q; }
         : 124    inline  bool sign      (Lit p)              { return p.x & 1; }
         : 125    inline  int  var       (Lit p)              { return p.x >> 1; }
    0.00 :   40fb90: mov    %ebx,%eax
         : 127    inline  bool sign      (Lit p)              { return p.x & 1; }
    0.00 :   40fb92: mov    %ebx,%edx
         : 129    inline  int  var       (Lit p)              { return p.x >> 1; }
    0.00 :   40fb94: sar    %eax
         : 131    inline  bool sign      (Lit p)              { return p.x & 1; }
    0.00 :   40fb96: and    $0x1,%edx
         : 133    const T& operator [] (int index) const { return data[index]; }
    0.00 :   40fb99: cltq
    0.00 :   40fb9b: cmp    %dl,(%rcx,%rax,1)
    0.00 :   40fb9e: jne    40fbe8 <Minisat::Solver::propagate()+0x128>
         : 137    *j++ = w; continue; }
    0.00 :   40fba0: mov    %r14d,0x0(%rbp)
    0.00 :   40fba4: add    $0x8,%rbp
    0.00 :   40fba8: mov    %ebx,-0x4(%rbp)
         : 141    *j++ = *i++; continue; }
    0.00 :   40fbab: mov    %r15,%r8
         : 143    for (i = j = (Watcher*)ws, end = i + ws.size();  i != end;){
    0.00 :   40fbae: cmp    %r8,%r13
    0.00 :   40fbb1: je     40fc78 <Minisat::Solver::propagate()+0x1b8>
         : 146    Lit blocker = i->blocker;
    0.00 :   40fbb7: mov    0x4(%r8),%edx
    0.00 :   40fbbb: mov    0x1b0(%r12),%rcx
         : 149    *j++ = *i++; continue; }
    0.00 :   40fbc3: lea    0x8(%r8),%r15
         : 151    inline  int  var       (Lit p)              { return p.x >> 1; }
    0.00 :   40fbc7: mov    %edx,%eax
         : 153    inline  bool sign      (Lit p)              { return p.x & 1; }
    0.00 :   40fbc9: mov    %edx,%esi
         : 155    inline  int  var       (Lit p)              { return p.x >> 1; }
    0.00 :   40fbcb: sar    %eax
         : 157    inline  bool sign      (Lit p)              { return p.x & 1; }
    0.00 :   40fbcd: and    $0x1,%esi
    0.00 :   40fbd0: cltq
         : 160    if (value(blocker) == l_True){
    0.00 :   40fbd2: cmp    %sil,(%rcx,%rax,1)
    0.00 :   40fbd6: jne    40fb68 <Minisat::Solver::propagate()+0xa8>
         : 163    *j++ = *i++; continue; }
    0.00 :   40fbd8: mov    (%r8),%rax
    0.00 :   40fbdb: add    $0x8,%rbp
    0.00 :   40fbdf: mov    %rax,-0x8(%rbp)
    0.00 :   40fbe3: jmp    40fbab <Minisat::Solver::propagate()+0xeb>
    0.00 :   40fbe5: nopl   (%rax)
         : 169    for (int i = 0; i < size(); i++)
         : 170    abstraction |= 1 << (var(data[i].lit) & 31);
         : 171    data[header.size].abs = abstraction;  }
         :
         :
         : 174    int          size        ()      const   { return header.size; }
    0.00 :   40fbe8: mov    (%rsi),%eax
         :
         : 177    // Look for new watch:
         : 178    for (int k = 2; k < c.size(); k++)/*auto*/{
    0.00 :   40fbea: mov    $0x2,%edx
    0.00 :   40fbef: mov    %eax,%r10d
    0.00 :   40fbf2: shr    $0x5,%r10d
    0.00 :   40fbf6: cmp    $0x5f,%eax
    0.00 :   40fbf9: ja     40fc0d <Minisat::Solver::propagate()+0x14d>
    0.00 :   40fbfb: jmp    40fcd0 <Minisat::Solver::propagate()+0x210>
    0.00 :   40fc00: add    $0x1,%rdx
    0.00 :   40fc04: cmp    %edx,%r10d
    0.00 :   40fc07: jle    40fcd0 <Minisat::Solver::propagate()+0x210>
    0.00 :   40fc0d: mov    0x4(%rsi,%rdx,4),%eax
    0.00 :   40fc11: movslq %edx,%rdi
         : 190    inline  int  var       (Lit p)              { return p.x >> 1; }
    0.00 :   40fc14: mov    %eax,%r11d
         : 192    inline  bool sign      (Lit p)              { return p.x & 1; }
    0.00 :   40fc17: and    $0x1,%eax
         : 194    inline  int  var       (Lit p)              { return p.x >> 1; }
    0.00 :   40fc1a: sar    %r11d
    0.00 :   40fc1d: movslq %r11d,%r11
         : 197    lbool operator ^  (bool  b) const { return lbool((uint8_t)(value^(uint8_t)b)); }
    0.00 :   40fc20: xor    (%rcx,%r11,1),%al
         :
         : 200    if (value(c[k]) != l_False){
    0.00 :   40fc24: cmp    $0x1,%al
    0.00 :   40fc26: je     40fc00 <Minisat::Solver::propagate()+0x140>
         : 203    c[1] = c[k]; c[k] = false_lit;
    0.00 :   40fc28: mov    0x4(%rsi,%rdi,4),%eax
    0.00 :   40fc2c: mov    %eax,0x8(%rsi)
    0.00 :   40fc2f: mov    %r9d,0x4(%rsi,%rdi,4)
         : 207    inline  Lit  operator ~(Lit p)              { Lit q; q.x = p.x ^ 1; return q; }
    0.00 :   40fc34: mov    0x8(%rsi),%eax
    0.00 :   40fc37: xor    $0x1,%eax
         : 210    T&       operator [] (int index)       { return data[index]; }
    0.00 :   40fc3a: cltq
    0.00 :   40fc3c: shl    $0x4,%rax
    0.00 :   40fc40: add    0x178(%r12),%rax
         : 214    void     push  (const T& elem)     { if (sz == cap) capacity(sz+1); data[sz++] = elem; }
    0.00 :   40fc48: movslq 0x8(%rax),%rdx
    0.00 :   40fc4c: cmp    0xc(%rax),%edx
    0.00 :   40fc4f: je     40fd88 <Minisat::Solver::propagate()+0x2c8>
    0.00 :   40fc55: lea    0x1(%rdx),%ecx
         : 219    *j++ = *i++; continue; }
    0.00 :   40fc58: mov    %r15,%r8
    0.00 :   40fc5b: mov    %ecx,0x8(%rax)
    0.00 :   40fc5e: mov    (%rax),%rcx
    0.00 :   40fc61: lea    (%rcx,%rdx,8),%rdx
    0.00 :   40fc65: mov    %r14d,(%rdx)
  100.00 :   40fc68: mov    %ebx,0x4(%rdx)
         : 226    for (i = j = (Watcher*)ws, end = i + ws.size();  i != end;){
    0.00 :   40fc6b: cmp    %r8,%r13
    0.00 :   40fc6e: jne    40fbb7 <Minisat::Solver::propagate()+0xf7>
    0.00 :   40fc74: nopl   0x0(%rax)
         : 230    uncheckedEnqueue(first, cr);
         : 231    }/*auto*/
         :
         : 233    NextClause:;
         : 234    }
         : 235    ws.shrink(i - j);
    0.00 :   40fc78: sub    %rbp,%r13
         : 237    while (qhead < trail.size()){
    0.00 :   40fc7b: movslq 0x210(%r12),%rax
         : 239    int      size     (void) const     { return sz; }
    0.00 :   40fc83: mov    0x1e8(%r12),%edx
         : 241    ws.shrink(i - j);
    0.00 :   40fc8b: sar    $0x3,%r13
         : 243    void     shrink   (int nelems)     { assert(nelems <= sz); for (int i = 0; i < nelems; i++) sz--, data[sz].~T(); }
    0.00 :   40fc8f: test   %r13d,%r13d
    0.00 :   40fc92: jle    40fc9c <Minisat::Solver::propagate()+0x1dc>
    0.00 :   40fc94: mov    (%rsp),%rdi
    0.00 :   40fc98: sub    %r13d,0x8(%rdi)
         : 248    while (qhead < trail.size()){
    0.00 :   40fc9c: cmp    %edx,%eax
    0.00 :   40fc9e: jl     40fb18 <Minisat::Solver::propagate()+0x58>
         : 251    }
         : 252    propagations += num_props;
    0.00 :   40fca4: movslq 0xc(%rsp),%rax
    0.00 :   40fca9: mov    %r12,%r9
         : 255    simpDB_props -= num_props;
    0.00 :   40fcac: mov    %rax,%rdx
         : 257    propagations += num_props;
    0.00 :   40fcaf: add    %rax,0xc0(%r9)
         :
         : 260    return confl;
         : 261    }
    0.00 :   40fcb6: mov    0x18(%rsp),%eax
         : 263    simpDB_props -= num_props;
    0.00 :   40fcba: sub    %rdx,0x218(%r9)
         : 265    }
    0.00 :   40fcc1: add    $0x28,%rsp
    0.00 :   40fcc5: pop    %rbx
    0.00 :   40fcc6: pop    %rbp
    0.00 :   40fcc7: pop    %r12
    0.00 :   40fcc9: pop    %r13
    0.00 :   40fccb: pop    %r14
    0.00 :   40fccd: pop    %r15
    0.00 :   40fccf: ret
         : 274    inline  int  var       (Lit p)              { return p.x >> 1; }
    0.00 :   40fcd0: mov    %ebx,%edx
         : 276    *j++ = w;
    0.00 :   40fcd2: mov    %r14d,0x0(%rbp)
         : 278    inline  bool sign      (Lit p)              { return p.x & 1; }
    0.00 :   40fcd6: mov    %ebx,%esi
         : 280    int      size     (void) const     { return sz; }
    0.00 :   40fcd8: mov    0x1e8(%r12),%r10d
         : 282    inline  int  var       (Lit p)              { return p.x >> 1; }
    0.00 :   40fce0: sar    %edx
    0.00 :   40fce2: mov    %ebx,0x4(%rbp)
         : 285    inline  bool sign      (Lit p)              { return p.x & 1; }
    0.00 :   40fce5: and    $0x1,%esi
    0.00 :   40fce8: lea    0x8(%rbp),%rax
         : 288    const T& operator [] (int index) const { return data[index]; }
    0.00 :   40fcec: movslq %edx,%rdx
    0.00 :   40fcef: add    %rdx,%rcx
         : 291    lbool operator ^  (bool  b) const { return lbool((uint8_t)(value^(uint8_t)b)); }
    0.00 :   40fcf2: movzbl (%rcx),%edi
    0.00 :   40fcf5: xor    %esi,%edi
         : 294    if (value(first) == l_False){
    0.00 :   40fcf7: cmp    $0x1,%dil
    0.00 :   40fcfb: je     40fd40 <Minisat::Solver::propagate()+0x280>
         : 297    assigns[var(p)] = lbool(!sign(p));
    0.00 :   40fcfd: mov    %sil,(%rcx)
         : 299    T&       operator [] (int index)       { return data[index]; }
    0.00 :   40fd00: mov    0x200(%r12),%rcx
         : 301    *j++ = w;
    0.00 :   40fd08: mov    %rax,%rbp
         : 303    *j++ = *i++; continue; }
    0.00 :   40fd0b: mov    %r15,%r8
         : 305    int      size     (void) const     { return sz; }
    0.00 :   40fd0e: mov    0x1f8(%r12),%esi
         : 307    T&       operator [] (int index)       { return data[index]; }
    0.00 :   40fd16: lea    (%rcx,%rdx,8),%rcx
         : 309    void     push_ (const T& elem)     { assert(sz < cap); data[sz++] = elem; }
    0.00 :   40fd1a: lea    0x1(%r10),%edx
         : 311    vardata[var(p)] = mkVarData(from, decisionLevel());
    0.00 :   40fd1e: mov    %r14d,(%rcx)
    0.00 :   40fd21: mov    %esi,0x4(%rcx)
    0.00 :   40fd24: mov    0x1e0(%r12),%rcx
    0.00 :   40fd2c: mov    %edx,0x1e8(%r12)
    0.00 :   40fd34: movslq %r10d,%rdx
    0.00 :   40fd37: mov    %ebx,(%rcx,%rdx,4)
    0.00 :   40fd3a: jmp    40fbae <Minisat::Solver::propagate()+0xee>
    0.00 :   40fd3f: nop
         : 320    qhead = trail.size();
    0.00 :   40fd40: mov    %r10d,0x210(%r12)
         : 322    while (i < end)/*auto*/{
    0.00 :   40fd48: cmp    %r15,%r13
    0.00 :   40fd4b: jbe    40fdb8 <Minisat::Solver::propagate()+0x2f8>
         : 325    *j++ = w;
    0.00 :   40fd4d: mov    %rax,%rdi
         : 327    while (i < end)/*auto*/{
    0.00 :   40fd50: mov    %r15,%rsi
    0.00 :   40fd53: nopl   0x0(%rax,%rax,1)
         : 330    *j++ = *i++;
    0.00 :   40fd58: movsq  %ds:(%rsi),%es:(%rdi)
         : 332    while (i < end)/*auto*/{
    0.00 :   40fd5a: cmp    %rsi,%r13
    0.00 :   40fd5d: ja     40fd58 <Minisat::Solver::propagate()+0x298>
    0.00 :   40fd5f: lea    -0x9(%r13),%rdx
         : 336    confl = cr;
    0.00 :   40fd63: mov    %r14d,0x18(%rsp)
    0.00 :   40fd68: sub    %r8,%rdx
    0.00 :   40fd6b: shr    $0x3,%rdx
    0.00 :   40fd6f: lea    0x8(,%rdx,8),%rbp
         : 341    *j++ = *i++;
    0.00 :   40fd77: lea    (%r15,%rbp,1),%r8
    0.00 :   40fd7b: add    %rax,%rbp
    0.00 :   40fd7e: jmp    40fbae <Minisat::Solver::propagate()+0xee>
    0.00 :   40fd83: nopl   0x0(%rax,%rax,1)
         : 346    void     push  (const T& elem)     { if (sz == cap) capacity(sz+1); data[sz++] = elem; }
    0.00 :   40fd88: lea    0x1(%rdx),%esi
    0.00 :   40fd8b: mov    %rax,%rdi
    0.00 :   40fd8e: mov    %r9d,0x1c(%rsp)
    0.00 :   40fd93: mov    %rax,0x10(%rsp)
    0.00 :   40fd98: call   412550 <Minisat::vec<Minisat::Solver::Watcher>::capacity(int)>
    0.00 :   40fd9d: mov    0x10(%rsp),%rax
    0.00 :   40fda2: mov    0x1c(%rsp),%r9d
    0.00 :   40fda7: movslq 0x8(%rax),%rdx
    0.00 :   40fdab: jmp    40fc55 <Minisat::Solver::propagate()+0x195>
         : 356    for (i = j = (Watcher*)ws, end = i + ws.size();  i != end;){
    0.00 :   40fdb0: movslq %ecx,%rax
    0.00 :   40fdb3: jmp    40fc9c <Minisat::Solver::propagate()+0x1dc>
         : 359    confl = cr;
    0.00 :   40fdb8: mov    %r14d,0x18(%rsp)
         : 361    *j++ = w;
    0.00 :   40fdbd: mov    %rax,%rbp
         : 363    while (i < end)/*auto*/{
    0.00 :   40fdc0: mov    %r15,%r8
    0.00 :   40fdc3: jmp    40fbae <Minisat::Solver::propagate()+0xee>
         : 366    CRef    confl     = CRef_Undef;
    0.00 :   40fdc8: movl   $0xffffffff,0x18(%rsp)
         : 368    while (qhead < trail.size()){
    0.00 :   40fdd0: xor    %edx,%edx
    0.00 :   40fdd2: xor    %eax,%eax
    0.00 :   40fdd4: jmp    40fcaf <Minisat::Solver::propagate()+0x1ef>
 Percent |	Source code & Disassembly of minisat_HACK_999ED_CSSC_static for cycles:u (1 samples, percent: local period)
---------------------------------------------------------------------------------------------------------------------------
         :
         :
         :
         : 3      Disassembly of section .text:
         :
         : 5      000000000040bfc0 <int& std::deque<int, std::allocator<int> >::emplace_back<int>(int&&) [clone .isra.0]>:
         : 6      #if __cplusplus > 201402L
         : 7      typename deque<_Tp, _Alloc>::reference
         : 8      #else
         : 9      void
         : 10     #endif
         : 11     deque<_Tp, _Alloc>::
    0.00 :   40bfc0: push   %r15
    0.00 :   40bfc2: push   %r14
    0.00 :   40bfc4: push   %r13
    0.00 :   40bfc6: push   %r12
    0.00 :   40bfc8: push   %rbp
    0.00 :   40bfc9: mov    %rsi,%rbp
    0.00 :   40bfcc: push   %rbx
    0.00 :   40bfcd: mov    %rdi,%rbx
    0.00 :   40bfd0: sub    $0x8,%rsp
         : 21     emplace_back(_Args&&... __args)
         : 22     {
         : 23     if (this->_M_impl._M_finish._M_cur
         : 24     != this->_M_impl._M_finish._M_last - 1)
    0.00 :   40bfd4: mov    0x40(%rdi),%rcx
         : 26     if (this->_M_impl._M_finish._M_cur
    0.00 :   40bfd8: mov    0x30(%rdi),%rax
         : 28     != this->_M_impl._M_finish._M_last - 1)
    0.00 :   40bfdc: lea    -0x4(%rcx),%rdx
         : 30     if (this->_M_impl._M_finish._M_cur
    0.00 :   40bfe0: cmp    %rdx,%rax
    0.00 :   40bfe3: je     40c008 <int& std::deque<int, std::allocator<int> >::emplace_back<int>(int&&) [clone .isra.0]+0x48>
         : 33     #if __cplusplus >= 201103L
         : 34     template<typename _Up, typename... _Args>
         : 35     void
         : 36     construct(_Up* __p, _Args&&... __args)
         : 37     noexcept(std::is_nothrow_constructible<_Up, _Args...>::value)
         : 38     { ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }
    0.00 :   40bfe5: mov    (%rsi),%edx
         : 40     {
         : 41     _Alloc_traits::construct(this->_M_impl,
         : 42     this->_M_impl._M_finish._M_cur,
         : 43     std::forward<_Args>(__args)...);
         : 44     ++this->_M_impl._M_finish._M_cur;
  100.00 :   40bfe7: add    $0x4,%rax
    0.00 :   40bfeb: mov    %edx,-0x4(%rax)
    0.00 :   40bfee: mov    %rax,0x30(%rbx)
         : 48     else
         : 49     _M_push_back_aux(std::forward<_Args>(__args)...);
         : 50     #if __cplusplus > 201402L
         : 51     return back();
         : 52     #endif
         : 53     }
    0.00 :   40bff2: add    $0x8,%rsp
    0.00 :   40bff6: pop    %rbx
    0.00 :   40bff7: pop    %rbp
    0.00 :   40bff8: pop    %r12
    0.00 :   40bffa: pop    %r13
    0.00 :   40bffc: pop    %r14
    0.00 :   40bffe: pop    %r15
    0.00 :   40c000: ret
    0.00 :   40c001: nopl   0x0(%rax)
         :
         : 64     friend difference_type
         : 65     operator-(const _Self& __x, const _Self& __y) _GLIBCXX_NOEXCEPT
         : 66     {
         : 67     return difference_type(_S_buffer_size())
         : 68     * (__x._M_node - __y._M_node - bool(__x._M_node))
    0.00 :   40c008: mov    0x48(%rdi),%r12
    0.00 :   40c00c: mov    0x28(%rdi),%rsi
         : 71     void
         : 72     deque<_Tp, _Alloc>::
         : 73     _M_push_back_aux(const value_type& __t)
         : 74     #endif
         : 75     {
         : 76     if (size() == max_size())
    0.00 :   40c010: movabs $0x1fffffffffffffff,%r8
    0.00 :   40c01a: mov    %r12,%r13
    0.00 :   40c01d: sub    %rsi,%r13
    0.00 :   40c020: mov    %r13,%rcx
    0.00 :   40c023: sar    $0x3,%rcx
    0.00 :   40c027: cmp    $0x1,%r12
    0.00 :   40c02b: mov    %rcx,%rdx
    0.00 :   40c02e: adc    $0xffffffffffffffff,%rdx
         : 85     + (__x._M_cur - __x._M_first)
    0.00 :   40c032: sub    0x38(%rdi),%rax
         : 87     * (__x._M_node - __y._M_node - bool(__x._M_node))
    0.00 :   40c036: shl    $0x7,%rdx
         : 89     + (__x._M_cur - __x._M_first)
    0.00 :   40c03a: sar    $0x2,%rax
    0.00 :   40c03e: add    %rdx,%rax
         : 92     + (__y._M_last - __y._M_cur);
    0.00 :   40c041: mov    0x20(%rdi),%rdx
    0.00 :   40c045: sub    0x10(%rdi),%rdx
    0.00 :   40c049: sar    $0x2,%rdx
    0.00 :   40c04d: add    %rdx,%rax
    0.00 :   40c050: cmp    %r8,%rax
    0.00 :   40c053: je     40c1ec <int& std::deque<int, std::allocator<int> >::emplace_back<int>(int&&) [clone .isra.0]+0x22c>
         : 99     *  (And consequently, %deque iterators.)
         : 100    */
         : 101    void
         : 102    _M_reserve_map_at_back(size_type __nodes_to_add = 1)
         : 103    {
         : 104    if (__nodes_to_add + 1 > this->_M_impl._M_map_size
    0.00 :   40c059: mov    0x8(%rdi),%rdx
         : 106    - (this->_M_impl._M_finish._M_node - this->_M_impl._M_map))
    0.00 :   40c05d: mov    (%rdi),%rdi
    0.00 :   40c060: mov    %r12,%rax
    0.00 :   40c063: sub    %rdi,%rax
    0.00 :   40c066: mov    %rdx,%r9
    0.00 :   40c069: sar    $0x3,%rax
    0.00 :   40c06d: sub    %rax,%r9
         : 113    if (__nodes_to_add + 1 > this->_M_impl._M_map_size
    0.00 :   40c070: cmp    $0x1,%r9
    0.00 :   40c074: jbe    40c0c0 <int& std::deque<int, std::allocator<int> >::emplace_back<int>(int&&) [clone .isra.0]+0x100>
         : 116    return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
    0.00 :   40c076: mov    $0x200,%edi
    0.00 :   40c07b: call   4246e0 <operator new(unsigned long)>
         : 119    { ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }
    0.00 :   40c080: mov    0x0(%rbp),%edx
         : 121    __throw_length_error(
         : 122    __N("cannot create std::deque larger than max_size()"));
         :
         : 124    _M_reserve_map_at_back();
         : 125    *(this->_M_impl._M_finish._M_node + 1) = this->_M_allocate_node();
    0.00 :   40c083: mov    %rax,0x8(%r12)
    0.00 :   40c088: mov    0x30(%rbx),%rax
    0.00 :   40c08c: mov    %edx,(%rax)
         : 129    this->_M_impl._M_finish._M_cur,
         : 130    std::forward<_Args>(__args)...);
         : 131    #else
         : 132    this->_M_impl.construct(this->_M_impl._M_finish._M_cur, __t);
         : 133    #endif
         : 134    this->_M_impl._M_finish._M_set_node(this->_M_impl._M_finish._M_node
    0.00 :   40c08e: mov    0x48(%rbx),%rax
    0.00 :   40c092: lea    0x8(%rax),%rdx
         : 137    _M_first = *__new_node;
    0.00 :   40c096: mov    0x8(%rax),%rax
    0.00 :   40c09a: mov    %rdx,0x48(%rbx)
         : 140    _M_last = _M_first + difference_type(_S_buffer_size());
    0.00 :   40c09e: lea    0x200(%rax),%rdx
         : 142    _M_first = *__new_node;
    0.00 :   40c0a5: movq   %rax,%xmm0
    0.00 :   40c0aa: movq   %rdx,%xmm1
    0.00 :   40c0af: punpcklqdq %xmm1,%xmm0
    0.00 :   40c0b3: movups %xmm0,0x38(%rbx)
         : 147    __catch(...)
         : 148    {
         : 149    _M_deallocate_node(*(this->_M_impl._M_finish._M_node + 1));
         : 150    __throw_exception_again;
         : 151    }
         : 152    }
    0.00 :   40c0b7: jmp    40bfee <int& std::deque<int, std::allocator<int> >::emplace_back<int>(int&&) [clone .isra.0]+0x2e>
    0.00 :   40c0bc: nopl   0x0(%rax)
         : 155    deque<_Tp, _Alloc>::
         : 156    _M_reallocate_map(size_type __nodes_to_add, bool __add_at_front)
         : 157    {
         : 158    const size_type __old_num_nodes
         : 159    = this->_M_impl._M_finish._M_node - this->_M_impl._M_start._M_node + 1;
         : 160    const size_type __new_num_nodes = __old_num_nodes + __nodes_to_add;
    0.00 :   40c0c0: lea    0x2(%rcx),%r14
         :
         : 163    _Map_pointer __new_nstart;
         : 164    if (this->_M_impl._M_map_size > 2 * __new_num_nodes)
    0.00 :   40c0c4: lea    (%r14,%r14,1),%rax
    0.00 :   40c0c8: cmp    %rax,%rdx
    0.00 :   40c0cb: ja     40c190 <int& std::deque<int, std::allocator<int> >::emplace_back<int>(int&&) [clone .isra.0]+0x1d0>
         : 168    this->_M_impl._M_finish._M_node + 1,
         : 169    __new_nstart + __old_num_nodes);
         : 170    }
         : 171    else
         : 172    {
         : 173    size_type __new_map_size = this->_M_impl._M_map_size
    0.00 :   40c0d1: test   %rdx,%rdx
    0.00 :   40c0d4: mov    $0x1,%eax
    0.00 :   40c0d9: cmovne %rdx,%rax
    0.00 :   40c0dd: lea    0x2(%rdx,%rax,1),%r15
         : 178    if (__builtin_expect(__n > this->_M_max_size(), false))
    0.00 :   40c0e2: mov    %r15,%rax
    0.00 :   40c0e5: shr    $0x3c,%rax
    0.00 :   40c0e9: jne    40c1dd <int& std::deque<int, std::allocator<int> >::emplace_back<int>(int&&) [clone .isra.0]+0x21d>
         : 182    return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
    0.00 :   40c0ef: lea    0x0(,%r15,8),%rdi
    0.00 :   40c0f7: call   4246e0 <operator new(unsigned long)>
         : 185    __nodes_to_add) + 2;
         :
         : 187    _Map_pointer __new_map = this->_M_allocate_map(__new_map_size);
         : 188    __new_nstart = __new_map + (__new_map_size - __new_num_nodes) / 2
         : 189    + (__add_at_front ? __nodes_to_add : 0);
         : 190    std::copy(this->_M_impl._M_start._M_node,
    0.00 :   40c0fc: mov    0x28(%rbx),%rsi
    0.00 :   40c100: mov    %rax,%r12
         : 193    __new_nstart = __new_map + (__new_map_size - __new_num_nodes) / 2
    0.00 :   40c103: mov    %r15,%rax
    0.00 :   40c106: sub    %r14,%rax
    0.00 :   40c109: shr    %rax
    0.00 :   40c10c: lea    (%r12,%rax,8),%r14
         : 198    std::copy(this->_M_impl._M_start._M_node,
    0.00 :   40c110: mov    0x48(%rbx),%rax
    0.00 :   40c114: lea    0x8(%rax),%rdx
         : 201    is_copy_assignable<_Tp>>;
         : 202    // trivial types can have deleted assignment
         : 203    static_assert( __assignable::type::value, "type is not assignable" );
         : 204    #endif
         : 205    const ptrdiff_t _Num = __last - __first;
         : 206    if (_Num)
    0.00 :   40c118: cmp    %rsi,%rdx
    0.00 :   40c11b: je     40c128 <int& std::deque<int, std::allocator<int> >::emplace_back<int>(int&&) [clone .isra.0]+0x168>
         : 209    const ptrdiff_t _Num = __last - __first;
    0.00 :   40c11d: sub    %rsi,%rdx
         : 211    __builtin_memmove(__result, __first, sizeof(_Tp) * _Num);
    0.00 :   40c120: mov    %r14,%rdi
    0.00 :   40c123: call   401040 <_init+0x40>
         : 214    ::operator delete(__p
    0.00 :   40c128: mov    0x8(%rbx),%rax
    0.00 :   40c12c: mov    (%rbx),%rdi
    0.00 :   40c12f: lea    0x0(,%rax,8),%rsi
    0.00 :   40c137: call   423130 <operator delete(void*, unsigned long)>
         : 219    this->_M_impl._M_finish._M_node + 1,
         : 220    __new_nstart);
         : 221    _M_deallocate_map(this->_M_impl._M_map, this->_M_impl._M_map_size);
         :
         : 223    this->_M_impl._M_map = __new_map;
    0.00 :   40c13c: mov    %r12,(%rbx)
         : 225    this->_M_impl._M_map_size = __new_map_size;
    0.00 :   40c13f: mov    %r15,0x8(%rbx)
         : 227    _M_last = _M_first + difference_type(_S_buffer_size());
    0.00 :   40c143: mov    (%r14),%rax
         : 229    _M_first = *__new_node;
    0.00 :   40c146: movq   (%r14),%xmm0
         : 231    }
         :
         : 233    this->_M_impl._M_start._M_set_node(__new_nstart);
         : 234    this->_M_impl._M_finish._M_set_node(__new_nstart + __old_num_nodes - 1);
    0.00 :   40c14b: lea    (%r14,%r13,1),%r12
         : 236    _M_node = __new_node;
    0.00 :   40c14f: mov    %r14,0x28(%rbx)
    0.00 :   40c153: mov    %r12,0x48(%rbx)
         : 239    _M_last = _M_first + difference_type(_S_buffer_size());
    0.00 :   40c157: add    $0x200,%rax
         : 241    _M_first = *__new_node;
    0.00 :   40c15d: movq   %rax,%xmm2
    0.00 :   40c162: punpcklqdq %xmm2,%xmm0
    0.00 :   40c166: movups %xmm0,0x18(%rbx)
         : 245    _M_last = _M_first + difference_type(_S_buffer_size());
    0.00 :   40c16a: mov    (%r12),%rax
         : 247    _M_first = *__new_node;
    0.00 :   40c16e: movq   (%r12),%xmm0
         : 249    _M_last = _M_first + difference_type(_S_buffer_size());
    0.00 :   40c174: add    $0x200,%rax
         : 251    _M_first = *__new_node;
    0.00 :   40c17a: movq   %rax,%xmm3
    0.00 :   40c17f: punpcklqdq %xmm3,%xmm0
    0.00 :   40c183: movups %xmm0,0x38(%rbx)
    0.00 :   40c187: jmp    40c076 <int& std::deque<int, std::allocator<int> >::emplace_back<int>(int&&) [clone .isra.0]+0xb6>
    0.00 :   40c18c: nopl   0x0(%rax)
         : 257    - __new_num_nodes) / 2
    0.00 :   40c190: sub    %r14,%rdx
         : 259    std::copy(this->_M_impl._M_start._M_node,
    0.00 :   40c193: add    $0x8,%r12
         : 261    - __new_num_nodes) / 2
    0.00 :   40c197: shr    %rdx
         : 263    __new_nstart = this->_M_impl._M_map + (this->_M_impl._M_map_size
    0.00 :   40c19a: lea    (%rdi,%rdx,8),%r14
         : 265    const ptrdiff_t _Num = __last - __first;
    0.00 :   40c19e: mov    %r12,%rdx
    0.00 :   40c1a1: sub    %rsi,%rdx
         : 268    if (__new_nstart < this->_M_impl._M_start._M_node)
    0.00 :   40c1a4: cmp    %r14,%rsi
    0.00 :   40c1a7: jbe    40c1c0 <int& std::deque<int, std::allocator<int> >::emplace_back<int>(int&&) [clone .isra.0]+0x200>
         : 271    if (_Num)
    0.00 :   40c1a9: cmp    %r12,%rsi
    0.00 :   40c1ac: je     40c143 <int& std::deque<int, std::allocator<int> >::emplace_back<int>(int&&) [clone .isra.0]+0x183>
         : 274    __builtin_memmove(__result, __first, sizeof(_Tp) * _Num);
    0.00 :   40c1ae: mov    %r14,%rdi
    0.00 :   40c1b1: call   401040 <_init+0x40>
    0.00 :   40c1b6: jmp    40c143 <int& std::deque<int, std::allocator<int> >::emplace_back<int>(int&&) [clone .isra.0]+0x183>
    0.00 :   40c1b8: nopl   0x0(%rax,%rax,1)
         : 279    is_copy_assignable<_Tp>>;
         : 280    // trivial types can have deleted assignment
         : 281    static_assert( __assignable::type::value, "type is not assignable" );
         : 282    #endif
         : 283    const ptrdiff_t _Num = __last - __first;
         : 284    if (_Num)
    0.00 :   40c1c0: cmp    %r12,%rsi
    0.00 :   40c1c3: je     40c143 <int& std::deque<int, std::allocator<int> >::emplace_back<int>(int&&) [clone .isra.0]+0x183>
         : 287    __builtin_memmove(__result - _Num, __first, sizeof(_Tp) * _Num);
    0.00 :   40c1c9: lea    0x8(%r13),%rdi
    0.00 :   40c1cd: sub    %rdx,%rdi
    0.00 :   40c1d0: add    %r14,%rdi
    0.00 :   40c1d3: call   401040 <_init+0x40>
    0.00 :   40c1d8: jmp    40c143 <int& std::deque<int, std::allocator<int> >::emplace_back<int>(int&&) [clone .isra.0]+0x183>
         : 293    if (__n > (std::size_t(-1) / sizeof(_Tp)))
    0.00 :   40c1dd: cmp    %r8,%r15
    0.00 :   40c1e0: jbe    40c1e7 <int& std::deque<int, std::allocator<int> >::emplace_back<int>(int&&) [clone .isra.0]+0x227>
         : 296    std::__throw_bad_array_new_length();
    0.00 :   40c1e2: call   401a00 <std::__throw_bad_array_new_length()>
         : 298    std::__throw_bad_alloc();
    0.00 :   40c1e7: call   4019cb <std::__throw_bad_alloc()>
         : 300    __throw_length_error(
    0.00 :   40c1ec: lea    0xe3cb5(%rip),%rdi        # 4efea8 <Minisat::lit_Undef+0x170>
    0.00 :   40c1f3: call   401ba7 <std::__throw_length_error(char const*)>
 Percent |	Source code & Disassembly of minisat_HACK_999ED_CSSC_static for cycles:u (1 samples, percent: local period)
---------------------------------------------------------------------------------------------------------------------------
         :
         :
         :
         : 3      Disassembly of section .text:
         :
         : 5      0000000000494500 <__memcpy_avx_unaligned_erms>:
    0.00 :   494500: endbr64
    0.00 :   494504: mov    %rdi,%rax
    0.00 :   494507: cmp    $0x20,%rdx
    0.00 :   49450b: jb     494530 <__memcpy_avx_unaligned_erms+0x30>
    0.00 :   49450d: vmovdqu (%rsi),%ymm0
    0.00 :   494511: cmp    $0x40,%rdx
    0.00 :   494515: ja     4945c0 <__memcpy_avx_unaligned_erms+0xc0>
    0.00 :   49451b: vmovdqu -0x20(%rsi,%rdx,1),%ymm1
    0.00 :   494521: vmovdqu %ymm0,(%rdi)
    0.00 :   494525: vmovdqu %ymm1,-0x20(%rdi,%rdx,1)
    0.00 :   49452b: vzeroupper
    0.00 :   49452e: ret
    0.00 :   49452f: nop
    0.00 :   494530: cmp    $0x10,%edx
    0.00 :   494533: jae    494562 <__memcpy_avx_unaligned_erms+0x62>
    0.00 :   494535: cmp    $0x8,%edx
    0.00 :   494538: jae    494580 <__memcpy_avx_unaligned_erms+0x80>
    0.00 :   49453a: cmp    $0x4,%edx
    0.00 :   49453d: jae    494555 <__memcpy_avx_unaligned_erms+0x55>
    0.00 :   49453f: cmp    $0x1,%edx
    0.00 :   494542: jl     494554 <__memcpy_avx_unaligned_erms+0x54>
    0.00 :   494544: mov    (%rsi),%cl
    0.00 :   494546: je     494552 <__memcpy_avx_unaligned_erms+0x52>
    0.00 :   494548: movzwl -0x2(%rsi,%rdx,1),%esi
    0.00 :   49454d: mov    %si,-0x2(%rdi,%rdx,1)
    0.00 :   494552: mov    %cl,(%rdi)
    0.00 :   494554: ret
    0.00 :   494555: mov    -0x4(%rsi,%rdx,1),%ecx
    0.00 :   494559: mov    (%rsi),%esi
    0.00 :   49455b: mov    %ecx,-0x4(%rdi,%rdx,1)
    0.00 :   49455f: mov    %esi,(%rdi)
    0.00 :   494561: ret
    0.00 :   494562: vmovdqu (%rsi),%xmm0
    0.00 :   494566: vmovdqu -0x10(%rsi,%rdx,1),%xmm1
    0.00 :   49456c: vmovdqu %xmm0,(%rdi)
    0.00 :   494570: vmovdqu %xmm1,-0x10(%rdi,%rdx,1)
    0.00 :   494576: ret
    0.00 :   494577: nopw   0x0(%rax,%rax,1)
    0.00 :   494580: mov    -0x8(%rsi,%rdx,1),%rcx
    0.00 :   494585: mov    (%rsi),%rsi
    0.00 :   494588: mov    %rsi,(%rdi)
    0.00 :   49458b: mov    %rcx,-0x8(%rdi,%rdx,1)
  100.00 :   494590: ret
    0.00 :   494591: vmovdqu -0x20(%rsi,%rdx,1),%ymm2
    0.00 :   494597: vmovdqu -0x40(%rsi,%rdx,1),%ymm3
    0.00 :   49459d: vmovdqu %ymm0,(%rdi)
    0.00 :   4945a1: vmovdqu %ymm1,0x20(%rdi)
    0.00 :   4945a6: vmovdqu %ymm2,-0x20(%rdi,%rdx,1)
    0.00 :   4945ac: vmovdqu %ymm3,-0x40(%rdi,%rdx,1)
    0.00 :   4945b2: vzeroupper
    0.00 :   4945b5: ret
    0.00 :   4945b6: cs nopw 0x0(%rax,%rax,1)
    0.00 :   4945c0: cmp    0x9cb91(%rip),%rdx        # 531158 <__x86_rep_movsb_threshold>
    0.00 :   4945c7: ja     4947c0 <__memcpy_avx_unaligned_erms+0x2c0>
    0.00 :   4945cd: cmp    $0x100,%rdx
    0.00 :   4945d4: ja     494635 <__memcpy_avx_unaligned_erms+0x135>
    0.00 :   4945d6: vmovdqu 0x20(%rsi),%ymm1
    0.00 :   4945db: cmp    $0x80,%rdx
    0.00 :   4945e2: jbe    494591 <__memcpy_avx_unaligned_erms+0x91>
    0.00 :   4945e4: vmovdqu 0x40(%rsi),%ymm2
    0.00 :   4945e9: vmovdqu 0x60(%rsi),%ymm3
    0.00 :   4945ee: vmovdqu -0x20(%rsi,%rdx,1),%ymm4
    0.00 :   4945f4: vmovdqu -0x40(%rsi,%rdx,1),%ymm5
    0.00 :   4945fa: vmovdqu -0x60(%rsi,%rdx,1),%ymm6
    0.00 :   494600: vmovdqu -0x80(%rsi,%rdx,1),%ymm7
    0.00 :   494606: vmovdqu %ymm0,(%rdi)
    0.00 :   49460a: vmovdqu %ymm1,0x20(%rdi)
    0.00 :   49460f: vmovdqu %ymm2,0x40(%rdi)
    0.00 :   494614: vmovdqu %ymm3,0x60(%rdi)
    0.00 :   494619: vmovdqu %ymm4,-0x20(%rdi,%rdx,1)
    0.00 :   49461f: vmovdqu %ymm5,-0x40(%rdi,%rdx,1)
    0.00 :   494625: vmovdqu %ymm6,-0x60(%rdi,%rdx,1)
    0.00 :   49462b: vmovdqu %ymm7,-0x80(%rdi,%rdx,1)
    0.00 :   494631: vzeroupper
    0.00 :   494634: ret
    0.00 :   494635: mov    %rdi,%rcx
    0.00 :   494638: sub    %rsi,%rcx
    0.00 :   49463b: cmp    %rdx,%rcx
    0.00 :   49463e: jb     4946f0 <__memcpy_avx_unaligned_erms+0x1f0>
    0.00 :   494644: cmp    0x9f805(%rip),%rdx        # 533e50 <__x86_shared_non_temporal_threshold>
    0.00 :   49464b: ja     49482d <__memcpy_avx_unaligned_erms+0x32d>
    0.00 :   494651: lea    (%rcx,%rdx,1),%r8
    0.00 :   494655: xor    %rcx,%r8
    0.00 :   494658: shr    $0x3f,%r8
    0.00 :   49465c: and    $0xf00,%ecx
    0.00 :   494662: add    %r8d,%ecx
    0.00 :   494665: je     4946f5 <__memcpy_avx_unaligned_erms+0x1f5>
    0.00 :   49466b: vmovdqu -0x20(%rsi,%rdx,1),%ymm5
    0.00 :   494671: vmovdqu -0x40(%rsi,%rdx,1),%ymm6
    0.00 :   494677: mov    %rdi,%rcx
    0.00 :   49467a: or     $0x1f,%rdi
    0.00 :   49467e: vmovdqu -0x60(%rsi,%rdx,1),%ymm7
    0.00 :   494684: vmovdqu -0x80(%rsi,%rdx,1),%ymm8
    0.00 :   49468a: sub    %rcx,%rsi
    0.00 :   49468d: inc    %rdi
    0.00 :   494690: add    %rdi,%rsi
    0.00 :   494693: lea    -0x80(%rcx,%rdx,1),%rdx
    0.00 :   494698: nopl   0x0(%rax,%rax,1)
    0.00 :   4946a0: vmovdqu (%rsi),%ymm1
    0.00 :   4946a4: vmovdqu 0x20(%rsi),%ymm2
    0.00 :   4946a9: vmovdqu 0x40(%rsi),%ymm3
    0.00 :   4946ae: vmovdqu 0x60(%rsi),%ymm4
    0.00 :   4946b3: sub    $0xffffffffffffff80,%rsi
    0.00 :   4946b7: vmovdqa %ymm1,(%rdi)
    0.00 :   4946bb: vmovdqa %ymm2,0x20(%rdi)
    0.00 :   4946c0: vmovdqa %ymm3,0x40(%rdi)
    0.00 :   4946c5: vmovdqa %ymm4,0x60(%rdi)
    0.00 :   4946ca: sub    $0xffffffffffffff80,%rdi
    0.00 :   4946ce: cmp    %rdi,%rdx
    0.00 :   4946d1: ja     4946a0 <__memcpy_avx_unaligned_erms+0x1a0>
    0.00 :   4946d3: vmovdqu %ymm5,0x60(%rdx)
    0.00 :   4946d8: vmovdqu %ymm6,0x40(%rdx)
    0.00 :   4946dd: vmovdqu %ymm7,0x20(%rdx)
    0.00 :   4946e2: vmovdqu %ymm8,(%rdx)
    0.00 :   4946e6: vmovdqu %ymm0,(%rcx)
    0.00 :   4946ea: vzeroupper
    0.00 :   4946ed: ret
    0.00 :   4946ee: xchg   %ax,%ax
    0.00 :   4946f0: test   %rcx,%rcx
    0.00 :   4946f3: je     4946ea <__memcpy_avx_unaligned_erms+0x1ea>
    0.00 :   4946f5: vmovdqu 0x20(%rsi),%ymm5
    0.00 :   4946fa: vmovdqu 0x40(%rsi),%ymm6
    0.00 :   4946ff: lea    -0x81(%rdi,%rdx,1),%rcx
    0.00 :   494707: vmovdqu 0x60(%rsi),%ymm7
    0.00 :   49470c: vmovdqu -0x20(%rsi,%rdx,1),%ymm8
    0.00 :   494712: sub    %rdi,%rsi
    0.00 :   494715: and    $0xffffffffffffffe0,%rcx
    0.00 :   494719: add    %rcx,%rsi
    0.00 :   49471c: nopl   0x0(%rax)
    0.00 :   494720: vmovdqu 0x60(%rsi),%ymm1
    0.00 :   494725: vmovdqu 0x40(%rsi),%ymm2
    0.00 :   49472a: vmovdqu 0x20(%rsi),%ymm3
    0.00 :   49472f: vmovdqu (%rsi),%ymm4
    0.00 :   494733: add    $0xffffffffffffff80,%rsi
    0.00 :   494737: vmovdqa %ymm1,0x60(%rcx)
    0.00 :   49473c: vmovdqa %ymm2,0x40(%rcx)
    0.00 :   494741: vmovdqa %ymm3,0x20(%rcx)
    0.00 :   494746: vmovdqa %ymm4,(%rcx)
    0.00 :   49474a: add    $0xffffffffffffff80,%rcx
    0.00 :   49474e: cmp    %rcx,%rdi
    0.00 :   494751: jb     494720 <__memcpy_avx_unaligned_erms+0x220>
    0.00 :   494753: vmovdqu %ymm0,(%rdi)
    0.00 :   494757: vmovdqu %ymm5,0x20(%rdi)
    0.00 :   49475c: vmovdqu %ymm6,0x40(%rdi)
    0.00 :   494761: vmovdqu %ymm7,0x60(%rdi)
    0.00 :   494766: vmovdqu %ymm8,-0x20(%rdx,%rdi,1)
    0.00 :   49476c: vzeroupper
    0.00 :   49476f: ret
    0.00 :   494770: data16 cs nopw 0x0(%rax,%rax,1)
    0.00 :   49477b: nopl   0x0(%rax,%rax,1)
    0.00 :   494780: vmovdqu 0x20(%rsi),%ymm1
    0.00 :   494785: test   $0xe00,%ecx
    0.00 :   49478b: jne    4947f5 <__memcpy_avx_unaligned_erms+0x2f5>
    0.00 :   49478d: mov    %rcx,%r9
    0.00 :   494790: lea    -0x1(%rsi,%rdx,1),%rcx
    0.00 :   494795: or     $0x3f,%rsi
    0.00 :   494799: lea    0x1(%rsi,%r9,1),%rdi
    0.00 :   49479e: sub    %rsi,%rcx
    0.00 :   4947a1: inc    %rsi
    0.00 :   4947a4: rep movsb %ds:(%rsi),%es:(%rdi)
    0.00 :   4947a6: vmovdqu %ymm0,(%r8)
    0.00 :   4947ab: vmovdqu %ymm1,0x20(%r8)
    0.00 :   4947b1: vzeroupper
    0.00 :   4947b4: ret
    0.00 :   4947b5: data16 cs nopw 0x0(%rax,%rax,1)
    0.00 :   4947c0: mov    %rdi,%rcx
    0.00 :   4947c3: sub    %rsi,%rcx
    0.00 :   4947c6: cmp    %rdx,%rcx
    0.00 :   4947c9: jb     4946f0 <__memcpy_avx_unaligned_erms+0x1f0>
    0.00 :   4947cf: mov    %rdi,%r8
    0.00 :   4947d2: cmp    0x9f66f(%rip),%rdx        # 533e48 <__x86_rep_movsb_stop_threshold>
    0.00 :   4947d9: jae    494820 <__memcpy_avx_unaligned_erms+0x320>
    0.00 :   4947db: testl  $0x1,0x9f65b(%rip)        # 533e40 <__x86_string_control>
    0.00 :   4947e5: je     494780 <__memcpy_avx_unaligned_erms+0x280>
    0.00 :   4947e7: cmp    $0xffffffc0,%ecx
    0.00 :   4947ea: ja     49466b <__memcpy_avx_unaligned_erms+0x16b>
    0.00 :   4947f0: vmovdqu 0x20(%rsi),%ymm1
    0.00 :   4947f5: sub    %rdi,%rsi
    0.00 :   4947f8: add    $0x3f,%rdi
    0.00 :   4947fc: lea    (%r8,%rdx,1),%rcx
    0.00 :   494800: and    $0xffffffffffffffc0,%rdi
    0.00 :   494804: add    %rdi,%rsi
    0.00 :   494807: sub    %rdi,%rcx
    0.00 :   49480a: rep movsb %ds:(%rsi),%es:(%rdi)
    0.00 :   49480c: vmovdqu %ymm0,(%r8)
    0.00 :   494811: vmovdqu %ymm1,0x20(%r8)
    0.00 :   494817: vzeroupper
    0.00 :   49481a: ret
    0.00 :   49481b: nopl   0x0(%rax,%rax,1)
    0.00 :   494820: cmp    0x9c931(%rip),%rdx        # 531158 <__x86_rep_movsb_threshold>
    0.00 :   494827: jb     494651 <__memcpy_avx_unaligned_erms+0x151>
    0.00 :   49482d: neg    %rcx
    0.00 :   494830: cmp    %rcx,%rdx
    0.00 :   494833: ja     49466b <__memcpy_avx_unaligned_erms+0x16b>
    0.00 :   494839: vmovdqu 0x20(%rsi),%ymm1
    0.00 :   49483e: vmovdqu %ymm0,(%rdi)
    0.00 :   494842: vmovdqu %ymm1,0x20(%rdi)
    0.00 :   494847: mov    %rdi,%r8
    0.00 :   49484a: and    $0x3f,%r8
    0.00 :   49484e: sub    $0x40,%r8
    0.00 :   494852: sub    %r8,%rsi
    0.00 :   494855: sub    %r8,%rdi
    0.00 :   494858: add    %r8,%rdx
    0.00 :   49485b: not    %ecx
    0.00 :   49485d: test   $0xf00,%ecx
    0.00 :   494863: je     4949f0 <__memcpy_avx_unaligned_erms+0x4f0>
    0.00 :   494869: mov    %rdx,%r10
    0.00 :   49486c: shr    $0x4,%r10
    0.00 :   494870: cmp    0x9f5d9(%rip),%r10        # 533e50 <__x86_shared_non_temporal_threshold>
    0.00 :   494877: jae    4949f0 <__memcpy_avx_unaligned_erms+0x4f0>
    0.00 :   49487d: and    $0x1fff,%edx
    0.00 :   494883: shr    $0x9,%r10
    0.00 :   494887: nopw   0x0(%rax,%rax,1)
    0.00 :   494890: mov    $0x20,%ecx
    0.00 :   494895: prefetcht0 0x80(%rsi)
    0.00 :   49489c: prefetcht0 0xc0(%rsi)
    0.00 :   4948a3: prefetcht0 0x100(%rsi)
    0.00 :   4948aa: prefetcht0 0x140(%rsi)
    0.00 :   4948b1: prefetcht0 0x1080(%rsi)
    0.00 :   4948b8: prefetcht0 0x10c0(%rsi)
    0.00 :   4948bf: prefetcht0 0x1100(%rsi)
    0.00 :   4948c6: prefetcht0 0x1140(%rsi)
    0.00 :   4948cd: vmovdqu (%rsi),%ymm0
    0.00 :   4948d1: vmovdqu 0x20(%rsi),%ymm1
    0.00 :   4948d6: vmovdqu 0x40(%rsi),%ymm2
    0.00 :   4948db: vmovdqu 0x60(%rsi),%ymm3
    0.00 :   4948e0: vmovdqu 0x1000(%rsi),%ymm4
    0.00 :   4948e8: vmovdqu 0x1020(%rsi),%ymm5
    0.00 :   4948f0: vmovdqu 0x1040(%rsi),%ymm6
    0.00 :   4948f8: vmovdqu 0x1060(%rsi),%ymm7
    0.00 :   494900: sub    $0xffffffffffffff80,%rsi
    0.00 :   494904: vmovntdq %ymm0,(%rdi)
    0.00 :   494908: vmovntdq %ymm1,0x20(%rdi)
    0.00 :   49490d: vmovntdq %ymm2,0x40(%rdi)
    0.00 :   494912: vmovntdq %ymm3,0x60(%rdi)
    0.00 :   494917: vmovntdq %ymm4,0x1000(%rdi)
    0.00 :   49491f: vmovntdq %ymm5,0x1020(%rdi)
    0.00 :   494927: vmovntdq %ymm6,0x1040(%rdi)
    0.00 :   49492f: vmovntdq %ymm7,0x1060(%rdi)
    0.00 :   494937: sub    $0xffffffffffffff80,%rdi
    0.00 :   49493b: dec    %ecx
    0.00 :   49493d: jne    494895 <__memcpy_avx_unaligned_erms+0x395>
    0.00 :   494943: add    $0x1000,%rdi
    0.00 :   49494a: add    $0x1000,%rsi
    0.00 :   494951: dec    %r10
    0.00 :   494954: jne    494890 <__memcpy_avx_unaligned_erms+0x390>
    0.00 :   49495a: sfence
    0.00 :   49495d: cmp    $0x80,%edx
    0.00 :   494963: jbe    4949ba <__memcpy_avx_unaligned_erms+0x4ba>
    0.00 :   494965: prefetcht0 0x80(%rsi)
    0.00 :   49496c: prefetcht0 0xc0(%rsi)
    0.00 :   494973: prefetcht0 0x80(%rdi)
    0.00 :   49497a: prefetcht0 0xc0(%rdi)
    0.00 :   494981: vmovdqu (%rsi),%ymm0
    0.00 :   494985: vmovdqu 0x20(%rsi),%ymm1
    0.00 :   49498a: vmovdqu 0x40(%rsi),%ymm2
    0.00 :   49498f: vmovdqu 0x60(%rsi),%ymm3
    0.00 :   494994: sub    $0xffffffffffffff80,%rsi
    0.00 :   494998: add    $0xffffff80,%edx
    0.00 :   49499b: vmovdqa %ymm0,(%rdi)
    0.00 :   49499f: vmovdqa %ymm1,0x20(%rdi)
    0.00 :   4949a4: vmovdqa %ymm2,0x40(%rdi)
    0.00 :   4949a9: vmovdqa %ymm3,0x60(%rdi)
    0.00 :   4949ae: sub    $0xffffffffffffff80,%rdi
    0.00 :   4949b2: cmp    $0x80,%edx
    0.00 :   4949b8: ja     494965 <__memcpy_avx_unaligned_erms+0x465>
    0.00 :   4949ba: vmovdqu -0x80(%rsi,%rdx,1),%ymm0
    0.00 :   4949c0: vmovdqu -0x60(%rsi,%rdx,1),%ymm1
    0.00 :   4949c6: vmovdqu -0x40(%rsi,%rdx,1),%ymm2
    0.00 :   4949cc: vmovdqu -0x20(%rsi,%rdx,1),%ymm3
    0.00 :   4949d2: vmovdqu %ymm0,-0x80(%rdi,%rdx,1)
    0.00 :   4949d8: vmovdqu %ymm1,-0x60(%rdi,%rdx,1)
    0.00 :   4949de: vmovdqu %ymm2,-0x40(%rdi,%rdx,1)
    0.00 :   4949e4: vmovdqu %ymm3,-0x20(%rdi,%rdx,1)
    0.00 :   4949ea: vzeroupper
    0.00 :   4949ed: ret
    0.00 :   4949ee: xchg   %ax,%ax
    0.00 :   4949f0: mov    %rdx,%r10
    0.00 :   4949f3: and    $0x3fff,%edx
    0.00 :   4949f9: shr    $0xe,%r10
    0.00 :   4949fd: nopl   (%rax)
    0.00 :   494a00: mov    $0x20,%ecx
    0.00 :   494a05: prefetcht0 0x80(%rsi)
    0.00 :   494a0c: prefetcht0 0xc0(%rsi)
    0.00 :   494a13: prefetcht0 0x1080(%rsi)
    0.00 :   494a1a: prefetcht0 0x10c0(%rsi)
    0.00 :   494a21: prefetcht0 0x2080(%rsi)
    0.00 :   494a28: prefetcht0 0x20c0(%rsi)
    0.00 :   494a2f: prefetcht0 0x3080(%rsi)
    0.00 :   494a36: prefetcht0 0x30c0(%rsi)
    0.00 :   494a3d: vmovdqu (%rsi),%ymm0
    0.00 :   494a41: vmovdqu 0x20(%rsi),%ymm1
    0.00 :   494a46: vmovdqu 0x40(%rsi),%ymm2
    0.00 :   494a4b: vmovdqu 0x60(%rsi),%ymm3
    0.00 :   494a50: vmovdqu 0x1000(%rsi),%ymm4
    0.00 :   494a58: vmovdqu 0x1020(%rsi),%ymm5
    0.00 :   494a60: vmovdqu 0x1040(%rsi),%ymm6
    0.00 :   494a68: vmovdqu 0x1060(%rsi),%ymm7
    0.00 :   494a70: vmovdqu 0x2000(%rsi),%ymm8
    0.00 :   494a78: vmovdqu 0x2020(%rsi),%ymm9
    0.00 :   494a80: vmovdqu 0x2040(%rsi),%ymm10
    0.00 :   494a88: vmovdqu 0x2060(%rsi),%ymm11
    0.00 :   494a90: vmovdqu 0x3000(%rsi),%ymm12
    0.00 :   494a98: vmovdqu 0x3020(%rsi),%ymm13
    0.00 :   494aa0: vmovdqu 0x3040(%rsi),%ymm14
    0.00 :   494aa8: vmovdqu 0x3060(%rsi),%ymm15
    0.00 :   494ab0: sub    $0xffffffffffffff80,%rsi
    0.00 :   494ab4: vmovntdq %ymm0,(%rdi)
    0.00 :   494ab8: vmovntdq %ymm1,0x20(%rdi)
    0.00 :   494abd: vmovntdq %ymm2,0x40(%rdi)
    0.00 :   494ac2: vmovntdq %ymm3,0x60(%rdi)
    0.00 :   494ac7: vmovntdq %ymm4,0x1000(%rdi)
    0.00 :   494acf: vmovntdq %ymm5,0x1020(%rdi)
    0.00 :   494ad7: vmovntdq %ymm6,0x1040(%rdi)
    0.00 :   494adf: vmovntdq %ymm7,0x1060(%rdi)
    0.00 :   494ae7: vmovntdq %ymm8,0x2000(%rdi)
    0.00 :   494aef: vmovntdq %ymm9,0x2020(%rdi)
    0.00 :   494af7: vmovntdq %ymm10,0x2040(%rdi)
    0.00 :   494aff: vmovntdq %ymm11,0x2060(%rdi)
    0.00 :   494b07: vmovntdq %ymm12,0x3000(%rdi)
    0.00 :   494b0f: vmovntdq %ymm13,0x3020(%rdi)
    0.00 :   494b17: vmovntdq %ymm14,0x3040(%rdi)
    0.00 :   494b1f: vmovntdq %ymm15,0x3060(%rdi)
    0.00 :   494b27: sub    $0xffffffffffffff80,%rdi
    0.00 :   494b2b: dec    %ecx
    0.00 :   494b2d: jne    494a05 <__memcpy_avx_unaligned_erms+0x505>
    0.00 :   494b33: add    $0x3000,%rdi
    0.00 :   494b3a: add    $0x3000,%rsi
    0.00 :   494b41: dec    %r10
    0.00 :   494b44: jne    494a00 <__memcpy_avx_unaligned_erms+0x500>
    0.00 :   494b4a: sfence
    0.00 :   494b4d: cmp    $0x80,%edx
    0.00 :   494b53: jbe    494baa <__memcpy_avx_unaligned_erms+0x6aa>
    0.00 :   494b55: prefetcht0 0x80(%rsi)
    0.00 :   494b5c: prefetcht0 0xc0(%rsi)
    0.00 :   494b63: prefetcht0 0x80(%rdi)
    0.00 :   494b6a: prefetcht0 0xc0(%rdi)
    0.00 :   494b71: vmovdqu (%rsi),%ymm0
    0.00 :   494b75: vmovdqu 0x20(%rsi),%ymm1
    0.00 :   494b7a: vmovdqu 0x40(%rsi),%ymm2
    0.00 :   494b7f: vmovdqu 0x60(%rsi),%ymm3
    0.00 :   494b84: sub    $0xffffffffffffff80,%rsi
    0.00 :   494b88: add    $0xffffff80,%edx
    0.00 :   494b8b: vmovdqa %ymm0,(%rdi)
    0.00 :   494b8f: vmovdqa %ymm1,0x20(%rdi)
    0.00 :   494b94: vmovdqa %ymm2,0x40(%rdi)
    0.00 :   494b99: vmovdqa %ymm3,0x60(%rdi)
    0.00 :   494b9e: sub    $0xffffffffffffff80,%rdi
    0.00 :   494ba2: cmp    $0x80,%edx
    0.00 :   494ba8: ja     494b55 <__memcpy_avx_unaligned_erms+0x655>
    0.00 :   494baa: vmovdqu -0x80(%rsi,%rdx,1),%ymm0
    0.00 :   494bb0: vmovdqu -0x60(%rsi,%rdx,1),%ymm1
    0.00 :   494bb6: vmovdqu -0x40(%rsi,%rdx,1),%ymm2
    0.00 :   494bbc: vmovdqu -0x20(%rsi,%rdx,1),%ymm3
    0.00 :   494bc2: vmovdqu %ymm0,-0x80(%rdi,%rdx,1)
    0.00 :   494bc8: vmovdqu %ymm1,-0x60(%rdi,%rdx,1)
    0.00 :   494bce: vmovdqu %ymm2,-0x40(%rdi,%rdx,1)
    0.00 :   494bd4: vmovdqu %ymm3,-0x20(%rdi,%rdx,1)
    0.00 :   494bda: vzeroupper
    0.00 :   494bdd: ret
 Percent |	Source code & Disassembly of minisat_HACK_999ED_CSSC_static for cycles:u (1 samples, percent: local period)
---------------------------------------------------------------------------------------------------------------------------
         :
         :
         :
         : 3      Disassembly of section .text:
         :
         : 5      0000000000408e00 <Minisat::SimpSolver::eliminateVar(int)>:
         : 6      }
         :
         :
         :
         : 10     bool SimpSolver::eliminateVar(Var v)
         : 11     {
    0.00 :   408e00: endbr64
    0.00 :   408e04: push   %r15
    0.00 :   408e06: mov    %rdi,%r15
    0.00 :   408e09: push   %r14
    0.00 :   408e0b: push   %r13
    0.00 :   408e0d: push   %r12
    0.00 :   408e0f: push   %rbp
    0.00 :   408e10: push   %rbx
    0.00 :   408e11: mov    %esi,%ebx
    0.00 :   408e13: sub    $0x98,%rsp
         : 22     const T& last  (void) const        { return data[sz-1]; }
         : 23     T&       last  (void)              { return data[sz-1]; }
         :
         : 25     // Vector interface:
         : 26     const T& operator [] (int index) const { return data[index]; }
         : 27     T&       operator [] (int index)       { return data[index]; }
    0.00 :   408e1a: mov    0x3f8(%rdi),%r8
    0.00 :   408e21: mov    %fs:0x28,%rax
    0.00 :   408e2a: mov    %rax,0x88(%rsp)
    0.00 :   408e32: xor    %eax,%eax
    0.00 :   408e34: movslq %esi,%rax
    0.00 :   408e37: add    %rax,%r8
    0.00 :   408e3a: mov    %rax,0x40(%rsp)
    0.00 :   408e3f: shl    $0x4,%rax
         : 36     OccLists(const Deleted& d) : deleted(d) {}
         :
         : 38     void  init      (const Idx& idx){ occs.growTo(toInt(idx)+1); dirty.growTo(toInt(idx)+1, 0); }
         : 39     // Vec&  operator[](const Idx& idx){ return occs[toInt(idx)]; }
         : 40     Vec&  operator[](const Idx& idx){ return occs[toInt(idx)]; }
         : 41     Vec&  lookup    (const Idx& idx){ if (dirty[toInt(idx)]) clean(idx); return occs[toInt(idx)]; }
    0.00 :   408e43: cmpb   $0x0,(%r8)
    0.00 :   408e47: mov    %rax,0x48(%rsp)
    0.00 :   408e4c: jne    409144 <Minisat::SimpSolver::eliminateVar(int)+0x344>
         : 45     vec()                       : data(NULL) , sz(0)   , cap(0)    { }
    0.00 :   408e52: movq   $0x0,0x60(%rsp)
         : 47     T&       operator [] (int index)       { return data[index]; }
    0.00 :   408e5b: mov    0x48(%rsp),%rax
         : 49     vec()                       : data(NULL) , sz(0)   , cap(0)    { }
    0.00 :   408e60: movq   $0x0,0x68(%rsp)
         : 51     T&       operator [] (int index)       { return data[index]; }
    0.00 :   408e69: add    0x3e8(%r15),%rax
         :
         : 54     // Split the occurrences into positive and negative:
         : 55     //
         : 56     const vec<CRef>& cls = occurs.lookup(v);
         : 57     vec<CRef>        pos, neg;
         : 58     for (int i = 0; i < cls.size(); i++)
    0.00 :   408e70: mov    0x8(%rax),%r8d
    0.00 :   408e74: mov    %rax,0x38(%rsp)
         : 61     vec()                       : data(NULL) , sz(0)   , cap(0)    { }
    0.00 :   408e79: movq   $0x0,0x70(%rsp)
    0.00 :   408e82: movq   $0x0,0x78(%rsp)
    0.00 :   408e8b: test   %r8d,%r8d
    0.00 :   408e8e: jle    4091bc <Minisat::SimpSolver::eliminateVar(int)+0x3bc>
         : 66     (find(ca[cls[i]], mkLit(v)) ? pos : neg).push(cls[i]);
    0.00 :   408e94: lea    0x70(%rsp),%rax
         : 68     inline  Lit  mkLit     (Var var, bool sign=false) { Lit p; p.x = var + var + (int)sign; return p; }
    0.00 :   408e99: lea    (%rbx,%rbx,1),%ebp
    0.00 :   408e9c: xor    %r13d,%r13d
    0.00 :   408e9f: mov    %rax,(%rsp)
         : 72     const T& operator [] (int index) const { return data[index]; }
    0.00 :   408ea3: mov    0x38(%rsp),%rax
    0.00 :   408ea8: mov    (%rax),%rax
    0.00 :   408eab: lea    (%rax,%r13,4),%r14
         :
         : 77     Ref      alloc     (int size);
         : 78     void     free      (int size)    { wasted_ += size; }
         :
         : 80     // Deref, Load Effective Address (LEA), Inverse of LEA (AEL):
         : 81     T&       operator[](Ref r)       { assert(r >= 0 && r < sz); return memory[r]; }
    0.00 :   408eaf: mov    0x308(%r15),%rax
    0.00 :   408eb6: mov    (%r14),%edx
  100.00 :   408eb9: lea    (%rax,%rdx,4),%rcx
    0.00 :   408ebd: mov    %rdx,%rsi
         :
         : 87     template<class V, class T>
         : 88     static inline bool find(V& ts, const T& t)
         : 89     {
         : 90     int j = 0;
         : 91     for (; j < ts.size() && ts[j] != t; j++);
    0.00 :   408ec0: mov    (%rcx),%edx
    0.00 :   408ec2: shr    $0x5,%edx
    0.00 :   408ec5: je     40910e <Minisat::SimpSolver::eliminateVar(int)+0x30e>
    0.00 :   408ecb: sub    $0x1,%edx
    0.00 :   408ece: lea    0x4(%rcx),%rax
    0.00 :   408ed2: lea    0x8(%rcx,%rdx,4),%rdx
    0.00 :   408ed7: jmp    408eed <Minisat::SimpSolver::eliminateVar(int)+0xed>
    0.00 :   408ed9: nopl   0x0(%rax)
    0.00 :   408ee0: add    $0x4,%rax
    0.00 :   408ee4: cmp    %rax,%rdx
    0.00 :   408ee7: je     40910e <Minisat::SimpSolver::eliminateVar(int)+0x30e>
    0.00 :   408eed: cmp    %ebp,(%rax)
    0.00 :   408eef: jne    408ee0 <Minisat::SimpSolver::eliminateVar(int)+0xe0>
    0.00 :   408ef1: lea    0x60(%rsp),%r12
         : 106    void     push  (const T& elem)     { if (sz == cap) capacity(sz+1); data[sz++] = elem; }
    0.00 :   408ef6: movslq 0x8(%r12),%rax
    0.00 :   408efb: cmp    0xc(%r12),%eax
    0.00 :   408f00: je     409122 <Minisat::SimpSolver::eliminateVar(int)+0x322>
    0.00 :   408f06: mov    (%r12),%rdx
    0.00 :   408f0a: lea    0x1(%rax),%ecx
         : 112    for (int i = 0; i < cls.size(); i++)
    0.00 :   408f0d: add    $0x1,%r13
    0.00 :   408f11: mov    %ecx,0x8(%r12)
    0.00 :   408f16: mov    %esi,(%rdx,%rax,4)
         : 116    int      size     (void) const     { return sz; }
    0.00 :   408f19: mov    0x38(%rsp),%rax
    0.00 :   408f1e: mov    0x8(%rax),%eax
    0.00 :   408f21: mov    %eax,0x34(%rsp)
    0.00 :   408f25: cmp    %r13d,%eax
    0.00 :   408f28: jg     408ea3 <Minisat::SimpSolver::eliminateVar(int)+0xa3>
         : 122    T&       operator [] (int index)       { return data[index]; }
    0.00 :   408f2e: mov    0x60(%rsp),%rdi
         : 124    int      size     (void) const     { return sz; }
    0.00 :   408f33: movslq 0x68(%rsp),%rax
         : 126    T&       operator [] (int index)       { return data[index]; }
    0.00 :   408f38: mov    %rdi,0x10(%rsp)
    0.00 :   408f3d: mov    0x70(%rsp),%rdi
         : 129    int      size     (void) const     { return sz; }
    0.00 :   408f42: mov    %eax,0x50(%rsp)
         : 131    T&       operator [] (int index)       { return data[index]; }
    0.00 :   408f46: mov    %rdi,0x8(%rsp)
         : 133    // clause must exceed the limit on the maximal clause size (if it is set):
         : 134    //
         : 135    int cnt         = 0;
         : 136    int clause_size = 0;
         :
         : 138    for (int i = 0; i < pos.size(); i++)
    0.00 :   408f4b: test   %eax,%eax
    0.00 :   408f4d: jle    4091d6 <Minisat::SimpSolver::eliminateVar(int)+0x3d6>
         : 141    int      size     (void) const     { return sz; }
    0.00 :   408f53: mov    0x78(%rsp),%edi
    0.00 :   408f57: mov    %rax,0x58(%rsp)
    0.00 :   408f5c: movq   $0x0,0x18(%rsp)
    0.00 :   408f65: movslq %edi,%rax
    0.00 :   408f68: mov    %edi,0x54(%rsp)
         : 147    int cnt         = 0;
    0.00 :   408f6c: movl   $0x0,(%rsp)
    0.00 :   408f73: mov    %rax,0x28(%rsp)
         : 150    for (int j = 0; j < neg.size(); j++)
    0.00 :   408f78: mov    0x54(%rsp),%edi
    0.00 :   408f7c: test   %edi,%edi
    0.00 :   408f7e: jle    40905b <Minisat::SimpSolver::eliminateVar(int)+0x25b>
         : 154    merges++;
    0.00 :   408f84: mov    0x3b4(%r15),%eax
    0.00 :   408f8b: mov    0x308(%r15),%r14
    0.00 :   408f92: xor    %r13d,%r13d
    0.00 :   408f95: add    $0x1,%eax
    0.00 :   408f98: mov    %eax,0x20(%rsp)
    0.00 :   408f9c: nopl   0x0(%rax)
    0.00 :   408fa0: mov    0x8(%rsp),%rax
    0.00 :   408fa5: mov    0x18(%rsp),%rdi
    0.00 :   408faa: mov    (%rax,%r13,4),%eax
    0.00 :   408fae: lea    (%r14,%rax,4),%rdx
    0.00 :   408fb2: mov    0x10(%rsp),%rax
    0.00 :   408fb7: mov    (%rax,%rdi,4),%eax
    0.00 :   408fba: lea    (%r14,%rax,4),%r11
    0.00 :   408fbe: mov    0x20(%rsp),%eax
         : 169    int          size        ()      const   { return header.size; }
    0.00 :   408fc2: mov    (%r11),%ecx
    0.00 :   408fc5: add    %r13d,%eax
    0.00 :   408fc8: mov    %eax,0x3b4(%r15)
    0.00 :   408fcf: mov    (%rdx),%eax
    0.00 :   408fd1: shr    $0x5,%ecx
    0.00 :   408fd4: mov    %ecx,%ebp
    0.00 :   408fd6: shr    $0x5,%eax
         : 177    const Clause& ps  =  ps_smallest ? _qs : _ps;
    0.00 :   408fd9: cmp    %eax,%ecx
    0.00 :   408fdb: jae    408fea <Minisat::SimpSolver::eliminateVar(int)+0x1ea>
    0.00 :   408fdd: mov    %eax,%ebp
    0.00 :   408fdf: mov    %ecx,%eax
    0.00 :   408fe1: mov    %rdx,%rcx
    0.00 :   408fe4: mov    %r11,%rdx
    0.00 :   408fe7: mov    %rcx,%r11
         : 185    size = ps.size()-1;
    0.00 :   408fea: lea    -0x1(%rbp),%r12d
         : 187    for (int i = 0; i < qs.size(); i++){
    0.00 :   408fee: test   %eax,%eax
    0.00 :   408ff0: je     40908d <Minisat::SimpSolver::eliminateVar(int)+0x28d>
    0.00 :   408ff6: sub    $0x1,%eax
    0.00 :   408ff9: lea    0x4(%rdx),%rdi
    0.00 :   408ffd: lea    0x8(%rdx,%rax,4),%r10
    0.00 :   409002: mov    %r12d,%eax
    0.00 :   409005: lea    0x8(%r11,%rax,4),%r8
    0.00 :   40900a: jmp    409019 <Minisat::SimpSolver::eliminateVar(int)+0x219>
    0.00 :   40900c: nopl   0x0(%rax)
    0.00 :   409010: add    $0x4,%rdi
    0.00 :   409014: cmp    %r10,%rdi
    0.00 :   409017: je     40908d <Minisat::SimpSolver::eliminateVar(int)+0x28d>
         : 200    if (var(__qs[i]) != v){
    0.00 :   409019: mov    (%rdi),%r9d
         : 202    inline  int  var       (Lit p)              { return p.x >> 1; }
    0.00 :   40901c: mov    %r9d,%esi
    0.00 :   40901f: sar    %esi
    0.00 :   409021: cmp    %ebx,%esi
    0.00 :   409023: je     409010 <Minisat::SimpSolver::eliminateVar(int)+0x210>
         : 207    for (int j = 0; j < ps.size(); j++)
    0.00 :   409025: test   %ebp,%ebp
    0.00 :   409027: je     409080 <Minisat::SimpSolver::eliminateVar(int)+0x280>
    0.00 :   409029: lea    0x4(%r11),%rax
    0.00 :   40902d: jmp    409039 <Minisat::SimpSolver::eliminateVar(int)+0x239>
    0.00 :   40902f: nop
    0.00 :   409030: add    $0x4,%rax
    0.00 :   409034: cmp    %rax,%r8
    0.00 :   409037: je     409080 <Minisat::SimpSolver::eliminateVar(int)+0x280>
         : 216    if (var(__ps[j]) == var(__qs[i]))
    0.00 :   409039: mov    (%rax),%edx
    0.00 :   40903b: mov    %edx,%ecx
    0.00 :   40903d: sar    %ecx
    0.00 :   40903f: cmp    %ecx,%esi
    0.00 :   409041: jne    409030 <Minisat::SimpSolver::eliminateVar(int)+0x230>
         : 222    inline  Lit  operator ~(Lit p)              { Lit q; q.x = p.x ^ 1; return q; }
    0.00 :   409043: xor    $0x1,%r9d
         : 224    if (__ps[j] == ~__qs[i])
    0.00 :   409047: cmp    %r9d,%edx
    0.00 :   40904a: jne    409010 <Minisat::SimpSolver::eliminateVar(int)+0x210>
         : 227    for (int j = 0; j < neg.size(); j++)
    0.00 :   40904c: add    $0x1,%r13
    0.00 :   409050: cmp    %r13,0x28(%rsp)
    0.00 :   409055: jne    408fa0 <Minisat::SimpSolver::eliminateVar(int)+0x1a0>
         : 231    for (int i = 0; i < pos.size(); i++)
    0.00 :   40905b: addq   $0x1,0x18(%rsp)
    0.00 :   409061: mov    0x18(%rsp),%rax
    0.00 :   409066: cmp    %rax,0x58(%rsp)
    0.00 :   40906b: jne    408f78 <Minisat::SimpSolver::eliminateVar(int)+0x178>
    0.00 :   409071: jmp    4091d6 <Minisat::SimpSolver::eliminateVar(int)+0x3d6>
    0.00 :   409076: cs nopw 0x0(%rax,%rax,1)
         : 238    for (int i = 0; i < qs.size(); i++){
    0.00 :   409080: add    $0x4,%rdi
         : 240    size++;
    0.00 :   409084: add    $0x1,%r12d
         : 242    for (int i = 0; i < qs.size(); i++){
    0.00 :   409088: cmp    %r10,%rdi
    0.00 :   40908b: jne    409019 <Minisat::SimpSolver::eliminateVar(int)+0x219>
         : 245    if (merge(ca[pos[i]], ca[neg[j]], v, clause_size) &&
    0.00 :   40908d: addl   $0x1,(%rsp)
    0.00 :   409091: mov    (%rsp),%edi
         : 248    (++cnt > cls.size() + grow || (clause_lim != -1 && clause_size > clause_lim)))
    0.00 :   409094: mov    0x34(%rsp),%eax
    0.00 :   409098: add    0x39c(%r15),%eax
         : 251    if (merge(ca[pos[i]], ca[neg[j]], v, clause_size) &&
    0.00 :   40909f: cmp    %edi,%eax
    0.00 :   4090a1: jl     40913a <Minisat::SimpSolver::eliminateVar(int)+0x33a>
         : 254    (++cnt > cls.size() + grow || (clause_lim != -1 && clause_size > clause_lim)))
    0.00 :   4090a7: mov    0x3a0(%r15),%edx
    0.00 :   4090ae: cmp    %r12d,%edx
    0.00 :   4090b1: setl   %al
    0.00 :   4090b4: cmp    $0xffffffff,%edx
    0.00 :   4090b7: setne  %dl
    0.00 :   4090ba: and    %dl,%al
    0.00 :   4090bc: je     40904c <Minisat::SimpSolver::eliminateVar(int)+0x24c>
         : 262    template<class T>
         : 263    void vec<T>::clear(bool dealloc) {
         : 264    if (data != NULL){
         : 265    for (int i = 0; i < sz; i++) data[i].~T();
         : 266    sz = 0;
         : 267    if (dealloc) free(data), data = NULL, cap = 0; } }
    0.00 :   4090be: mov    0x8(%rsp),%rdi
    0.00 :   4090c3: mov    %al,(%rsp)
    0.00 :   4090c6: call   4657f0 <__free>
    0.00 :   4090cb: movzbl (%rsp),%eax
         : 272    if (data != NULL){
    0.00 :   4090cf: mov    0x10(%rsp),%rdi
    0.00 :   4090d4: test   %rdi,%rdi
    0.00 :   4090d7: je     4090e5 <Minisat::SimpSolver::eliminateVar(int)+0x2e5>
    0.00 :   4090d9: mov    %al,(%rsp)
         : 277    if (dealloc) free(data), data = NULL, cap = 0; } }
    0.00 :   4090dc: call   4657f0 <__free>
    0.00 :   4090e1: movzbl (%rsp),%eax
         : 280    // Free watchers lists for this variable, if possible:
         : 281    if (watches[ mkLit(v)].size() == 0) watches[ mkLit(v)].clear(true);
         : 282    if (watches[~mkLit(v)].size() == 0) watches[~mkLit(v)].clear(true);
         :
         : 284    return backwardSubsumptionCheck();
         : 285    }
    0.00 :   4090e5: mov    0x88(%rsp),%rdx
    0.00 :   4090ed: sub    %fs:0x28,%rdx
    0.00 :   4090f6: jne    40950e <Minisat::SimpSolver::eliminateVar(int)+0x70e>
    0.00 :   4090fc: add    $0x98,%rsp
    0.00 :   409103: pop    %rbx
    0.00 :   409104: pop    %rbp
    0.00 :   409105: pop    %r12
    0.00 :   409107: pop    %r13
    0.00 :   409109: pop    %r14
    0.00 :   40910b: pop    %r15
    0.00 :   40910d: ret
         : 297    (find(ca[cls[i]], mkLit(v)) ? pos : neg).push(cls[i]);
    0.00 :   40910e: mov    (%rsp),%r12
         : 299    void     push  (const T& elem)     { if (sz == cap) capacity(sz+1); data[sz++] = elem; }
    0.00 :   409112: movslq 0x8(%r12),%rax
    0.00 :   409117: cmp    0xc(%r12),%eax
    0.00 :   40911c: jne    408f06 <Minisat::SimpSolver::eliminateVar(int)+0x106>
    0.00 :   409122: lea    0x1(%rax),%esi
    0.00 :   409125: mov    %r12,%rdi
    0.00 :   409128: call   40af10 <Minisat::vec<unsigned int>::capacity(int)>
    0.00 :   40912d: mov    (%r14),%esi
    0.00 :   409130: movslq 0x8(%r12),%rax
    0.00 :   409135: jmp    408f06 <Minisat::SimpSolver::eliminateVar(int)+0x106>
    0.00 :   40913a: mov    $0x1,%eax
    0.00 :   40913f: jmp    4090be <Minisat::SimpSolver::eliminateVar(int)+0x2be>
         : 311    T&       operator [] (int index)       { return data[index]; }
    0.00 :   409144: mov    0x3e8(%rdi),%rdi
    0.00 :   40914b: add    %rax,%rdi
         : 314    int      size     (void) const     { return sz; }
    0.00 :   40914e: mov    0x8(%rdi),%edx
         : 316    template<class Idx, class Vec, class Deleted>
         : 317    void OccLists<Idx,Vec,Deleted>::clean(const Idx& idx)
         : 318    {
         : 319    Vec& vec = occs[toInt(idx)];
         : 320    int  i, j;
         : 321    for (i = j = 0; i < vec.size(); i++)
    0.00 :   409151: test   %edx,%edx
    0.00 :   409153: jle    4091ae <Minisat::SimpSolver::eliminateVar(int)+0x3ae>
         : 324    const T& operator[](Ref r) const { assert(r >= 0 && r < sz); return memory[r]; }
    0.00 :   409155: mov    0x418(%r15),%rax
         : 326    T&       operator [] (int index)       { return data[index]; }
    0.00 :   40915c: mov    (%rdi),%r10
    0.00 :   40915f: xor    %ecx,%ecx
    0.00 :   409161: mov    (%rax),%r11
    0.00 :   409164: xor    %eax,%eax
         : 331    };
         :
         : 333    struct ClauseDeleted {
         : 334    const ClauseAllocator& ca;
         : 335    explicit ClauseDeleted(const ClauseAllocator& _ca) : ca(_ca) {}
         : 336    bool operator()(const CRef& cr) const { return ca[cr].mark() == 1; } };
    0.00 :   409166: mov    (%r10,%rax,4),%esi
    0.00 :   40916a: mov    %rsi,%rbp
         : 339    uint32_t     mark        ()      const   { return header.mark; }
    0.00 :   40916d: movzbl (%r11,%rsi,4),%esi
    0.00 :   409172: and    $0x3,%esi
         : 342    if (!deleted(vec[i]))
    0.00 :   409175: cmp    $0x1,%sil
    0.00 :   409179: je     409196 <Minisat::SimpSolver::eliminateVar(int)+0x396>
         : 345    vec[j++] = vec[i];
    0.00 :   40917b: mov    %ebp,(%r10,%rcx,4)
         : 347    int      size     (void) const     { return sz; }
    0.00 :   40917f: mov    0x8(%rdi),%edx
    0.00 :   409182: lea    0x1(%rax),%esi
         : 350    for (i = j = 0; i < vec.size(); i++)
    0.00 :   409185: add    $0x1,%rax
         : 352    vec[j++] = vec[i];
    0.00 :   409189: lea    0x1(%rcx),%r9d
         : 354    for (i = j = 0; i < vec.size(); i++)
    0.00 :   40918d: cmp    %eax,%edx
    0.00 :   40918f: jle    4091b7 <Minisat::SimpSolver::eliminateVar(int)+0x3b7>
         : 357    vec[j++] = vec[i];
    0.00 :   409191: movslq %r9d,%rcx
    0.00 :   409194: jmp    409166 <Minisat::SimpSolver::eliminateVar(int)+0x366>
         : 360    for (i = j = 0; i < vec.size(); i++)
    0.00 :   409196: lea    0x1(%rax),%esi
    0.00 :   409199: add    $0x1,%rax
    0.00 :   40919d: cmp    %eax,%edx
    0.00 :   40919f: jg     409166 <Minisat::SimpSolver::eliminateVar(int)+0x366>
         : 365    vec.shrink(i - j);
    0.00 :   4091a1: mov    %esi,%eax
    0.00 :   4091a3: sub    %ecx,%eax
         : 368    void     shrink   (int nelems)     { assert(nelems <= sz); for (int i = 0; i < nelems; i++) sz--, data[sz].~T(); }
    0.00 :   4091a5: test   %eax,%eax
    0.00 :   4091a7: jle    4091ae <Minisat::SimpSolver::eliminateVar(int)+0x3ae>
    0.00 :   4091a9: sub    %eax,%edx
    0.00 :   4091ab: mov    %edx,0x8(%rdi)
         : 373    dirty[toInt(idx)] = 0;
    0.00 :   4091ae: movb   $0x0,(%r8)
         : 375    }
    0.00 :   4091b2: jmp    408e52 <Minisat::SimpSolver::eliminateVar(int)+0x52>
         : 377    vec[j++] = vec[i];
    0.00 :   4091b7: mov    %r9d,%ecx
    0.00 :   4091ba: jmp    4091a1 <Minisat::SimpSolver::eliminateVar(int)+0x3a1>
         : 380    for (int i = 0; i < cls.size(); i++)
    0.00 :   4091bc: movq   $0x0,0x10(%rsp)
    0.00 :   4091c5: movq   $0x0,0x8(%rsp)
         : 383    int      size     (void) const     { return sz; }
    0.00 :   4091ce: movl   $0x0,0x50(%rsp)
         : 385    eliminated[v] = true;
    0.00 :   4091d6: mov    0x480(%r15),%rax
    0.00 :   4091dd: mov    0x40(%rsp),%rdi
    0.00 :   4091e2: movb   $0x1,(%rax,%rdi,1)
         : 389    T&       operator [] (int index)       { return data[index]; }
    0.00 :   4091e6: mov    0x1d0(%r15),%rax
    0.00 :   4091ed: add    %rdi,%rax
         : 392    inline int      Solver::nFreeVars     ()      const   { return (int)dec_vars - (trail_lim.size() == 0 ? trail.size() : trail_lim[0]); }
         : 393    inline void     Solver::setPolarity   (Var v, bool b) { polarity[v] = b; }
         : 394    inline void     Solver::setDecisionVar(Var v, bool b)
         : 395    {
         : 396    if      ( b && !decision[v]) dec_vars++;
         : 397    else if (!b &&  decision[v]) dec_vars--;
    0.00 :   4091f0: cmpb   $0x0,(%rax)
    0.00 :   4091f3: je     4091fd <Minisat::SimpSolver::eliminateVar(int)+0x3fd>
    0.00 :   4091f5: subq   $0x1,0xf8(%r15)
         :
         : 402    decision[v] = b;
    0.00 :   4091fd: movb   $0x0,(%rax)
         : 404    int      size     (void) const     { return sz; }
    0.00 :   409200: mov    0x250(%r15),%eax
         : 406    public:
         : 407    Heap(const Comp& c) : lt(c) { }
         :
         : 409    int  size      ()          const { return heap.size(); }
         : 410    bool empty     ()          const { return heap.size() == 0; }
         : 411    bool inHeap    (int n)     const { return n < indices.size() && indices[n] >= 0; }
    0.00 :   409207: cmp    %ebx,%eax
    0.00 :   409209: jle    4092e0 <Minisat::SimpSolver::eliminateVar(int)+0x4e0>
    0.00 :   40920f: mov    0x248(%r15),%rdx
    0.00 :   409216: mov    0x40(%rsp),%rdi
    0.00 :   40921b: mov    (%rdx,%rdi,4),%esi
    0.00 :   40921e: test   %esi,%esi
    0.00 :   409220: js     4092e0 <Minisat::SimpSolver::eliminateVar(int)+0x4e0>
    0.00 :   409226: mov    0x78(%rsp),%r12d
         : 420    if (pos.size() > neg.size()){
    0.00 :   40922b: mov    0x50(%rsp),%eax
         : 422    mkElimClause(elimclauses, ~mkLit(v));
    0.00 :   40922f: lea    0x3c8(%r15),%rbp
         : 424    eliminated_vars++;
    0.00 :   409236: addl   $0x1,0x3bc(%r15)
         : 426    if (pos.size() > neg.size()){
    0.00 :   40923e: cmp    %r12d,%eax
    0.00 :   409241: jle    4093af <Minisat::SimpSolver::eliminateVar(int)+0x5af>
         : 429    for (int i = 0; i < neg.size(); i++)
    0.00 :   409247: test   %r12d,%r12d
    0.00 :   40924a: jle    40927d <Minisat::SimpSolver::eliminateVar(int)+0x47d>
    0.00 :   40924c: mov    0x8(%rsp),%rdi
    0.00 :   409251: mov    %r12d,%eax
    0.00 :   409254: mov    %rdi,%r13
    0.00 :   409257: lea    (%rdi,%rax,4),%r14
         : 436    T&       operator[](Ref r)       { assert(r >= 0 && r < sz); return memory[r]; }
    0.00 :   40925b: mov    0x0(%r13),%edx
    0.00 :   40925f: mov    0x308(%r15),%rax
         : 439    mkElimClause(elimclauses, v, ca[neg[i]]);
    0.00 :   409266: mov    %ebx,%esi
    0.00 :   409268: mov    %rbp,%rdi
    0.00 :   40926b: lea    (%rax,%rdx,4),%rdx
    0.00 :   40926f: call   406ca0 <mkElimClause(Minisat::vec<unsigned int>&, int, Minisat::Clause&)>
         : 444    for (int i = 0; i < neg.size(); i++)
    0.00 :   409274: add    $0x4,%r13
    0.00 :   409278: cmp    %r14,%r13
    0.00 :   40927b: jne    40925b <Minisat::SimpSolver::eliminateVar(int)+0x45b>
         : 448    inline  Lit  mkLit     (Var var, bool sign=false) { Lit p; p.x = var + var + (int)sign; return p; }
    0.00 :   40927d: lea    (%rbx,%rbx,1),%eax
    0.00 :   409280: mov    %eax,(%rsp)
         : 451    void     push  (const T& elem)     { if (sz == cap) capacity(sz+1); data[sz++] = elem; }
    0.00 :   409283: movslq 0x3d0(%r15),%rax
    0.00 :   40928a: cmp    0x3d4(%r15),%eax
    0.00 :   409291: je     409580 <Minisat::SimpSolver::eliminateVar(int)+0x780>
    0.00 :   409297: mov    0x3c8(%r15),%rdx
    0.00 :   40929e: mov    (%rsp),%edi
    0.00 :   4092a1: lea    0x1(%rax),%ecx
    0.00 :   4092a4: mov    %ecx,0x3d0(%r15)
    0.00 :   4092ab: mov    %edi,(%rdx,%rax,4)
    0.00 :   4092ae: movslq 0x3d0(%r15),%rax
    0.00 :   4092b5: cmp    0x3d4(%r15),%eax
    0.00 :   4092bc: jne    40942e <Minisat::SimpSolver::eliminateVar(int)+0x62e>
    0.00 :   4092c2: lea    0x1(%rax),%esi
    0.00 :   4092c5: mov    %rbp,%rdi
    0.00 :   4092c8: call   40af10 <Minisat::vec<unsigned int>::capacity(int)>
    0.00 :   4092cd: mov    0x3c8(%r15),%rdx
    0.00 :   4092d4: movslq 0x3d0(%r15),%rax
    0.00 :   4092db: jmp    40942e <Minisat::SimpSolver::eliminateVar(int)+0x62e>
         : 469    if (!order_heap.inHeap(x) && decision[x]) order_heap.insert(x); }
    0.00 :   4092e0: mov    0x1d0(%r15),%rdx
    0.00 :   4092e7: mov    0x40(%rsp),%rdi
    0.00 :   4092ec: cmpb   $0x0,(%rdx,%rdi,1)
    0.00 :   4092f0: je     409226 <Minisat::SimpSolver::eliminateVar(int)+0x426>
         : 474    }
         :
         :
         : 477    void insert(int n)
         : 478    {
         : 479    indices.growTo(n+1, -1);
    0.00 :   4092f6: lea    0x1(%rbx),%ebp
         : 481    if (sz >= size) return;
    0.00 :   4092f9: cmp    %ebp,%eax
    0.00 :   4092fb: jl     40953a <Minisat::SimpSolver::eliminateVar(int)+0x73a>
         : 484    const T& operator [] (int index) const { return data[index]; }
    0.00 :   409301: mov    0x248(%r15),%r12
         : 486    T&       operator [] (int index)       { return data[index]; }
    0.00 :   409308: mov    0x40(%rsp),%rbp
         : 488    int      size     (void) const     { return sz; }
    0.00 :   40930d: mov    0x240(%r15),%eax
         : 490    T&       operator [] (int index)       { return data[index]; }
    0.00 :   409314: shl    $0x2,%rbp
    0.00 :   409318: lea    (%r12,%rbp,1),%rcx
         : 493    assert(!inHeap(n));
         :
         : 495    indices[n] = heap.size();
    0.00 :   40931c: mov    %eax,(%rcx)
         : 497    void     push  (const T& elem)     { if (sz == cap) capacity(sz+1); data[sz++] = elem; }
    0.00 :   40931e: cmp    0x244(%r15),%eax
    0.00 :   409325: je     40951b <Minisat::SimpSolver::eliminateVar(int)+0x71b>
    0.00 :   40932b: movslq 0x240(%r15),%rax
    0.00 :   409332: mov    0x238(%r15),%rdx
    0.00 :   409339: lea    0x1(%rax),%esi
    0.00 :   40933c: mov    %esi,0x240(%r15)
    0.00 :   409343: mov    %ebx,(%rdx,%rax,4)
         : 505    heap.push(n);
         : 506    percolateUp(indices[n]);
    0.00 :   409346: movslq (%rcx),%r8
         : 508    static inline int parent(int i) { return (i-1) >> 1; }
    0.00 :   409349: lea    -0x1(%r8),%ecx
         : 510    int x  = heap[i];
    0.00 :   40934d: mov    (%rdx,%r8,4),%edi
         : 512    percolateUp(indices[n]);
    0.00 :   409351: mov    %r8,%rax
         : 514    static inline int parent(int i) { return (i-1) >> 1; }
    0.00 :   409354: sar    %ecx
         : 516    while (i != 0 && lt(x, heap[p])){
    0.00 :   409356: test   %r8d,%r8d
    0.00 :   409359: je     409513 <Minisat::SimpSolver::eliminateVar(int)+0x713>
         : 519    const T& operator [] (int index) const { return data[index]; }
    0.00 :   40935f: mov    0x230(%r15),%rsi
    0.00 :   409366: mov    (%rsi),%r11
    0.00 :   409369: movslq %edi,%rsi
         : 523    bool operator () (Var x, Var y) const { return activity[x] > activity[y]; }
    0.00 :   40936c: movsd  (%r11,%rsi,8),%xmm0
    0.00 :   409372: jmp    40938e <Minisat::SimpSolver::eliminateVar(int)+0x58e>
         : 526    heap[i]          = heap[p];
    0.00 :   409374: mov    %r9d,(%r8)
         : 528    static inline int parent(int i) { return (i-1) >> 1; }
    0.00 :   409377: lea    -0x1(%rcx),%r8d
         : 530    indices[heap[p]] = i;
    0.00 :   40937b: mov    %eax,(%r12,%r9,4)
         : 532    static inline int parent(int i) { return (i-1) >> 1; }
    0.00 :   40937f: sar    %r8d
         : 534    while (i != 0 && lt(x, heap[p])){
    0.00 :   409382: mov    %ecx,%eax
    0.00 :   409384: test   %ecx,%ecx
    0.00 :   409386: je     4093a4 <Minisat::SimpSolver::eliminateVar(int)+0x5a4>
         : 538    p                = parent(p);
    0.00 :   409388: mov    %r8d,%ecx
    0.00 :   40938b: movslq %eax,%r8
         : 541    T&       operator [] (int index)       { return data[index]; }
    0.00 :   40938e: movslq %ecx,%r9
    0.00 :   409391: lea    (%rdx,%r8,4),%r8
         : 544    while (i != 0 && lt(x, heap[p])){
    0.00 :   409395: movslq (%rdx,%r9,4),%r9
    0.00 :   409399: comisd (%r11,%r9,8),%xmm0
    0.00 :   40939f: ja     409374 <Minisat::SimpSolver::eliminateVar(int)+0x574>
    0.00 :   4093a1: mov    %r8,%rdx
         : 549    heap   [i] = x;
    0.00 :   4093a4: mov    %edi,(%rdx)
         : 551    indices[x] = i;
    0.00 :   4093a6: mov    %eax,(%r12,%rsi,4)
    0.00 :   4093aa: jmp    409226 <Minisat::SimpSolver::eliminateVar(int)+0x426>
         : 554    for (int i = 0; i < pos.size(); i++)
    0.00 :   4093af: test   %eax,%eax
    0.00 :   4093b1: jle    4093e5 <Minisat::SimpSolver::eliminateVar(int)+0x5e5>
    0.00 :   4093b3: mov    0x10(%rsp),%rdi
    0.00 :   4093b8: sub    $0x1,%eax
    0.00 :   4093bb: mov    %rdi,%r13
    0.00 :   4093be: lea    0x4(%rdi,%rax,4),%r14
    0.00 :   4093c3: mov    0x0(%r13),%edx
    0.00 :   4093c7: mov    0x308(%r15),%rax
         : 563    mkElimClause(elimclauses, v, ca[pos[i]]);
    0.00 :   4093ce: mov    %ebx,%esi
    0.00 :   4093d0: mov    %rbp,%rdi
    0.00 :   4093d3: lea    (%rax,%rdx,4),%rdx
    0.00 :   4093d7: call   406ca0 <mkElimClause(Minisat::vec<unsigned int>&, int, Minisat::Clause&)>
         : 568    for (int i = 0; i < pos.size(); i++)
    0.00 :   4093dc: add    $0x4,%r13
    0.00 :   4093e0: cmp    %r14,%r13
    0.00 :   4093e3: jne    4093c3 <Minisat::SimpSolver::eliminateVar(int)+0x5c3>
    0.00 :   4093e5: lea    (%rbx,%rbx,1),%eax
    0.00 :   4093e8: mov    %eax,(%rsp)
         : 574    inline  Lit  operator ~(Lit p)              { Lit q; q.x = p.x ^ 1; return q; }
    0.00 :   4093eb: xor    $0x1,%eax
    0.00 :   4093ee: mov    %eax,%r13d
         : 577    void     push  (const T& elem)     { if (sz == cap) capacity(sz+1); data[sz++] = elem; }
    0.00 :   4093f1: movslq 0x3d0(%r15),%rax
    0.00 :   4093f8: cmp    0x3d4(%r15),%eax
    0.00 :   4093ff: je     409597 <Minisat::SimpSolver::eliminateVar(int)+0x797>
    0.00 :   409405: mov    0x3c8(%r15),%rdx
    0.00 :   40940c: lea    0x1(%rax),%ecx
    0.00 :   40940f: mov    %ecx,0x3d0(%r15)
    0.00 :   409416: mov    %r13d,(%rdx,%rax,4)
    0.00 :   40941a: movslq 0x3d0(%r15),%rax
    0.00 :   409421: cmp    0x3d4(%r15),%eax
    0.00 :   409428: je     4092c2 <Minisat::SimpSolver::eliminateVar(int)+0x4c2>
    0.00 :   40942e: lea    0x1(%rax),%ecx
         : 589    for (int i = 0; i < cls.size(); i++)
    0.00 :   409431: xor    %ebp,%ebp
    0.00 :   409433: mov    %ecx,0x3d0(%r15)
    0.00 :   40943a: movl   $0x1,(%rdx,%rax,4)
    0.00 :   409441: mov    0x38(%rsp),%rax
    0.00 :   409446: mov    0x8(%rax),%ecx
    0.00 :   409449: test   %ecx,%ecx
    0.00 :   40944b: jle    40946a <Minisat::SimpSolver::eliminateVar(int)+0x66a>
         : 597    removeClause(cls[i]);
    0.00 :   40944d: mov    0x38(%rsp),%r14
    0.00 :   409452: mov    %r15,%rdi
    0.00 :   409455: mov    (%r14),%rax
    0.00 :   409458: mov    (%rax,%rbp,4),%esi
    0.00 :   40945b: call   406500 <Minisat::SimpSolver::removeClause(unsigned int)>
         : 603    for (int i = 0; i < cls.size(); i++)
    0.00 :   409460: add    $0x1,%rbp
    0.00 :   409464: cmp    %ebp,0x8(%r14)
    0.00 :   409468: jg     40944d <Minisat::SimpSolver::eliminateVar(int)+0x64d>
         : 607    for (int i = 0; i < pos.size(); i++)
    0.00 :   40946a: mov    0x50(%rsp),%eax
         : 609    vec<Lit>& resolvent = add_tmp;
    0.00 :   40946e: lea    0x360(%r15),%r14
         : 611    for (int i = 0; i < pos.size(); i++)
    0.00 :   409475: test   %eax,%eax
    0.00 :   409477: jle    4095bf <Minisat::SimpSolver::eliminateVar(int)+0x7bf>
    0.00 :   40947d: mov    0x10(%rsp),%rdi
    0.00 :   409482: sub    $0x1,%eax
    0.00 :   409485: lea    0x4(%rdi,%rax,4),%rax
    0.00 :   40948a: mov    %rdi,%r13
    0.00 :   40948d: mov    0x8(%rsp),%rdi
    0.00 :   409492: mov    %rax,0x20(%rsp)
    0.00 :   409497: lea    -0x1(%r12),%eax
    0.00 :   40949c: lea    0x4(%rdi,%rax,4),%rax
    0.00 :   4094a1: mov    %rax,0x18(%rsp)
         : 623    for (int j = 0; j < neg.size(); j++)
    0.00 :   4094a6: mov    0x8(%rsp),%rbp
    0.00 :   4094ab: test   %r12d,%r12d
    0.00 :   4094ae: jg     4094c7 <Minisat::SimpSolver::eliminateVar(int)+0x6c7>
    0.00 :   4094b0: jmp    4095b0 <Minisat::SimpSolver::eliminateVar(int)+0x7b0>
    0.00 :   4094b5: nopl   (%rax)
    0.00 :   4094b8: add    $0x4,%rbp
    0.00 :   4094bc: cmp    0x18(%rsp),%rbp
    0.00 :   4094c1: je     4095b0 <Minisat::SimpSolver::eliminateVar(int)+0x7b0>
    0.00 :   4094c7: mov    0x308(%r15),%rax
    0.00 :   4094ce: mov    0x0(%rbp),%edx
         : 634    if (merge(ca[pos[i]], ca[neg[j]], v, resolvent) && !addClause_(resolvent))
    0.00 :   4094d1: mov    %r14,%r8
    0.00 :   4094d4: mov    %r15,%rdi
    0.00 :   4094d7: mov    0x0(%r13),%ecx
    0.00 :   4094db: lea    (%rax,%rdx,4),%rdx
    0.00 :   4094df: lea    (%rax,%rcx,4),%rsi
    0.00 :   4094e3: mov    %ebx,%ecx
    0.00 :   4094e5: call   406260 <Minisat::SimpSolver::merge(Minisat::Clause const&, Minisat::Clause const&, int, Minisat::vec<Minisat::Lit>&)>
    0.00 :   4094ea: test   %al,%al
    0.00 :   4094ec: je     4094b8 <Minisat::SimpSolver::eliminateVar(int)+0x6b8>
    0.00 :   4094ee: mov    %r14,%rsi
    0.00 :   4094f1: mov    %r15,%rdi
    0.00 :   4094f4: call   406db0 <Minisat::SimpSolver::addClause_(Minisat::vec<Minisat::Lit>&)>
    0.00 :   4094f9: test   %al,%al
    0.00 :   4094fb: jne    4094b8 <Minisat::SimpSolver::eliminateVar(int)+0x6b8>
         : 649    if (data != NULL){
    0.00 :   4094fd: cmpq   $0x0,0x8(%rsp)
    0.00 :   409503: je     4090cf <Minisat::SimpSolver::eliminateVar(int)+0x2cf>
    0.00 :   409509: jmp    4090be <Minisat::SimpSolver::eliminateVar(int)+0x2be>
         : 653    }
    0.00 :   40950e: call   49fd70 <__stack_chk_fail>
         : 655    T&       operator [] (int index)       { return data[index]; }
    0.00 :   409513: movslq %edi,%rsi
    0.00 :   409516: jmp    4093a4 <Minisat::SimpSolver::eliminateVar(int)+0x5a4>
         : 658    void     push  (const T& elem)     { if (sz == cap) capacity(sz+1); data[sz++] = elem; }
    0.00 :   40951b: lea    0x1(%rax),%esi
         : 660    heap.push(n);
    0.00 :   40951e: lea    0x238(%r15),%rdi
    0.00 :   409525: call   40adf0 <Minisat::vec<int>::capacity(int)>
         : 663    T&       operator [] (int index)       { return data[index]; }
    0.00 :   40952a: mov    0x248(%r15),%r12
    0.00 :   409531: lea    (%r12,%rbp,1),%rcx
    0.00 :   409535: jmp    40932b <Minisat::SimpSolver::eliminateVar(int)+0x52b>
         : 667    indices.growTo(n+1, -1);
    0.00 :   40953a: lea    0x248(%r15),%rdi
         : 669    capacity(size);
    0.00 :   409541: mov    %ebp,%esi
    0.00 :   409543: call   40adf0 <Minisat::vec<int>::capacity(int)>
         : 672    for (int i = sz; i < size; i++) data[i] = pad;
    0.00 :   409548: movslq 0x250(%r15),%rax
    0.00 :   40954f: mov    0x248(%r15),%r12
    0.00 :   409556: cmp    %eax,%ebp
    0.00 :   409558: jle    409574 <Minisat::SimpSolver::eliminateVar(int)+0x774>
    0.00 :   40955a: mov    %ebx,%edx
    0.00 :   40955c: lea    (%r12,%rax,4),%rdi
    0.00 :   409560: mov    $0xff,%esi
    0.00 :   409565: sub    %eax,%edx
    0.00 :   409567: lea    0x4(,%rdx,4),%rdx
    0.00 :   40956f: call   401120 <_init+0x120>
         : 683    sz = size; }
    0.00 :   409574: mov    %ebp,0x250(%r15)
    0.00 :   40957b: jmp    409308 <Minisat::SimpSolver::eliminateVar(int)+0x508>
         : 686    void     push  (const T& elem)     { if (sz == cap) capacity(sz+1); data[sz++] = elem; }
    0.00 :   409580: lea    0x1(%rax),%esi
    0.00 :   409583: mov    %rbp,%rdi
    0.00 :   409586: call   40af10 <Minisat::vec<unsigned int>::capacity(int)>
    0.00 :   40958b: movslq 0x3d0(%r15),%rax
    0.00 :   409592: jmp    409297 <Minisat::SimpSolver::eliminateVar(int)+0x497>
    0.00 :   409597: lea    0x1(%rax),%esi
    0.00 :   40959a: mov    %rbp,%rdi
    0.00 :   40959d: call   40af10 <Minisat::vec<unsigned int>::capacity(int)>
    0.00 :   4095a2: movslq 0x3d0(%r15),%rax
    0.00 :   4095a9: jmp    409405 <Minisat::SimpSolver::eliminateVar(int)+0x605>
    0.00 :   4095ae: xchg   %ax,%ax
         : 698    for (int i = 0; i < pos.size(); i++)
    0.00 :   4095b0: add    $0x4,%r13
    0.00 :   4095b4: cmp    0x20(%rsp),%r13
    0.00 :   4095b9: jne    4094a6 <Minisat::SimpSolver::eliminateVar(int)+0x6a6>
         : 702    T&       operator [] (int index)       { return data[index]; }
    0.00 :   4095bf: mov    0x48(%rsp),%rbx
    0.00 :   4095c4: add    0x3e8(%r15),%rbx
         : 705    if (data != NULL){
    0.00 :   4095cb: mov    (%rbx),%rdi
    0.00 :   4095ce: test   %rdi,%rdi
    0.00 :   4095d1: je     4095ed <Minisat::SimpSolver::eliminateVar(int)+0x7ed>
         : 709    sz = 0;
    0.00 :   4095d3: movl   $0x0,0x8(%rbx)
         : 711    if (dealloc) free(data), data = NULL, cap = 0; } }
    0.00 :   4095da: call   4657f0 <__free>
    0.00 :   4095df: movq   $0x0,(%rbx)
    0.00 :   4095e6: movl   $0x0,0xc(%rbx)
         : 715    T&       operator [] (int index)       { return data[index]; }
    0.00 :   4095ed: movslq (%rsp),%rbp
    0.00 :   4095f1: mov    0x178(%r15),%rbx
    0.00 :   4095f8: shl    $0x4,%rbp
    0.00 :   4095fc: add    %rbx,%rbp
         : 720    if (watches[ mkLit(v)].size() == 0) watches[ mkLit(v)].clear(true);
    0.00 :   4095ff: mov    0x8(%rbp),%edx
    0.00 :   409602: test   %edx,%edx
    0.00 :   409604: jne    40962a <Minisat::SimpSolver::eliminateVar(int)+0x82a>
         : 724    if (data != NULL){
    0.00 :   409606: mov    0x0(%rbp),%rdi
    0.00 :   40960a: test   %rdi,%rdi
    0.00 :   40960d: je     40962a <Minisat::SimpSolver::eliminateVar(int)+0x82a>
         : 728    if (dealloc) free(data), data = NULL, cap = 0; } }
    0.00 :   40960f: call   4657f0 <__free>
    0.00 :   409614: movq   $0x0,0x0(%rbp)
         : 731    T&       operator [] (int index)       { return data[index]; }
    0.00 :   40961c: mov    0x178(%r15),%rbx
         : 733    if (dealloc) free(data), data = NULL, cap = 0; } }
    0.00 :   409623: movl   $0x0,0xc(%rbp)
    0.00 :   40962a: mov    (%rsp),%eax
    0.00 :   40962d: xor    $0x1,%eax
         : 737    T&       operator [] (int index)       { return data[index]; }
    0.00 :   409630: cltq
    0.00 :   409632: shl    $0x4,%rax
    0.00 :   409636: add    %rax,%rbx
         : 741    if (watches[~mkLit(v)].size() == 0) watches[~mkLit(v)].clear(true);
    0.00 :   409639: mov    0x8(%rbx),%eax
    0.00 :   40963c: test   %eax,%eax
    0.00 :   40963e: jne    40965b <Minisat::SimpSolver::eliminateVar(int)+0x85b>
         : 745    if (data != NULL){
    0.00 :   409640: mov    (%rbx),%rdi
    0.00 :   409643: test   %rdi,%rdi
    0.00 :   409646: je     40965b <Minisat::SimpSolver::eliminateVar(int)+0x85b>
         : 749    if (dealloc) free(data), data = NULL, cap = 0; } }
    0.00 :   409648: call   4657f0 <__free>
    0.00 :   40964d: movq   $0x0,(%rbx)
    0.00 :   409654: movl   $0x0,0xc(%rbx)
         : 753    return backwardSubsumptionCheck();
    0.00 :   40965b: xor    %esi,%esi
    0.00 :   40965d: mov    %r15,%rdi
    0.00 :   409660: call   408600 <Minisat::SimpSolver::backwardSubsumptionCheck(bool)>
    0.00 :   409665: jmp    4094fd <Minisat::SimpSolver::eliminateVar(int)+0x6fd>
    0.00 :   40966a: endbr64
         : 759    if (data != NULL){
    0.00 :   40966e: mov    %rax,%rbp
    0.00 :   409671: jmp    401400 <Minisat::SimpSolver::eliminateVar(int) [clone .cold]>
 Percent |	Source code & Disassembly of minisat_HACK_999ED_CSSC_static for cycles:u (1 samples, percent: local period)
---------------------------------------------------------------------------------------------------------------------------
         :
         :
         :
         : 3      Disassembly of section .text:
         :
         : 5      0000000000463de0 <_int_malloc>:
    0.00 :   463de0: test   %rsi,%rsi
    0.00 :   463de3: js     4644a0 <_int_malloc+0x6c0>
    0.00 :   463de9: push   %r15
    0.00 :   463deb: lea    0x17(%rsi),%rax
    0.00 :   463def: push   %r14
    0.00 :   463df1: push   %r13
    0.00 :   463df3: push   %r12
    0.00 :   463df5: push   %rbp
    0.00 :   463df6: mov    %rsi,%rbp
    0.00 :   463df9: push   %rbx
    0.00 :   463dfa: mov    %rdi,%rbx
    0.00 :   463dfd: sub    $0x98,%rsp
    0.00 :   463e04: cmp    $0x1f,%rax
    0.00 :   463e08: ja     463f28 <_int_malloc+0x148>
    0.00 :   463e0e: test   %rdi,%rdi
    0.00 :   463e11: je     464460 <_int_malloc+0x680>
    0.00 :   463e17: cmpq   $0x1f,0xd4fb9(%rip)        # 538dd8 <global_max_fast>
    0.00 :   463e1f: ja     464010 <_int_malloc+0x230>
    0.00 :   463e25: mov    $0x80,%edx
    0.00 :   463e2a: mov    $0x2,%r14d
    0.00 :   463e30: mov    $0x20,%r13d
    0.00 :   463e36: add    %rbx,%rdx
    0.00 :   463e39: mov    0x8(%rdx),%rax
    0.00 :   463e3d: lea    -0x10(%rdx),%rsi
    0.00 :   463e41: cmp    %rax,%rsi
    0.00 :   463e44: je     464208 <_int_malloc+0x428>
    0.00 :   463e4a: mov    0x18(%rax),%rcx
    0.00 :   463e4e: cmp    %rax,0x10(%rcx)
    0.00 :   463e52: jne    464970 <_int_malloc+0xb90>
    0.00 :   463e58: lea    0xcd9e1(%rip),%r9        # 531840 <main_arena>
    0.00 :   463e5f: orq    $0x1,0x8(%rax,%r13,1)
    0.00 :   463e65: mov    %rcx,0x8(%rdx)
    0.00 :   463e69: mov    %rsi,0x10(%rcx)
    0.00 :   463e6d: cmp    %r9,%rbx
    0.00 :   463e70: je     463e77 <_int_malloc+0x97>
    0.00 :   463e72: orq    $0x4,0x8(%rax)
    0.00 :   463e77: mov    %fs:0xffffffffffffffc0,%r8
    0.00 :   463e80: test   %r8,%r8
    0.00 :   463e83: je     4644b8 <_int_malloc+0x6d8>
    0.00 :   463e89: lea    -0x11(%r13),%rdi
    0.00 :   463e8d: shr    $0x4,%rdi
    0.00 :   463e91: cmp    %rdi,0xcd970(%rip)        # 531808 <mp_+0x68>
    0.00 :   463e98: jbe    4644b8 <_int_malloc+0x6d8>
    0.00 :   463e9e: mov    0xd4f0b(%rip),%r14        # 538db0 <tcache_key>
    0.00 :   463ea5: mov    0xcd96c(%rip),%r11        # 531818 <mp_+0x78>
    0.00 :   463eac: lea    0x10(%rdi),%r15
    0.00 :   463eb0: movzwl (%r8,%rdi,2),%r10d
    0.00 :   463eb5: mov    %r14,0x8(%rsp)
    0.00 :   463eba: movzwl %r10w,%r12d
    0.00 :   463ebe: cmp    %r11,%r12
    0.00 :   463ec1: jae    4644b8 <_int_malloc+0x6d8>
    0.00 :   463ec7: cmp    %rcx,%rsi
    0.00 :   463eca: je     4644b8 <_int_malloc+0x6d8>
    0.00 :   463ed0: mov    0x18(%rcx),%r12
    0.00 :   463ed4: orq    $0x1,0x8(%rcx,%r13,1)
    0.00 :   463eda: cmp    %r9,%rbx
    0.00 :   463edd: je     463ee4 <_int_malloc+0x104>
    0.00 :   463edf: orq    $0x4,0x8(%rcx)
    0.00 :   463ee4: mov    0x8(%rsp),%r14
    0.00 :   463ee9: mov    %r12,0x8(%rdx)
    0.00 :   463eed: add    $0x1,%r10d
    0.00 :   463ef1: mov    %rsi,0x10(%r12)
    0.00 :   463ef6: mov    %r14,0x18(%rcx)
    0.00 :   463efa: lea    0x10(%rcx),%r14
    0.00 :   463efe: mov    %r14,0x10(%rsp)
    0.00 :   463f03: shr    $0xc,%r14
    0.00 :   463f07: xor    (%r8,%r15,8),%r14
    0.00 :   463f0b: mov    %r14,0x10(%rcx)
    0.00 :   463f0f: mov    0x10(%rsp),%r14
    0.00 :   463f14: mov    %r12,%rcx
    0.00 :   463f17: mov    %r14,(%r8,%r15,8)
    0.00 :   463f1b: mov    %r10w,(%r8,%rdi,2)
    0.00 :   463f20: jmp    463eba <_int_malloc+0xda>
    0.00 :   463f22: nopw   0x0(%rax,%rax,1)
    0.00 :   463f28: and    $0xfffffffffffffff0,%rax
    0.00 :   463f2c: mov    %rax,%r13
    0.00 :   463f2f: test   %rdi,%rdi
    0.00 :   463f32: je     464466 <_int_malloc+0x686>
    0.00 :   463f38: mov    %eax,%r14d
    0.00 :   463f3b: shr    $0x4,%r14d
    0.00 :   463f3f: cmp    0xd4e92(%rip),%rax        # 538dd8 <global_max_fast>
    0.00 :   463f46: jbe    464180 <_int_malloc+0x3a0>
    0.00 :   463f4c: cmp    $0x3ff,%rax
    0.00 :   463f52: jbe    464958 <_int_malloc+0xb78>
    0.00 :   463f58: mov    $0x2,%edx
    0.00 :   463f5d: mov    %rax,%rdi
    0.00 :   463f60: mov    %rax,%rcx
    0.00 :   463f63: mov    %rax,%rsi
    0.00 :   463f66: shr    $0xc,%rsi
    0.00 :   463f6a: mov    %rax,%r15
    0.00 :   463f6d: shr    $0x12,%rax
    0.00 :   463f71: shr    $0xf,%r15
    0.00 :   463f75: shr    $0x6,%rdi
    0.00 :   463f79: lea    0x6e(%rsi),%r10d
    0.00 :   463f7d: mov    %rsi,0x68(%rsp)
    0.00 :   463f82: shr    $0x9,%rcx
    0.00 :   463f86: cmp    %rdx,%rax
    0.00 :   463f89: lea    0x77(%r15),%r9d
    0.00 :   463f8d: mov    %r15,0x70(%rsp)
    0.00 :   463f92: cmova  %rdx,%rax
    0.00 :   463f96: mov    %r15,%rdx
    0.00 :   463f99: lea    0x5b(%rcx),%r15d
    0.00 :   463f9d: mov    %rdi,0x50(%rsp)
    0.00 :   463fa2: mov    %rcx,0x60(%rsp)
    0.00 :   463fa7: lea    0x7c(%rax),%r11d
    0.00 :   463fab: mov    %rsi,%rax
    0.00 :   463fae: mov    %edi,%esi
    0.00 :   463fb0: mov    %r9d,0x7c(%rsp)
    0.00 :   463fb5: add    $0x30,%esi
    0.00 :   463fb8: mov    %r11d,0x78(%rsp)
    0.00 :   463fbd: mov    %r10d,0x80(%rsp)
    0.00 :   463fc5: mov    %r15d,0x84(%rsp)
    0.00 :   463fcd: mov    %esi,0x5c(%rsp)
    0.00 :   463fd1: mov    %esi,0x1c(%rsp)
    0.00 :   463fd5: cmp    $0x30,%rdi
    0.00 :   463fd9: jbe    463ff8 <_int_malloc+0x218>
    0.00 :   463fdb: mov    %r15d,0x1c(%rsp)
    0.00 :   463fe0: cmp    $0x14,%rcx
    0.00 :   463fe4: jbe    463ff8 <_int_malloc+0x218>
    0.00 :   463fe6: mov    %r10d,0x1c(%rsp)
    0.00 :   463feb: cmp    $0xa,%rax
    0.00 :   463fef: ja     464720 <_int_malloc+0x940>
    0.00 :   463ff5: nopl   (%rax)
    0.00 :   463ff8: mov    0x8(%rbx),%eax
    0.00 :   463ffb: test   %eax,%eax
    0.00 :   463ffd: je     464265 <_int_malloc+0x485>
    0.00 :   464003: mov    %rbx,%rdi
    0.00 :   464006: call   461cc0 <malloc_consolidate>
    0.00 :   46400b: jmp    464265 <_int_malloc+0x485>
    0.00 :   464010: xor    %eax,%eax
    0.00 :   464012: mov    $0x10,%ecx
    0.00 :   464017: mov    $0x2,%r14d
    0.00 :   46401d: mov    $0x20,%r13d
    0.00 :   464023: lea    (%rbx,%rax,8),%rdi
    0.00 :   464027: mov    0x10(%rdi),%rdx
    0.00 :   46402b: test   %rdx,%rdx
    0.00 :   46402e: je     46419d <_int_malloc+0x3bd>
    0.00 :   464034: test   $0xf,%dl
    0.00 :   464037: jne    464820 <_int_malloc+0xa40>
    0.00 :   46403d: add    %rbx,%rcx
    0.00 :   464040: mov    %fs:0x18,%esi
    0.00 :   464048: mov    0x10(%rdx),%rax
    0.00 :   46404c: test   %esi,%esi
    0.00 :   46404e: jne    464164 <_int_malloc+0x384>
    0.00 :   464054: lea    0x10(%rdx),%r9
    0.00 :   464058: mov    %r9,%rsi
    0.00 :   46405b: shr    $0xc,%rsi
    0.00 :   46405f: xor    %rsi,%rax
    0.00 :   464062: mov    %rax,0x10(%rdi)
    0.00 :   464066: mov    0x8(%rdx),%rax
    0.00 :   46406a: shr    $0x4,%eax
    0.00 :   46406d: cmp    %r14d,%eax
    0.00 :   464070: jne    464840 <_int_malloc+0xa60>
    0.00 :   464076: mov    %fs:0xffffffffffffffc0,%r12
    0.00 :   46407f: lea    -0x11(%r13),%r11
    0.00 :   464083: shr    $0x4,%r11
    0.00 :   464087: test   %r12,%r12
    0.00 :   46408a: je     46447c <_int_malloc+0x69c>
    0.00 :   464090: cmp    %r11,0xcd771(%rip)        # 531808 <mp_+0x68>
    0.00 :   464097: jbe    46447c <_int_malloc+0x69c>
    0.00 :   46409d: movzwl (%r12,%r11,2),%eax
    0.00 :   4640a2: cmp    0xcd76f(%rip),%rax        # 531818 <mp_+0x78>
    0.00 :   4640a9: lea    0x10(%r11),%rbx
    0.00 :   4640ad: jb     4640fe <_int_malloc+0x31e>
    0.00 :   4640af: jmp    46447c <_int_malloc+0x69c>
    0.00 :   4640b4: nopl   0x0(%rax)
    0.00 :   4640b8: lea    0x10(%rdx),%r10
    0.00 :   4640bc: mov    %r10,%rsi
    0.00 :   4640bf: shr    $0xc,%rsi
    0.00 :   4640c3: xor    %rsi,%rax
    0.00 :   4640c6: mov    %rax,0x10(%rdi)
    0.00 :   4640ca: mov    0xd4cdf(%rip),%rax        # 538db0 <tcache_key>
    0.00 :   4640d1: xor    (%r12,%rbx,8),%rsi
    0.00 :   4640d5: mov    %rsi,0x10(%rdx)
    0.00 :   4640d9: mov    %rax,0x18(%rdx)
    0.00 :   4640dd: movzwl (%r12,%r11,2),%eax
    0.00 :   4640e2: mov    %r10,(%r12,%rbx,8)
    0.00 :   4640e6: add    $0x1,%eax
    0.00 :   4640e9: mov    %ax,(%r12,%r11,2)
    0.00 :   4640ee: movzwl %ax,%eax
    0.00 :   4640f1: cmp    0xcd720(%rip),%rax        # 531818 <mp_+0x78>
    0.00 :   4640f8: jae    46447c <_int_malloc+0x69c>
    0.00 :   4640fe: mov    0x10(%rdi),%rdx
    0.00 :   464102: test   %rdx,%rdx
    0.00 :   464105: je     46447c <_int_malloc+0x69c>
    0.00 :   46410b: test   $0xf,%dl
    0.00 :   46410e: jne    464760 <_int_malloc+0x980>
    0.00 :   464114: mov    %fs:0x18,%esi
    0.00 :   46411c: mov    0x10(%rdx),%rax
    0.00 :   464120: test   %esi,%esi
    0.00 :   464122: je     4640b8 <_int_malloc+0x2d8>
    0.00 :   464124: jmp    4641e8 <_int_malloc+0x408>
    0.00 :   464129: nopl   0x0(%rax)
    0.00 :   464130: test   $0xf,%sil
    0.00 :   464134: jne    464750 <_int_malloc+0x970>
    0.00 :   46413a: nopw   0x0(%rax,%rax,1)
    0.00 :   464140: mov    %rdx,%rax
    0.00 :   464143: cmpl   $0x0,%fs:0x18
    0.00 :   46414c: je     46414f <_int_malloc+0x36f>
    0.00 :   46414e: lock cmpxchg %rsi,(%rcx)
    0.00 :   464153: cmp    %rdx,%rax
    0.00 :   464156: je     464066 <_int_malloc+0x286>
    0.00 :   46415c: test   %rax,%rax
    0.00 :   46415f: je     46419d <_int_malloc+0x3bd>
    0.00 :   464161: mov    %rax,%rdx
    0.00 :   464164: lea    0x10(%rdx),%r9
    0.00 :   464168: mov    0x10(%rdx),%rax
    0.00 :   46416c: mov    %r9,%r8
    0.00 :   46416f: shr    $0xc,%r8
    0.00 :   464173: mov    %r8,%rsi
    0.00 :   464176: xor    %rax,%rsi
    0.00 :   464179: cmp    %rax,%r8
    0.00 :   46417c: je     464140 <_int_malloc+0x360>
    0.00 :   46417e: jmp    464130 <_int_malloc+0x350>
    0.00 :   464180: lea    -0x2(%r14),%eax
    0.00 :   464184: lea    (%rbx,%rax,8),%rdi
    0.00 :   464188: lea    0x10(,%rax,8),%rcx
    0.00 :   464190: mov    0x10(%rdi),%rdx
    0.00 :   464194: test   %rdx,%rdx
    0.00 :   464197: jne    464034 <_int_malloc+0x254>
    0.00 :   46419d: lea    0xc(%r14,%r14,1),%edx
    0.00 :   4641a2: shl    $0x3,%rdx
    0.00 :   4641a6: jmp    463e36 <_int_malloc+0x56>
    0.00 :   4641ab: nopl   0x0(%rax,%rax,1)
    0.00 :   4641b0: test   $0xf,%r8b
    0.00 :   4641b4: jne    464750 <_int_malloc+0x970>
    0.00 :   4641ba: nopw   0x0(%rax,%rax,1)
    0.00 :   4641c0: mov    %rdx,%rax
    0.00 :   4641c3: cmpl   $0x0,%fs:0x18
    0.00 :   4641cc: je     4641cf <_int_malloc+0x3ef>
    0.00 :   4641ce: lock cmpxchg %r8,(%rcx)
    0.00 :   4641d3: cmp    %rdx,%rax
    0.00 :   4641d6: je     4640ca <_int_malloc+0x2ea>
    0.00 :   4641dc: test   %rax,%rax
    0.00 :   4641df: je     46447c <_int_malloc+0x69c>
    0.00 :   4641e5: mov    %rax,%rdx
    0.00 :   4641e8: lea    0x10(%rdx),%r10
    0.00 :   4641ec: mov    0x10(%rdx),%rax
    0.00 :   4641f0: mov    %r10,%rsi
    0.00 :   4641f3: shr    $0xc,%rsi
    0.00 :   4641f7: mov    %rsi,%r8
    0.00 :   4641fa: xor    %rax,%r8
    0.00 :   4641fd: cmp    %rax,%rsi
    0.00 :   464200: je     4641c0 <_int_malloc+0x3e0>
    0.00 :   464202: jmp    4641b0 <_int_malloc+0x3d0>
    0.00 :   464204: nopl   0x0(%rax)
    0.00 :   464208: mov    %r13,%rcx
    0.00 :   46420b: mov    %r13,%rax
    0.00 :   46420e: mov    %r14d,0x1c(%rsp)
    0.00 :   464213: shr    $0x9,%rcx
    0.00 :   464217: shr    $0x6,%rax
    0.00 :   46421b: movl   $0x6e,0x80(%rsp)
  100.00 :   464226: mov    %ecx,%edi
    0.00 :   464228: mov    %rax,0x50(%rsp)
    0.00 :   46422d: add    $0x30,%eax
    0.00 :   464230: add    $0x5b,%edi
    0.00 :   464233: mov    %rcx,0x60(%rsp)
    0.00 :   464238: mov    %edi,0x84(%rsp)
    0.00 :   46423f: mov    %eax,0x5c(%rsp)
    0.00 :   464243: movl   $0x77,0x7c(%rsp)
    0.00 :   46424b: movl   $0x7c,0x78(%rsp)
    0.00 :   464253: movq   $0x0,0x70(%rsp)
    0.00 :   46425c: movq   $0x0,0x68(%rsp)
    0.00 :   464265: lea    -0x11(%r13),%rax
    0.00 :   464269: shr    $0x4,%rax
    0.00 :   46426d: mov    %rax,%r15
    0.00 :   464270: xor    %eax,%eax
    0.00 :   464272: mov    %rax,0x10(%rsp)
    0.00 :   464277: cmpq   $0x0,%fs:0xffffffffffffffc0
    0.00 :   464281: je     464293 <_int_malloc+0x4b3>
    0.00 :   464283: cmp    %r15,0xcd57e(%rip)        # 531808 <mp_+0x68>
    0.00 :   46428a: cmova  %r13,%rax
    0.00 :   46428e: mov    %rax,0x10(%rsp)
    0.00 :   464293: lea    0x60(%rbx),%r11
    0.00 :   464297: mov    %r14d,0x58(%rsp)
    0.00 :   46429c: movq   $0x0,0x8(%rsp)
    0.00 :   4642a5: movq   %r11,%xmm1
    0.00 :   4642aa: mov    %rbp,0x30(%rsp)
    0.00 :   4642af: punpcklqdq %xmm1,%xmm1
    0.00 :   4642b3: mov    0x78(%rbx),%rdx
    0.00 :   4642b7: cmp    %r11,%rdx
    0.00 :   4642ba: je     464638 <_int_malloc+0x858>
    0.00 :   4642c0: mov    0xcd559(%rip),%r8        # 531820 <mp_+0x80>
    0.00 :   4642c7: mov    0xcd54a(%rip),%rax        # 531818 <mp_+0x78>
    0.00 :   4642ce: lea    0x10(%r15),%r14
    0.00 :   4642d2: test   %r8,%r8
    0.00 :   4642d5: mov    %r8,%rbp
    0.00 :   4642d8: setne  0x38(%rsp)
    0.00 :   4642dd: xor    %edi,%edi
    0.00 :   4642df: xor    %r9d,%r9d
    0.00 :   4642e2: mov    %fs:0xffffffffffffffc0,%r12
    0.00 :   4642eb: mov    %rax,0x20(%rsp)
    0.00 :   4642f0: mov    0xd4ab9(%rip),%rax        # 538db0 <tcache_key>
    0.00 :   4642f7: mov    %rax,0x40(%rsp)
    0.00 :   4642fc: lea    0x20(%r13),%rax
    0.00 :   464300: mov    %rax,0x48(%rsp)
    0.00 :   464305: mov    0x8(%rdx),%rax
    0.00 :   464309: movq   %rdx,%xmm0
    0.00 :   46430e: punpcklqdq %xmm0,%xmm0
    0.00 :   464312: and    $0xfffffffffffffff8,%rax
    0.00 :   464316: lea    (%rdx,%rax,1),%r10
    0.00 :   46431a: cmp    $0x10,%rax
    0.00 :   46431e: jbe    4644e0 <_int_malloc+0x700>
    0.00 :   464324: mov    0x888(%rbx),%rsi
    0.00 :   46432b: cmp    %rax,%rsi
    0.00 :   46432e: jb     4644e0 <_int_malloc+0x700>
    0.00 :   464334: mov    0x8(%r10),%rcx
    0.00 :   464338: cmp    $0xf,%rcx
    0.00 :   46433c: jbe    4644f0 <_int_malloc+0x710>
    0.00 :   464342: cmp    %rcx,%rsi
    0.00 :   464345: jb     4644f0 <_int_malloc+0x710>
    0.00 :   46434b: mov    (%r10),%rsi
    0.00 :   46434e: and    $0xfffffffffffffff8,%rsi
    0.00 :   464352: cmp    %rax,%rsi
    0.00 :   464355: jne    464770 <_int_malloc+0x990>
    0.00 :   46435b: mov    0x18(%rdx),%rsi
    0.00 :   46435f: cmp    %rdx,0x10(%rsi)
    0.00 :   464363: jne    4646e0 <_int_malloc+0x900>
    0.00 :   464369: cmp    %r11,0x10(%rdx)
    0.00 :   46436d: jne    4646e0 <_int_malloc+0x900>
    0.00 :   464373: test   $0x1,%cl
    0.00 :   464376: jne    464830 <_int_malloc+0xa50>
    0.00 :   46437c: cmp    $0x3ff,%r13
    0.00 :   464383: ja     46438e <_int_malloc+0x5ae>
    0.00 :   464385: cmp    %r11,%rsi
    0.00 :   464388: je     464780 <_int_malloc+0x9a0>
    0.00 :   46438e: mov    %rsi,0x78(%rbx)
    0.00 :   464392: mov    %r11,0x10(%rsi)
    0.00 :   464396: cmp    %r13,%rax
    0.00 :   464399: je     464500 <_int_malloc+0x720>
    0.00 :   46439f: cmp    $0x3ff,%rax
    0.00 :   4643a5: ja     464548 <_int_malloc+0x768>
    0.00 :   4643ab: mov    %eax,%ecx
    0.00 :   4643ad: shr    $0x4,%ecx
    0.00 :   4643b0: lea    0xc(%rcx,%rcx,1),%eax
    0.00 :   4643b4: cltq
    0.00 :   4643b6: lea    (%rbx,%rax,8),%rax
    0.00 :   4643ba: mov    (%rax),%r8
    0.00 :   4643bd: lea    -0x10(%rax),%r10
    0.00 :   4643c1: mov    %ecx,%eax
    0.00 :   4643c3: movq   %r8,%xmm0
    0.00 :   4643c8: movq   %r10,%xmm2
    0.00 :   4643cd: mov    $0x1,%esi
    0.00 :   4643d2: sar    $0x5,%eax
    0.00 :   4643d5: punpcklqdq %xmm2,%xmm0
    0.00 :   4643d9: addq   $0x1,0x8(%rsp)
    0.00 :   4643df: shl    %cl,%esi
    0.00 :   4643e1: cltq
    0.00 :   4643e3: or     %esi,0x860(%rbx,%rax,4)
    0.00 :   4643ea: mov    0x8(%rsp),%rax
    0.00 :   4643ef: movups %xmm0,0x10(%rdx)
    0.00 :   4643f3: mov    %rdx,0x18(%r8)
    0.00 :   4643f7: mov    %rdx,0x10(%r10)
    0.00 :   4643fb: test   %r9d,%r9d
    0.00 :   4643fe: je     464620 <_int_malloc+0x840>
    0.00 :   464404: cmp    %rax,%rbp
    0.00 :   464407: jae    464440 <_int_malloc+0x660>
    0.00 :   464409: cmpb   $0x0,0x38(%rsp)
    0.00 :   46440e: je     464440 <_int_malloc+0x660>
    0.00 :   464410: lea    0x10(%r15),%rdx
    0.00 :   464414: mov    (%r12,%rdx,8),%r9
    0.00 :   464418: test   $0xf,%r9b
    0.00 :   46441c: jne    464c8d <_int_malloc+0xead>
    0.00 :   464422: mov    %r9,%rax
    0.00 :   464425: shr    $0xc,%rax
    0.00 :   464429: xor    (%r9),%rax
    0.00 :   46442c: mov    %rax,(%r12,%rdx,8)
    0.00 :   464430: subw   $0x1,(%r12,%r15,2)
    0.00 :   464436: movq   $0x0,0x8(%r9)
    0.00 :   46443e: jmp    464486 <_int_malloc+0x6a6>
    0.00 :   464440: add    $0x1,%edi
    0.00 :   464443: cmp    $0x270f,%edi
    0.00 :   464449: jg     464410 <_int_malloc+0x630>
    0.00 :   46444b: mov    0x78(%rbx),%rdx
    0.00 :   46444f: cmp    %rdx,%r11
    0.00 :   464452: je     464410 <_int_malloc+0x630>
    0.00 :   464454: mov    $0x1,%r9d
    0.00 :   46445a: jmp    464305 <_int_malloc+0x525>
    0.00 :   46445f: nop
    0.00 :   464460: mov    $0x20,%r13d
    0.00 :   464466: xor    %esi,%esi
    0.00 :   464468: mov    %r13,%rdi
    0.00 :   46446b: call   4634b0 <sysmalloc>
    0.00 :   464470: mov    %rax,%r9
    0.00 :   464473: test   %rax,%rax
    0.00 :   464476: je     464738 <_int_malloc+0x958>
    0.00 :   46447c: mov    0xd4952(%rip),%esi        # 538dd4 <perturb_byte>
    0.00 :   464482: test   %esi,%esi
    0.00 :   464484: jne    4644c6 <_int_malloc+0x6e6>
    0.00 :   464486: add    $0x98,%rsp
    0.00 :   46448d: mov    %r9,%rax
    0.00 :   464490: pop    %rbx
    0.00 :   464491: pop    %rbp
    0.00 :   464492: pop    %r12
    0.00 :   464494: pop    %r13
    0.00 :   464496: pop    %r14
    0.00 :   464498: pop    %r15
    0.00 :   46449a: ret
    0.00 :   46449b: nopl   0x0(%rax,%rax,1)
    0.00 :   4644a0: mov    $0xffffffffffffffb8,%rax
    0.00 :   4644a7: movl   $0xc,%fs:(%rax)
    0.00 :   4644ae: xor    %eax,%eax
    0.00 :   4644b0: ret
    0.00 :   4644b1: nopl   0x0(%rax)
    0.00 :   4644b8: mov    0xd4916(%rip),%esi        # 538dd4 <perturb_byte>
    0.00 :   4644be: lea    0x10(%rax),%r9
    0.00 :   4644c2: test   %esi,%esi
    0.00 :   4644c4: je     464486 <_int_malloc+0x6a6>
    0.00 :   4644c6: mov    %r9,%rdi
    0.00 :   4644c9: xor    $0xff,%sil
    0.00 :   4644cd: mov    %rbp,%rdx
    0.00 :   4644d0: call   401120 <_init+0x120>
    0.00 :   4644d5: mov    %rax,%r9
    0.00 :   4644d8: jmp    464486 <_int_malloc+0x6a6>
    0.00 :   4644da: nopw   0x0(%rax,%rax,1)
    0.00 :   4644e0: lea    0x99311(%rip),%rdi        # 4fd7f8 <__PRETTY_FUNCTION__.20+0xa16>
    0.00 :   4644e7: call   4610d0 <malloc_printerr>
    0.00 :   4644ec: nopl   0x0(%rax)
    0.00 :   4644f0: lea    0x99329(%rip),%rdi        # 4fd820 <__PRETTY_FUNCTION__.20+0xa3e>
    0.00 :   4644f7: call   4610d0 <malloc_printerr>
    0.00 :   4644fc: nopl   0x0(%rax)
    0.00 :   464500: or     $0x1,%rcx
    0.00 :   464504: lea    0xcd335(%rip),%rax        # 531840 <main_arena>
    0.00 :   46450b: mov    %rcx,0x8(%r10)
    0.00 :   46450f: cmp    %rax,%rbx
    0.00 :   464512: je     464519 <_int_malloc+0x739>
    0.00 :   464514: orq    $0x4,0x8(%rdx)
    0.00 :   464519: cmpq   $0x0,0x10(%rsp)
    0.00 :   46451f: lea    0x10(%rdx),%r9
    0.00 :   464523: je     464538 <_int_malloc+0x758>
    0.00 :   464525: movzwl (%r12,%r15,2),%ecx
    0.00 :   46452a: mov    %rcx,%rax
    0.00 :   46452d: cmp    0x20(%rsp),%rcx
    0.00 :   464532: jb     4646f0 <_int_malloc+0x910>
    0.00 :   464538: mov    0x30(%rsp),%rbp
    0.00 :   46453d: jmp    46447c <_int_malloc+0x69c>
    0.00 :   464542: nopw   0x0(%rax,%rax,1)
    0.00 :   464548: mov    %rax,%rcx
    0.00 :   46454b: shr    $0x6,%rcx
    0.00 :   46454f: add    $0x30,%ecx
    0.00 :   464552: cmp    $0xc3f,%rax
    0.00 :   464558: jbe    4645b0 <_int_malloc+0x7d0>
    0.00 :   46455a: mov    %rax,%rcx
    0.00 :   46455d: shr    $0x9,%rcx
    0.00 :   464561: add    $0x5b,%ecx
    0.00 :   464564: cmp    $0x29ff,%rax
    0.00 :   46456a: jbe    4645b0 <_int_malloc+0x7d0>
    0.00 :   46456c: mov    %rax,%rcx
    0.00 :   46456f: shr    $0xc,%rcx
    0.00 :   464573: add    $0x6e,%ecx
    0.00 :   464576: cmp    $0xafff,%rax
    0.00 :   46457c: jbe    4645b0 <_int_malloc+0x7d0>
    0.00 :   46457e: mov    %rax,%rcx
    0.00 :   464581: shr    $0xf,%rcx
    0.00 :   464585: add    $0x77,%ecx
    0.00 :   464588: cmp    $0x27fff,%rax
    0.00 :   46458e: jbe    4645b0 <_int_malloc+0x7d0>
    0.00 :   464590: mov    %rax,%rcx
    0.00 :   464593: mov    $0x2,%esi
    0.00 :   464598: shr    $0x12,%rcx
    0.00 :   46459c: cmp    %rsi,%rcx
    0.00 :   46459f: cmova  %rsi,%rcx
    0.00 :   4645a3: add    $0x7c,%ecx
    0.00 :   4645a6: cs nopw 0x0(%rax,%rax,1)
    0.00 :   4645b0: lea    0xc(%rcx,%rcx,1),%esi
    0.00 :   4645b4: movslq %esi,%rsi
    0.00 :   4645b7: lea    (%rbx,%rsi,8),%r10
    0.00 :   4645bb: mov    (%r10),%rsi
    0.00 :   4645be: lea    -0x10(%r10),%r8
    0.00 :   4645c2: cmp    %rsi,%r8
    0.00 :   4645c5: je     464740 <_int_malloc+0x960>
    0.00 :   4645cb: mov    0x8(%r10),%r10
    0.00 :   4645cf: or     $0x1,%rax
    0.00 :   4645d3: mov    %rax,0x88(%rsp)
    0.00 :   4645db: mov    0x8(%r10),%rax
    0.00 :   4645df: test   $0x4,%al
    0.00 :   4645e1: jne    464d06 <_int_malloc+0xf26>
    0.00 :   4645e7: cmp    0x88(%rsp),%rax
    0.00 :   4645ef: jbe    46497c <_int_malloc+0xb9c>
    0.00 :   4645f5: mov    0x28(%rsi),%rax
    0.00 :   4645f9: movq   %rsi,%xmm0
    0.00 :   4645fe: movq   %rax,%xmm3
    0.00 :   464603: punpcklqdq %xmm3,%xmm0
    0.00 :   464607: movups %xmm0,0x20(%rdx)
    0.00 :   46460b: mov    %rdx,0x20(%rax)
    0.00 :   46460f: mov    %rdx,0x28(%rsi)
    0.00 :   464613: jmp    4643c1 <_int_malloc+0x5e1>
    0.00 :   464618: nopl   0x0(%rax,%rax,1)
    0.00 :   464620: add    $0x1,%edi
    0.00 :   464623: cmp    $0x270f,%edi
    0.00 :   464629: jg     464638 <_int_malloc+0x858>
    0.00 :   46462b: mov    0x78(%rbx),%rdx
    0.00 :   46462f: cmp    %r11,%rdx
    0.00 :   464632: jne    464305 <_int_malloc+0x525>
    0.00 :   464638: cmp    $0x3ff,%r13
    0.00 :   46463f: jbe    464663 <_int_malloc+0x883>
    0.00 :   464641: mov    0x1c(%rsp),%eax
    0.00 :   464645: lea    0xc(%rax,%rax,1),%eax
    0.00 :   464649: lea    (%rbx,%rax,8),%rdx
    0.00 :   46464d: mov    (%rdx),%rax
    0.00 :   464650: lea    -0x10(%rdx),%rcx
    0.00 :   464654: cmp    %rcx,%rax
    0.00 :   464657: je     464663 <_int_malloc+0x883>
    0.00 :   464659: cmp    %r13,0x8(%rax)
    0.00 :   46465d: jae    464b3f <_int_malloc+0xd5f>
    0.00 :   464663: mov    0x1c(%rsp),%eax
    0.00 :   464667: lea    0x1(%rax),%ecx
    0.00 :   46466a: lea    0xe(%rax,%rax,1),%eax
    0.00 :   46466e: mov    %ecx,%edi
    0.00 :   464670: lea    -0x10(%rbx,%rax,8),%rdx
    0.00 :   464675: shr    $0x5,%edi
    0.00 :   464678: mov    %edi,%eax
    0.00 :   46467a: mov    0x860(%rbx,%rax,4),%esi
    0.00 :   464681: mov    $0x1,%eax
    0.00 :   464686: shl    %cl,%eax
    0.00 :   464688: nopl   0x0(%rax,%rax,1)
    0.00 :   464690: cmp    %esi,%eax
    0.00 :   464692: ja     464850 <_int_malloc+0xa70>
    0.00 :   464698: test   %eax,%eax
    0.00 :   46469a: jne    4646b4 <_int_malloc+0x8d4>
    0.00 :   46469c: jmp    464850 <_int_malloc+0xa70>
    0.00 :   4646a1: nopl   0x0(%rax)
    0.00 :   4646a8: add    $0x10,%rdx
    0.00 :   4646ac: add    %eax,%eax
    0.00 :   4646ae: je     464b20 <_int_malloc+0xd40>
    0.00 :   4646b4: test   %esi,%eax
    0.00 :   4646b6: je     4646a8 <_int_malloc+0x8c8>
    0.00 :   4646b8: mov    0x18(%rdx),%rcx
    0.00 :   4646bc: cmp    %rcx,%rdx
    0.00 :   4646bf: jne    4649fe <_int_malloc+0xc1e>
    0.00 :   4646c5: mov    %eax,%ecx
    0.00 :   4646c7: add    $0x10,%rdx
    0.00 :   4646cb: add    %eax,%eax
    0.00 :   4646cd: not    %ecx
    0.00 :   4646cf: and    %ecx,%esi
    0.00 :   4646d1: mov    %edi,%ecx
    0.00 :   4646d3: mov    %esi,0x860(%rbx,%rcx,4)
    0.00 :   4646da: jmp    464690 <_int_malloc+0x8b0>
    0.00 :   4646dc: nopl   0x0(%rax)
    0.00 :   4646e0: lea    0x99199(%rip),%rdi        # 4fd880 <__PRETTY_FUNCTION__.20+0xa9e>
    0.00 :   4646e7: call   4610d0 <malloc_printerr>
    0.00 :   4646ec: nopl   0x0(%rax)
    0.00 :   4646f0: mov    0x40(%rsp),%rcx
    0.00 :   4646f5: add    $0x1,%eax
    0.00 :   4646f8: mov    %rcx,0x18(%rdx)
    0.00 :   4646fc: mov    %r9,%rcx
    0.00 :   4646ff: shr    $0xc,%rcx
    0.00 :   464703: xor    (%r12,%r14,8),%rcx
    0.00 :   464707: mov    %rcx,0x10(%rdx)
    0.00 :   46470b: mov    %rsi,%rdx
    0.00 :   46470e: mov    %r9,(%r12,%r14,8)
    0.00 :   464712: mov    %ax,(%r12,%r15,2)
    0.00 :   464717: jmp    46444f <_int_malloc+0x66f>
    0.00 :   46471c: nopl   0x0(%rax)
    0.00 :   464720: cmp    $0x5,%rdx
    0.00 :   464724: cmovb  %r9d,%r11d
    0.00 :   464728: mov    %r11d,0x1c(%rsp)
    0.00 :   46472d: jmp    463ff8 <_int_malloc+0x218>
    0.00 :   464732: nopw   0x0(%rax,%rax,1)
    0.00 :   464738: xor    %r9d,%r9d
    0.00 :   46473b: jmp    464486 <_int_malloc+0x6a6>
    0.00 :   464740: movups %xmm0,0x20(%rdx)
    0.00 :   464744: mov    %r8,%r10
    0.00 :   464747: jmp    4643c1 <_int_malloc+0x5e1>
    0.00 :   46474c: nopl   0x0(%rax)
    0.00 :   464750: lea    0x98fe9(%rip),%rdi        # 4fd740 <__PRETTY_FUNCTION__.20+0x95e>
    0.00 :   464757: call   4610d0 <malloc_printerr>
    0.00 :   46475c: nopl   0x0(%rax)
    0.00 :   464760: lea    0x99031(%rip),%rdi        # 4fd798 <__PRETTY_FUNCTION__.20+0x9b6>
    0.00 :   464767: call   4610d0 <malloc_printerr>
    0.00 :   46476c: nopl   0x0(%rax)
    0.00 :   464770: lea    0x990d1(%rip),%rdi        # 4fd848 <__PRETTY_FUNCTION__.20+0xa66>
    0.00 :   464777: call   4610d0 <malloc_printerr>
    0.00 :   46477c: nopl   0x0(%rax)
    0.00 :   464780: cmp    %rdx,0x68(%rbx)
    0.00 :   464784: jne    46438e <_int_malloc+0x5ae>
    0.00 :   46478a: cmp    %rax,0x48(%rsp)
    0.00 :   46478f: jae    46438e <_int_malloc+0x5ae>
    0.00 :   464795: lea    (%rdx,%r13,1),%rsi
    0.00 :   464799: sub    %r13,%rax
    0.00 :   46479c: mov    0x30(%rsp),%rbp
    0.00 :   4647a1: movq   %rsi,%xmm0
    0.00 :   4647a6: mov    %rsi,0x78(%rbx)
    0.00 :   4647aa: punpcklqdq %xmm0,%xmm0
    0.00 :   4647ae: movups %xmm0,0x68(%rbx)
    0.00 :   4647b2: movups %xmm1,0x10(%rsi)
    0.00 :   4647b6: cmp    $0x3ff,%rax
    0.00 :   4647bc: jbe    4647c6 <_int_malloc+0x9e6>
    0.00 :   4647be: pxor   %xmm0,%xmm0
    0.00 :   4647c2: movups %xmm0,0x20(%rsi)
    0.00 :   4647c6: lea    0xcd073(%rip),%rcx        # 531840 <main_arena>
    0.00 :   4647cd: lea    0x10(%rdx),%r9
    0.00 :   4647d1: cmp    %rcx,%rbx
    0.00 :   4647d4: setne  %cl
    0.00 :   4647d7: movzbl %cl,%ecx
    0.00 :   4647da: shl    $0x2,%rcx
    0.00 :   4647de: or     %r13,%rcx
    0.00 :   4647e1: or     $0x1,%rcx
    0.00 :   4647e5: mov    %rcx,0x8(%rdx)
    0.00 :   4647e9: mov    %rax,%rcx
    0.00 :   4647ec: or     $0x1,%rcx
    0.00 :   4647f0: mov    %rcx,0x8(%rsi)
    0.00 :   4647f4: mov    %rax,(%r10)
    0.00 :   4647f7: mov    0xd45d7(%rip),%eax        # 538dd4 <perturb_byte>
    0.00 :   4647fd: test   %eax,%eax
    0.00 :   4647ff: je     464486 <_int_malloc+0x6a6>
    0.00 :   464805: xor    $0xff,%al
    0.00 :   464807: mov    %r9,%rdi
    0.00 :   46480a: mov    %rbp,%rdx
    0.00 :   46480d: mov    %eax,%esi
    0.00 :   46480f: call   401120 <_init+0x120>
    0.00 :   464814: mov    %rax,%r9
    0.00 :   464817: jmp    464486 <_int_malloc+0x6a6>
    0.00 :   46481c: nopl   0x0(%rax)
    0.00 :   464820: lea    0x98ee9(%rip),%rdi        # 4fd710 <__PRETTY_FUNCTION__.20+0x92e>
    0.00 :   464827: call   4610d0 <malloc_printerr>
    0.00 :   46482c: nopl   0x0(%rax)
    0.00 :   464830: lea    0x99079(%rip),%rdi        # 4fd8b0 <__PRETTY_FUNCTION__.20+0xace>
    0.00 :   464837: call   4610d0 <malloc_printerr>
    0.00 :   46483c: nopl   0x0(%rax)
    0.00 :   464840: lea    0x98f29(%rip),%rdi        # 4fd770 <__PRETTY_FUNCTION__.20+0x98e>
    0.00 :   464847: call   4610d0 <malloc_printerr>
    0.00 :   46484c: nopl   0x0(%rax)
    0.00 :   464850: lea    0x1(%rdi),%eax
    0.00 :   464853: cmp    $0x3,%edi
    0.00 :   464856: je     464895 <_int_malloc+0xab5>
    0.00 :   464858: mov    %eax,%edx
    0.00 :   46485a: mov    0x860(%rbx,%rdx,4),%esi
    0.00 :   464861: test   %esi,%esi
    0.00 :   464863: jne    464acf <_int_malloc+0xcef>
    0.00 :   464869: lea    0x2(%rdi),%eax
    0.00 :   46486c: cmp    $0x2,%edi
    0.00 :   46486f: je     464895 <_int_malloc+0xab5>
    0.00 :   464871: mov    %eax,%edx
    0.00 :   464873: mov    0x860(%rbx,%rdx,4),%esi
    0.00 :   46487a: test   %esi,%esi
    0.00 :   46487c: jne    464acf <_int_malloc+0xcef>
    0.00 :   464882: cmp    $0x1,%edi
    0.00 :   464885: je     464895 <_int_malloc+0xab5>
    0.00 :   464887: mov    0x86c(%rbx),%esi
    0.00 :   46488d: test   %esi,%esi
    0.00 :   46488f: jne    464b00 <_int_malloc+0xd20>
    0.00 :   464895: mov    0x60(%rbx),%rax
    0.00 :   464899: mov    0x8(%rax),%rdx
    0.00 :   46489d: and    $0xfffffffffffffff8,%rdx
    0.00 :   4648a1: cmp    %rdx,0x888(%rbx)
    0.00 :   4648a8: jb     464ae8 <_int_malloc+0xd08>
    0.00 :   4648ae: lea    0x20(%r13),%rcx
    0.00 :   4648b2: cmp    %rdx,%rcx
    0.00 :   4648b5: jbe    464c33 <_int_malloc+0xe53>
    0.00 :   4648bb: mov    %r11,0x38(%rsp)
    0.00 :   4648c0: movaps %xmm1,0x20(%rsp)
    0.00 :   4648c5: mov    0x8(%rbx),%eax
    0.00 :   4648c8: test   %eax,%eax
    0.00 :   4648ca: je     464c99 <_int_malloc+0xeb9>
    0.00 :   4648d0: mov    %rbx,%rdi
    0.00 :   4648d3: call   461cc0 <malloc_consolidate>
    0.00 :   4648d8: mov    0x58(%rsp),%eax
    0.00 :   4648dc: movdqa 0x20(%rsp),%xmm1
    0.00 :   4648e2: cmp    $0x3ff,%r13
    0.00 :   4648e9: mov    0x38(%rsp),%r11
    0.00 :   4648ee: mov    %eax,0x1c(%rsp)
    0.00 :   4648f2: jbe    4642b3 <_int_malloc+0x4d3>
    0.00 :   4648f8: mov    0x5c(%rsp),%eax
    0.00 :   4648fc: cmpq   $0x30,0x50(%rsp)
    0.00 :   464902: mov    %eax,0x1c(%rsp)
    0.00 :   464906: jbe    4642b3 <_int_malloc+0x4d3>
    0.00 :   46490c: mov    0x84(%rsp),%eax
    0.00 :   464913: cmpq   $0x14,0x60(%rsp)
    0.00 :   464919: mov    %eax,0x1c(%rsp)
    0.00 :   46491d: jbe    4642b3 <_int_malloc+0x4d3>
    0.00 :   464923: mov    0x80(%rsp),%eax
    0.00 :   46492a: cmpq   $0xa,0x68(%rsp)
    0.00 :   464930: mov    %eax,0x1c(%rsp)
    0.00 :   464934: jbe    4642b3 <_int_malloc+0x4d3>
    0.00 :   46493a: mov    0x7c(%rsp),%eax
    0.00 :   46493e: cmpq   $0x4,0x70(%rsp)
    0.00 :   464944: cmova  0x78(%rsp),%eax
    0.00 :   464949: mov    %eax,0x1c(%rsp)
    0.00 :   46494d: jmp    4642b3 <_int_malloc+0x4d3>
    0.00 :   464952: nopw   0x0(%rax,%rax,1)
    0.00 :   464958: lea    -0x2(%r14,%r14,1),%eax
    0.00 :   46495d: lea    0x70(,%rax,8),%rdx
    0.00 :   464965: jmp    463e36 <_int_malloc+0x56>
    0.00 :   46496a: nopw   0x0(%rax,%rax,1)
    0.00 :   464970: lea    0x98e51(%rip),%rdi        # 4fd7c8 <__PRETTY_FUNCTION__.20+0x9e6>
    0.00 :   464977: call   4610d0 <malloc_printerr>
    0.00 :   46497c: mov    0x8(%rsi),%r8
    0.00 :   464980: test   $0x4,%r8b
    0.00 :   464984: jne    464ce7 <_int_malloc+0xf07>
    0.00 :   46498a: mov    0x88(%rsp),%rax
    0.00 :   464992: jmp    4649aa <_int_malloc+0xbca>
    0.00 :   464994: nopl   0x0(%rax)
    0.00 :   464998: mov    0x20(%rsi),%rsi
    0.00 :   46499c: mov    0x8(%rsi),%r8
    0.00 :   4649a0: test   $0x4,%r8b
    0.00 :   4649a4: jne    464c14 <_int_malloc+0xe34>
    0.00 :   4649aa: cmp    %r8,%rax
    0.00 :   4649ad: jb     464998 <_int_malloc+0xbb8>
    0.00 :   4649af: je     4649f8 <_int_malloc+0xc18>
    0.00 :   4649b1: movq   %rsi,%xmm0
    0.00 :   4649b6: movhps 0x28(%rsi),%xmm0
    0.00 :   4649ba: movups %xmm0,0x20(%rdx)
    0.00 :   4649be: mov    0x28(%rsi),%rax
    0.00 :   4649c2: cmp    %rsi,0x20(%rax)
    0.00 :   4649c6: jne    464af4 <_int_malloc+0xd14>
    0.00 :   4649cc: mov    %rdx,0x28(%rsi)
    0.00 :   4649d0: mov    0x28(%rdx),%rax
    0.00 :   4649d4: mov    %rsi,%r8
    0.00 :   4649d7: mov    %rdx,0x20(%rax)
    0.00 :   4649db: mov    0x18(%r8),%r10
    0.00 :   4649df: cmp    %r8,0x10(%r10)
    0.00 :   4649e3: je     4643c1 <_int_malloc+0x5e1>
    0.00 :   4649e9: lea    0x98f30(%rip),%rdi        # 4fd920 <__PRETTY_FUNCTION__.20+0xb3e>
    0.00 :   4649f0: call   4610d0 <malloc_printerr>
    0.00 :   4649f5: nopl   (%rax)
    0.00 :   4649f8: mov    0x10(%rsi),%r8
    0.00 :   4649fc: jmp    4649db <_int_malloc+0xbfb>
    0.00 :   4649fe: mov    0x8(%rcx),%r14
    0.00 :   464a02: mov    0x30(%rsp),%rbp
    0.00 :   464a07: and    $0xfffffffffffffff8,%r14
    0.00 :   464a0b: cmp    %r13,%r14
    0.00 :   464a0e: jb     464cc8 <_int_malloc+0xee8>
    0.00 :   464a14: mov    %r14,%r12
    0.00 :   464a17: mov    %rcx,%rdi
    0.00 :   464a1a: mov    %r11,0x10(%rsp)
    0.00 :   464a1f: sub    %r13,%r12
    0.00 :   464a22: mov    %rcx,0x8(%rsp)
    0.00 :   464a27: call   461be0 <unlink_chunk.constprop.0>
    0.00 :   464a2c: cmp    $0x1f,%r12
    0.00 :   464a30: mov    0x8(%rsp),%rcx
    0.00 :   464a35: mov    0x10(%rsp),%r11
    0.00 :   464a3a: jbe    464b07 <_int_malloc+0xd27>
    0.00 :   464a40: mov    0x70(%rbx),%rax
    0.00 :   464a44: movq   %r11,%xmm5
    0.00 :   464a49: lea    (%rcx,%r13,1),%rdx
    0.00 :   464a4d: movq   %rax,%xmm0
    0.00 :   464a52: punpcklqdq %xmm5,%xmm0
    0.00 :   464a56: cmp    %r11,0x18(%rax)
    0.00 :   464a5a: jne    464c81 <_int_malloc+0xea1>
    0.00 :   464a60: movups %xmm0,0x10(%rdx)
    0.00 :   464a64: mov    %rdx,0x70(%rbx)
    0.00 :   464a68: mov    %rdx,0x18(%rax)
    0.00 :   464a6c: cmp    $0x3ff,%r13
    0.00 :   464a73: ja     464a79 <_int_malloc+0xc99>
    0.00 :   464a75: mov    %rdx,0x68(%rbx)
    0.00 :   464a79: cmp    $0x3ff,%r12
    0.00 :   464a80: jbe    464a8a <_int_malloc+0xcaa>
    0.00 :   464a82: pxor   %xmm0,%xmm0
    0.00 :   464a86: movups %xmm0,0x20(%rdx)
    0.00 :   464a8a: lea    0xccdaf(%rip),%rax        # 531840 <main_arena>
    0.00 :   464a91: cmp    %rax,%rbx
    0.00 :   464a94: setne  %al
    0.00 :   464a97: movzbl %al,%eax
    0.00 :   464a9a: shl    $0x2,%rax
    0.00 :   464a9e: or     %r13,%rax
    0.00 :   464aa1: or     $0x1,%rax
    0.00 :   464aa5: mov    %rax,0x8(%rcx)
    0.00 :   464aa9: mov    %r12,%rax
    0.00 :   464aac: or     $0x1,%rax
    0.00 :   464ab0: mov    %rax,0x8(%rdx)
    0.00 :   464ab4: mov    %r12,(%rcx,%r14,1)
    0.00 :   464ab8: mov    0xd4316(%rip),%eax        # 538dd4 <perturb_byte>
    0.00 :   464abe: lea    0x10(%rcx),%r9
    0.00 :   464ac2: test   %eax,%eax
    0.00 :   464ac4: je     464486 <_int_malloc+0x6a6>
    0.00 :   464aca: jmp    464805 <_int_malloc+0xa25>
    0.00 :   464acf: mov    %eax,%edi
    0.00 :   464ad1: mov    %edi,%eax
    0.00 :   464ad3: shl    $0x6,%eax
    0.00 :   464ad6: add    $0xc,%eax
    0.00 :   464ad9: lea    -0x10(%rbx,%rax,8),%rdx
    0.00 :   464ade: mov    $0x1,%eax
    0.00 :   464ae3: jmp    4646b4 <_int_malloc+0x8d4>
    0.00 :   464ae8: lea    0x98176(%rip),%rdi        # 4fcc65 <__PRETTY_FUNCTION__.0+0x175>
    0.00 :   464aef: call   4610d0 <malloc_printerr>
    0.00 :   464af4: lea    0x98de5(%rip),%rdi        # 4fd8e0 <__PRETTY_FUNCTION__.20+0xafe>
    0.00 :   464afb: call   4610d0 <malloc_printerr>
    0.00 :   464b00: mov    $0x3,%edi
    0.00 :   464b05: jmp    464ad1 <_int_malloc+0xcf1>
    0.00 :   464b07: lea    0xccd32(%rip),%rax        # 531840 <main_arena>
    0.00 :   464b0e: orq    $0x1,0x8(%rcx,%r14,1)
    0.00 :   464b14: cmp    %rax,%rbx
    0.00 :   464b17: je     464ab8 <_int_malloc+0xcd8>
    0.00 :   464b19: orq    $0x4,0x8(%rcx)
    0.00 :   464b1e: jmp    464ab8 <_int_malloc+0xcd8>
    0.00 :   464b20: lea    0x99319(%rip),%rcx        # 4fde40 <__PRETTY_FUNCTION__.7>
    0.00 :   464b27: mov    $0x10bb,%edx
    0.00 :   464b2c: lea    0xad55c(%rip),%rsi        # 51208f <__PRETTY_FUNCTION__.2+0x1f>
    0.00 :   464b33: lea    0x98122(%rip),%rdi        # 4fcc5c <__PRETTY_FUNCTION__.0+0x16c>
    0.00 :   464b3a: call   461260 <__malloc_assert>
    0.00 :   464b3f: mov    0x30(%rsp),%rbp
    0.00 :   464b44: mov    0x28(%rax),%r14
    0.00 :   464b48: jmp    464b4e <_int_malloc+0xd6e>
    0.00 :   464b4a: mov    0x28(%r14),%r14
    0.00 :   464b4e: mov    0x8(%r14),%rcx
    0.00 :   464b52: mov    %rcx,%r15
    0.00 :   464b55: and    $0xfffffffffffffff8,%r15
    0.00 :   464b59: cmp    %r13,%r15
    0.00 :   464b5c: jb     464b4a <_int_malloc+0xd6a>
    0.00 :   464b5e: cmp    %r14,0x8(%rdx)
    0.00 :   464b62: je     464b70 <_int_malloc+0xd90>
    0.00 :   464b64: mov    0x10(%r14),%rax
    0.00 :   464b68: cmp    0x8(%rax),%rcx
    0.00 :   464b6c: cmove  %rax,%r14
    0.00 :   464b70: mov    %r15,%r12
    0.00 :   464b73: mov    %r14,%rdi
    0.00 :   464b76: mov    %r11,0x8(%rsp)
    0.00 :   464b7b: call   461be0 <unlink_chunk.constprop.0>
    0.00 :   464b80: sub    %r13,%r12
    0.00 :   464b83: mov    0x8(%rsp),%r11
    0.00 :   464b88: cmp    $0x1f,%r12
    0.00 :   464b8c: jbe    464d31 <_int_malloc+0xf51>
    0.00 :   464b92: mov    0x70(%rbx),%rax
    0.00 :   464b96: movq   %r11,%xmm4
    0.00 :   464b9b: lea    (%r14,%r13,1),%rdx
    0.00 :   464b9f: movq   %rax,%xmm0
    0.00 :   464ba4: punpcklqdq %xmm4,%xmm0
    0.00 :   464ba8: cmp    %r11,0x18(%rax)
    0.00 :   464bac: jne    464d25 <_int_malloc+0xf45>
    0.00 :   464bb2: movups %xmm0,0x10(%rdx)
    0.00 :   464bb6: mov    %rdx,0x70(%rbx)
    0.00 :   464bba: mov    %rdx,0x18(%rax)
    0.00 :   464bbe: cmp    $0x3ff,%r12
    0.00 :   464bc5: jbe    464bcf <_int_malloc+0xdef>
    0.00 :   464bc7: pxor   %xmm0,%xmm0
    0.00 :   464bcb: movups %xmm0,0x20(%rdx)
    0.00 :   464bcf: lea    0xccc6a(%rip),%rax        # 531840 <main_arena>
    0.00 :   464bd6: cmp    %rax,%rbx
    0.00 :   464bd9: setne  %al
    0.00 :   464bdc: movzbl %al,%eax
    0.00 :   464bdf: shl    $0x2,%rax
    0.00 :   464be3: or     %r13,%rax
    0.00 :   464be6: or     $0x1,%rax
    0.00 :   464bea: mov    %rax,0x8(%r14)
    0.00 :   464bee: mov    %r12,%rax
    0.00 :   464bf1: or     $0x1,%rax
    0.00 :   464bf5: mov    %rax,0x8(%rdx)
    0.00 :   464bf9: mov    %r12,(%r14,%r15,1)
    0.00 :   464bfd: mov    0xd41d1(%rip),%eax        # 538dd4 <perturb_byte>
    0.00 :   464c03: lea    0x10(%r14),%r9
    0.00 :   464c07: test   %eax,%eax
    0.00 :   464c09: je     464486 <_int_malloc+0x6a6>
    0.00 :   464c0f: jmp    464805 <_int_malloc+0xa25>
    0.00 :   464c14: lea    0x99225(%rip),%rcx        # 4fde40 <__PRETTY_FUNCTION__.7>
    0.00 :   464c1b: mov    $0x101a,%edx
    0.00 :   464c20: lea    0xad468(%rip),%rsi        # 51208f <__PRETTY_FUNCTION__.2+0x1f>
    0.00 :   464c27: lea    0x98017(%rip),%rdi        # 4fcc45 <__PRETTY_FUNCTION__.0+0x155>
    0.00 :   464c2e: call   461260 <__malloc_assert>
    0.00 :   464c33: lea    0xccc06(%rip),%rcx        # 531840 <main_arena>
    0.00 :   464c3a: lea    (%rax,%r13,1),%rsi
    0.00 :   464c3e: mov    0x30(%rsp),%rbp
    0.00 :   464c43: cmp    %rcx,%rbx
    0.00 :   464c46: mov    %rsi,0x60(%rbx)
    0.00 :   464c4a: lea    0x10(%rax),%r9
    0.00 :   464c4e: setne  %cl
    0.00 :   464c51: sub    %r13,%rdx
    0.00 :   464c54: movzbl %cl,%ecx
    0.00 :   464c57: or     $0x1,%rdx
    0.00 :   464c5b: shl    $0x2,%rcx
    0.00 :   464c5f: or     %r13,%rcx
    0.00 :   464c62: or     $0x1,%rcx
    0.00 :   464c66: mov    %rcx,0x8(%rax)
    0.00 :   464c6a: mov    0xd4164(%rip),%eax        # 538dd4 <perturb_byte>
    0.00 :   464c70: mov    %rdx,0x8(%rsi)
    0.00 :   464c74: test   %eax,%eax
    0.00 :   464c76: je     464486 <_int_malloc+0x6a6>
    0.00 :   464c7c: jmp    464805 <_int_malloc+0xa25>
    0.00 :   464c81: lea    0x98d58(%rip),%rdi        # 4fd9e0 <__PRETTY_FUNCTION__.20+0xbfe>
    0.00 :   464c88: call   4610d0 <malloc_printerr>
    0.00 :   464c8d: lea    0x98cc4(%rip),%rdi        # 4fd958 <__PRETTY_FUNCTION__.20+0xb76>
    0.00 :   464c94: call   4610d0 <malloc_printerr>
    0.00 :   464c99: mov    %rbx,%rsi
    0.00 :   464c9c: mov    %r13,%rdi
    0.00 :   464c9f: mov    0x30(%rsp),%rbp
    0.00 :   464ca4: call   4634b0 <sysmalloc>
    0.00 :   464ca9: mov    %rax,%r9
    0.00 :   464cac: test   %rax,%rax
    0.00 :   464caf: je     464738 <_int_malloc+0x958>
    0.00 :   464cb5: mov    0xd4119(%rip),%eax        # 538dd4 <perturb_byte>
    0.00 :   464cbb: test   %eax,%eax
    0.00 :   464cbd: je     464486 <_int_malloc+0x6a6>
    0.00 :   464cc3: jmp    464805 <_int_malloc+0xa25>
    0.00 :   464cc8: lea    0x99171(%rip),%rcx        # 4fde40 <__PRETTY_FUNCTION__.7>
    0.00 :   464ccf: mov    $0x10ce,%edx
    0.00 :   464cd4: lea    0xad3b4(%rip),%rsi        # 51208f <__PRETTY_FUNCTION__.2+0x1f>
    0.00 :   464cdb: lea    0x98cce(%rip),%rdi        # 4fd9b0 <__PRETTY_FUNCTION__.20+0xbce>
    0.00 :   464ce2: call   461260 <__malloc_assert>
    0.00 :   464ce7: lea    0x99152(%rip),%rcx        # 4fde40 <__PRETTY_FUNCTION__.7>
    0.00 :   464cee: mov    $0x1016,%edx
    0.00 :   464cf3: lea    0xad395(%rip),%rsi        # 51208f <__PRETTY_FUNCTION__.2+0x1f>
    0.00 :   464cfa: lea    0x97f44(%rip),%rdi        # 4fcc45 <__PRETTY_FUNCTION__.0+0x155>
    0.00 :   464d01: call   461260 <__malloc_assert>
    0.00 :   464d06: lea    0x99133(%rip),%rcx        # 4fde40 <__PRETTY_FUNCTION__.7>
    0.00 :   464d0d: mov    $0x1009,%edx
    0.00 :   464d12: lea    0xad376(%rip),%rsi        # 51208f <__PRETTY_FUNCTION__.2+0x1f>
    0.00 :   464d19: lea    0x97f0a(%rip),%rdi        # 4fcc2a <__PRETTY_FUNCTION__.0+0x13a>
    0.00 :   464d20: call   461260 <__malloc_assert>
    0.00 :   464d25: lea    0x98c5c(%rip),%rdi        # 4fd988 <__PRETTY_FUNCTION__.20+0xba6>
    0.00 :   464d2c: call   4610d0 <malloc_printerr>
    0.00 :   464d31: lea    0xccb08(%rip),%rax        # 531840 <main_arena>
    0.00 :   464d38: orq    $0x1,0x8(%r14,%r15,1)
    0.00 :   464d3e: cmp    %rax,%rbx
    0.00 :   464d41: je     464bfd <_int_malloc+0xe1d>
    0.00 :   464d47: orq    $0x4,0x8(%r14)
    0.00 :   464d4c: jmp    464bfd <_int_malloc+0xe1d>
 Percent |	Source code & Disassembly of minisat_HACK_999ED_CSSC_static for cycles:u (1 samples, percent: local period)
---------------------------------------------------------------------------------------------------------------------------
         :
         :
         :
         : 3      Disassembly of section .text:
         :
         : 5      000000000048d2e0 <__strlen_avx2>:
    0.00 :   48d2e0: endbr64
    0.00 :   48d2e4: mov    %edi,%eax
    0.00 :   48d2e6: mov    %rdi,%rdx
    0.00 :   48d2e9: vpxor  %xmm0,%xmm0,%xmm0
    0.00 :   48d2ed: and    $0xfff,%eax
    0.00 :   48d2f2: cmp    $0xfe0,%eax
    0.00 :   48d2f7: ja     48d430 <__strlen_avx2+0x150>
    0.00 :   48d2fd: vpcmpeqb (%rdi),%ymm0,%ymm1
  100.00 :   48d301: vpmovmskb %ymm1,%eax
    0.00 :   48d305: test   %eax,%eax
    0.00 :   48d307: je     48d360 <__strlen_avx2+0x80>
    0.00 :   48d309: tzcnt  %eax,%eax
    0.00 :   48d30d: vzeroupper
    0.00 :   48d310: ret
    0.00 :   48d311: data16 cs nopw 0x0(%rax,%rax,1)
    0.00 :   48d31c: nopl   0x0(%rax)
    0.00 :   48d320: tzcnt  %eax,%eax
    0.00 :   48d324: sub    %edx,%edi
    0.00 :   48d326: inc    %edi
    0.00 :   48d328: add    %edi,%eax
    0.00 :   48d32a: vzeroupper
    0.00 :   48d32d: ret
    0.00 :   48d32e: xchg   %ax,%ax
    0.00 :   48d330: tzcnt  %eax,%eax
    0.00 :   48d334: sub    %edx,%edi
    0.00 :   48d336: add    $0x21,%edi
    0.00 :   48d339: add    %edi,%eax
    0.00 :   48d33b: vzeroupper
    0.00 :   48d33e: ret
    0.00 :   48d33f: nop
    0.00 :   48d340: tzcnt  %eax,%eax
    0.00 :   48d344: sub    %edx,%edi
    0.00 :   48d346: add    $0x41,%edi
    0.00 :   48d349: add    %edi,%eax
    0.00 :   48d34b: vzeroupper
    0.00 :   48d34e: ret
    0.00 :   48d34f: nop
    0.00 :   48d350: tzcnt  %eax,%eax
    0.00 :   48d354: sub    %edx,%edi
    0.00 :   48d356: add    $0x61,%edi
    0.00 :   48d359: add    %edi,%eax
    0.00 :   48d35b: vzeroupper
    0.00 :   48d35e: ret
    0.00 :   48d35f: nop
    0.00 :   48d360: or     $0x1f,%rdi
    0.00 :   48d364: vpcmpeqb 0x1(%rdi),%ymm0,%ymm1
    0.00 :   48d369: vpmovmskb %ymm1,%eax
    0.00 :   48d36d: test   %eax,%eax
    0.00 :   48d36f: jne    48d320 <__strlen_avx2+0x40>
    0.00 :   48d371: vpcmpeqb 0x21(%rdi),%ymm0,%ymm1
    0.00 :   48d376: vpmovmskb %ymm1,%eax
    0.00 :   48d37a: test   %eax,%eax
    0.00 :   48d37c: jne    48d330 <__strlen_avx2+0x50>
    0.00 :   48d37e: vpcmpeqb 0x41(%rdi),%ymm0,%ymm1
    0.00 :   48d383: vpmovmskb %ymm1,%eax
    0.00 :   48d387: test   %eax,%eax
    0.00 :   48d389: jne    48d340 <__strlen_avx2+0x60>
    0.00 :   48d38b: vpcmpeqb 0x61(%rdi),%ymm0,%ymm1
    0.00 :   48d390: vpmovmskb %ymm1,%eax
    0.00 :   48d394: test   %eax,%eax
    0.00 :   48d396: jne    48d350 <__strlen_avx2+0x70>
    0.00 :   48d398: inc    %rdi
    0.00 :   48d39b: or     $0x7f,%rdi
    0.00 :   48d39f: nop
    0.00 :   48d3a0: vmovdqa 0x1(%rdi),%ymm1
    0.00 :   48d3a5: vpminub 0x21(%rdi),%ymm1,%ymm2
    0.00 :   48d3aa: vmovdqa 0x41(%rdi),%ymm3
    0.00 :   48d3af: vpminub 0x61(%rdi),%ymm3,%ymm4
    0.00 :   48d3b4: vpminub %ymm2,%ymm4,%ymm5
    0.00 :   48d3b8: vpcmpeqb %ymm5,%ymm0,%ymm5
    0.00 :   48d3bc: vpmovmskb %ymm5,%ecx
    0.00 :   48d3c0: sub    $0xffffffffffffff80,%rdi
    0.00 :   48d3c4: test   %ecx,%ecx
    0.00 :   48d3c6: je     48d3a0 <__strlen_avx2+0xc0>
    0.00 :   48d3c8: vpcmpeqb %ymm1,%ymm0,%ymm1
    0.00 :   48d3cc: vpmovmskb %ymm1,%eax
    0.00 :   48d3d0: sub    %rdx,%rdi
    0.00 :   48d3d3: test   %eax,%eax
    0.00 :   48d3d5: jne    48d410 <__strlen_avx2+0x130>
    0.00 :   48d3d7: vpcmpeqb %ymm2,%ymm0,%ymm2
    0.00 :   48d3db: vpmovmskb %ymm2,%eax
    0.00 :   48d3df: test   %eax,%eax
    0.00 :   48d3e1: jne    48d420 <__strlen_avx2+0x140>
    0.00 :   48d3e3: vpcmpeqb %ymm3,%ymm0,%ymm3
    0.00 :   48d3e7: vpmovmskb %ymm3,%eax
    0.00 :   48d3eb: shl    $0x20,%rcx
    0.00 :   48d3ef: or     %rcx,%rax
    0.00 :   48d3f2: tzcnt  %rax,%rax
    0.00 :   48d3f7: sub    $0x3f,%rdi
    0.00 :   48d3fb: add    %rdi,%rax
    0.00 :   48d3fe: vzeroupper
    0.00 :   48d401: ret
    0.00 :   48d402: data16 cs nopw 0x0(%rax,%rax,1)
    0.00 :   48d40d: nopl   (%rax)
    0.00 :   48d410: tzcnt  %eax,%eax
    0.00 :   48d414: sub    $0x7f,%rdi
    0.00 :   48d418: add    %rdi,%rax
    0.00 :   48d41b: vzeroupper
    0.00 :   48d41e: ret
    0.00 :   48d41f: nop
    0.00 :   48d420: tzcnt  %eax,%eax
    0.00 :   48d424: sub    $0x5f,%rdi
    0.00 :   48d428: add    %rdi,%rax
    0.00 :   48d42b: vzeroupper
    0.00 :   48d42e: ret
    0.00 :   48d42f: nop
    0.00 :   48d430: or     $0x1f,%rdi
    0.00 :   48d434: vpcmpeqb -0x1f(%rdi),%ymm0,%ymm1
    0.00 :   48d439: vpmovmskb %ymm1,%eax
    0.00 :   48d43d: sarx   %edx,%eax,%eax
    0.00 :   48d442: test   %eax,%eax
    0.00 :   48d444: je     48d364 <__strlen_avx2+0x84>
    0.00 :   48d44a: tzcnt  %eax,%eax
    0.00 :   48d44e: vzeroupper
    0.00 :   48d451: ret
 Percent |	Source code & Disassembly of minisat_HACK_999ED_CSSC_static for cycles:u (1 samples, percent: local period)
---------------------------------------------------------------------------------------------------------------------------
         :
         :
         :
         : 3      Disassembly of section .text:
         :
         : 5      000000000040bc70 <void Minisat::sort<Minisat::Lit, Minisat::LessThan_default<Minisat::Lit> >(Minisat::Lit*, int, Minisat::LessThan_default<Minisat::Lit>) [clone .isra.0]>:
         : 6      }
         : 7      template <class T> static inline void selectionSort(T* array, int size) {
         : 8      selectionSort(array, size, LessThan_default<T>()); }
         :
         : 10     template <class T, class LessThan>
         : 11     void sort(T* array, int size, LessThan lt)
    0.00 :   40bc70: push   %r15
    0.00 :   40bc72: mov    %rdi,%r8
    0.00 :   40bc75: push   %r14
    0.00 :   40bc77: push   %r13
    0.00 :   40bc79: push   %r12
    0.00 :   40bc7b: push   %rbp
    0.00 :   40bc7c: push   %rbx
    0.00 :   40bc7d: mov    %esi,%ebx
    0.00 :   40bc7f: sub    $0x28,%rsp
         : 21     {
         : 22     if (size <= 15)
    0.00 :   40bc83: cmp    $0xf,%esi
    0.00 :   40bc86: jle    40bd00 <void Minisat::sort<Minisat::Lit, Minisat::LessThan_default<Minisat::Lit> >(Minisat::Lit*, int, Minisat::LessThan_default<Minisat::Lit>) [clone .isra.0]+0x90>
         : 25     selectionSort(array, size, lt);
         :
         : 27     else{
         : 28     T           pivot = array[size / 2];
    0.00 :   40bc88: mov    %ebx,%eax
    0.00 :   40bc8a: mov    %r8,%r12
    0.00 :   40bc8d: mov    %ebx,%edx
         : 32     T           tmp;
         : 33     int         i = -1;
    0.00 :   40bc8f: mov    $0xffffffff,%r13d
         : 35     T           pivot = array[size / 2];
    0.00 :   40bc95: sar    %eax
    0.00 :   40bc97: cltq
    0.00 :   40bc99: mov    (%r8,%rax,4),%ecx
    0.00 :   40bc9d: nopl   (%rax)
    0.00 :   40bca0: mov    (%r12),%edi
         : 41     int         j = size;
         :
         : 43     for(;;){
         : 44     do i++; while(lt(array[i], pivot));
    0.00 :   40bca4: add    $0x1,%r13d
    0.00 :   40bca8: mov    %r12,%rbp
    0.00 :   40bcab: cmp    %edi,%ecx
    0.00 :   40bcad: jg     40bcdc <void Minisat::sort<Minisat::Lit, Minisat::LessThan_default<Minisat::Lit> >(Minisat::Lit*, int, Minisat::LessThan_default<Minisat::Lit>) [clone .isra.0]+0x6c>
    0.00 :   40bcaf: movslq %edx,%rax
    0.00 :   40bcb2: lea    -0x4(%r8,%rax,4),%rax
    0.00 :   40bcb7: nopw   0x0(%rax,%rax,1)
         : 52     do j--; while(lt(pivot, array[j]));
    0.00 :   40bcc0: mov    %rax,%rsi
    0.00 :   40bcc3: sub    $0x4,%rax
    0.00 :   40bcc7: sub    $0x1,%edx
    0.00 :   40bcca: cmp    0x4(%rax),%ecx
    0.00 :   40bccd: jl     40bcc0 <void Minisat::sort<Minisat::Lit, Minisat::LessThan_default<Minisat::Lit> >(Minisat::Lit*, int, Minisat::LessThan_default<Minisat::Lit>) [clone .isra.0]+0x50>
         :
         : 59     if (i >= j) break;
    0.00 :   40bccf: cmp    %edx,%r13d
    0.00 :   40bcd2: jge    40bce8 <void Minisat::sort<Minisat::Lit, Minisat::LessThan_default<Minisat::Lit> >(Minisat::Lit*, int, Minisat::LessThan_default<Minisat::Lit>) [clone .isra.0]+0x78>
         :
         : 63     tmp = array[i]; array[i] = array[j]; array[j] = tmp;
    0.00 :   40bcd4: mov    (%rsi),%eax
    0.00 :   40bcd6: mov    %eax,(%r12)
    0.00 :   40bcda: mov    %edi,(%rsi)
         : 67     for(;;){
    0.00 :   40bcdc: add    $0x4,%r12
    0.00 :   40bce0: jmp    40bca0 <void Minisat::sort<Minisat::Lit, Minisat::LessThan_default<Minisat::Lit> >(Minisat::Lit*, int, Minisat::LessThan_default<Minisat::Lit>) [clone .isra.0]+0x30>
    0.00 :   40bce2: nopw   0x0(%rax,%rax,1)
         : 71     }
         :
         : 73     sort(array    , i     , lt);
    0.00 :   40bce8: mov    %r13d,%esi
    0.00 :   40bceb: mov    %r8,%rdi
         : 76     sort(&array[i], size-i, lt);
    0.00 :   40bcee: sub    %r13d,%ebx
         : 78     sort(array    , i     , lt);
    0.00 :   40bcf1: call   40bc70 <void Minisat::sort<Minisat::Lit, Minisat::LessThan_default<Minisat::Lit> >(Minisat::Lit*, int, Minisat::LessThan_default<Minisat::Lit>) [clone .isra.0]>
         : 80     if (size <= 15)
    0.00 :   40bcf6: cmp    $0xf,%ebx
    0.00 :   40bcf9: jle    40bd03 <void Minisat::sort<Minisat::Lit, Minisat::LessThan_default<Minisat::Lit> >(Minisat::Lit*, int, Minisat::LessThan_default<Minisat::Lit>) [clone .isra.0]+0x93>
         : 83     do i++; while(lt(array[i], pivot));
    0.00 :   40bcfb: mov    %r12,%r8
    0.00 :   40bcfe: jmp    40bc88 <void Minisat::sort<Minisat::Lit, Minisat::LessThan_default<Minisat::Lit> >(Minisat::Lit*, int, Minisat::LessThan_default<Minisat::Lit>) [clone .isra.0]+0x18>
         : 86     if (size <= 15)
    0.00 :   40bd00: mov    %rdi,%rbp
         : 88     for (i = 0; i < size-1; i++){
    0.00 :   40bd03: lea    -0x1(%rbx),%eax
    0.00 :   40bd06: mov    %eax,0x1c(%rsp)
    0.00 :   40bd0a: test   %eax,%eax
    0.00 :   40bd0c: jle    40bfae <void Minisat::sort<Minisat::Lit, Minisat::LessThan_default<Minisat::Lit> >(Minisat::Lit*, int, Minisat::LessThan_default<Minisat::Lit>) [clone .isra.0]+0x33e>
    0.00 :   40bd12: mov    %rbp,%rax
    0.00 :   40bd15: mov    $0x5,%r13d
    0.00 :   40bd1b: mov    $0x2,%edi
    0.00 :   40bd20: xor    %ecx,%ecx
    0.00 :   40bd22: movl   $0x7,0x14(%rsp)
    0.00 :   40bd2a: mov    $0x4,%r9d
    0.00 :   40bd30: mov    $0x3,%r8d
    0.00 :   40bd36: movl   $0x6,0x10(%rsp)
    0.00 :   40bd3e: movl   $0xe,0x18(%rsp)
    0.00 :   40bd46: jmp    40bf90 <void Minisat::sort<Minisat::Lit, Minisat::LessThan_default<Minisat::Lit> >(Minisat::Lit*, int, Minisat::LessThan_default<Minisat::Lit>) [clone .isra.0]+0x320>
    0.00 :   40bd4b: nopl   0x0(%rax,%rax,1)
    0.00 :   40bd50: mov    0x4(%rax),%r10d
    0.00 :   40bd54: lea    0x4(%rax),%rdx
         : 106    if (lt(array[j], array[best_i]))
    0.00 :   40bd58: mov    %ecx,%r15d
    0.00 :   40bd5b: mov    %rdx,0x8(%rsp)
    0.00 :   40bd60: cmp    %r11d,%r10d
    0.00 :   40bd63: jl     40bd6e <void Minisat::sort<Minisat::Lit, Minisat::LessThan_default<Minisat::Lit> >(Minisat::Lit*, int, Minisat::LessThan_default<Minisat::Lit>) [clone .isra.0]+0xfe>
    0.00 :   40bd65: mov    %r11d,%r10d
    0.00 :   40bd68: mov    %rax,%rdx
    0.00 :   40bd6b: mov    %esi,%r15d
         : 114    for (j = i+1; j < size; j++){
    0.00 :   40bd6e: mov    %edi,%r14d
    0.00 :   40bd71: cmp    %edi,%ebx
    0.00 :   40bd73: jle    40bf60 <void Minisat::sort<Minisat::Lit, Minisat::LessThan_default<Minisat::Lit> >(Minisat::Lit*, int, Minisat::LessThan_default<Minisat::Lit>) [clone .isra.0]+0x2f0>
    0.00 :   40bd79: mov    0x8(%rax),%r12d
    0.00 :   40bd7d: lea    0x8(%rax),%rdx
         : 120    if (lt(array[j], array[best_i]))
    0.00 :   40bd81: cmp    %r10d,%r12d
    0.00 :   40bd84: jl     40bd94 <void Minisat::sort<Minisat::Lit, Minisat::LessThan_default<Minisat::Lit> >(Minisat::Lit*, int, Minisat::LessThan_default<Minisat::Lit>) [clone .isra.0]+0x124>
    0.00 :   40bd86: movslq %r15d,%rdx
    0.00 :   40bd89: mov    %r10d,%r12d
    0.00 :   40bd8c: mov    %r15d,%r14d
    0.00 :   40bd8f: lea    0x0(%rbp,%rdx,4),%rdx
         : 127    for (j = i+1; j < size; j++){
    0.00 :   40bd94: mov    %r8d,%r15d
    0.00 :   40bd97: cmp    %r8d,%ebx
    0.00 :   40bd9a: jle    40bf60 <void Minisat::sort<Minisat::Lit, Minisat::LessThan_default<Minisat::Lit> >(Minisat::Lit*, int, Minisat::LessThan_default<Minisat::Lit>) [clone .isra.0]+0x2f0>
    0.00 :   40bda0: mov    0xc(%rax),%r10d
    0.00 :   40bda4: lea    0xc(%rax),%rdx
         : 133    if (lt(array[j], array[best_i]))
    0.00 :   40bda8: cmp    %r12d,%r10d
    0.00 :   40bdab: jl     40bdbb <void Minisat::sort<Minisat::Lit, Minisat::LessThan_default<Minisat::Lit> >(Minisat::Lit*, int, Minisat::LessThan_default<Minisat::Lit>) [clone .isra.0]+0x14b>
    0.00 :   40bdad: movslq %r14d,%rdx
    0.00 :   40bdb0: mov    %r12d,%r10d
    0.00 :   40bdb3: mov    %r14d,%r15d
    0.00 :   40bdb6: lea    0x0(%rbp,%rdx,4),%rdx
         : 140    for (j = i+1; j < size; j++){
    0.00 :   40bdbb: mov    %r9d,%r14d
    0.00 :   40bdbe: cmp    %r9d,%ebx
    0.00 :   40bdc1: jle    40bf60 <void Minisat::sort<Minisat::Lit, Minisat::LessThan_default<Minisat::Lit> >(Minisat::Lit*, int, Minisat::LessThan_default<Minisat::Lit>) [clone .isra.0]+0x2f0>
    0.00 :   40bdc7: mov    0x10(%rax),%r12d
    0.00 :   40bdcb: lea    0x10(%rax),%rdx
         : 146    if (lt(array[j], array[best_i]))
    0.00 :   40bdcf: cmp    %r10d,%r12d
    0.00 :   40bdd2: jl     40bde2 <void Minisat::sort<Minisat::Lit, Minisat::LessThan_default<Minisat::Lit> >(Minisat::Lit*, int, Minisat::LessThan_default<Minisat::Lit>) [clone .isra.0]+0x172>
    0.00 :   40bdd4: movslq %r15d,%rdx
    0.00 :   40bdd7: mov    %r10d,%r12d
    0.00 :   40bdda: mov    %r15d,%r14d
    0.00 :   40bddd: lea    0x0(%rbp,%rdx,4),%rdx
         : 153    for (j = i+1; j < size; j++){
    0.00 :   40bde2: mov    %r13d,%r15d
    0.00 :   40bde5: cmp    %ebx,%r13d
    0.00 :   40bde8: jge    40bf60 <void Minisat::sort<Minisat::Lit, Minisat::LessThan_default<Minisat::Lit> >(Minisat::Lit*, int, Minisat::LessThan_default<Minisat::Lit>) [clone .isra.0]+0x2f0>
    0.00 :   40bdee: mov    0x14(%rax),%r10d
    0.00 :   40bdf2: lea    0x14(%rax),%rdx
         : 159    if (lt(array[j], array[best_i]))
    0.00 :   40bdf6: cmp    %r12d,%r10d
    0.00 :   40bdf9: jl     40be09 <void Minisat::sort<Minisat::Lit, Minisat::LessThan_default<Minisat::Lit> >(Minisat::Lit*, int, Minisat::LessThan_default<Minisat::Lit>) [clone .isra.0]+0x199>
    0.00 :   40bdfb: movslq %r14d,%rdx
    0.00 :   40bdfe: mov    %r12d,%r10d
    0.00 :   40be01: mov    %r14d,%r15d
    0.00 :   40be04: lea    0x0(%rbp,%rdx,4),%rdx
         : 166    for (j = i+1; j < size; j++){
    0.00 :   40be09: mov    0x10(%rsp),%r12d
    0.00 :   40be0e: mov    %r12d,%r14d
    0.00 :   40be11: cmp    %r12d,%ebx
    0.00 :   40be14: jle    40bf60 <void Minisat::sort<Minisat::Lit, Minisat::LessThan_default<Minisat::Lit> >(Minisat::Lit*, int, Minisat::LessThan_default<Minisat::Lit>) [clone .isra.0]+0x2f0>
    0.00 :   40be1a: mov    0x18(%rax),%r12d
    0.00 :   40be1e: lea    0x18(%rax),%rdx
         : 173    if (lt(array[j], array[best_i]))
    0.00 :   40be22: cmp    %r12d,%r10d
    0.00 :   40be25: jg     40be35 <void Minisat::sort<Minisat::Lit, Minisat::LessThan_default<Minisat::Lit> >(Minisat::Lit*, int, Minisat::LessThan_default<Minisat::Lit>) [clone .isra.0]+0x1c5>
    0.00 :   40be27: movslq %r15d,%rdx
    0.00 :   40be2a: mov    %r10d,%r12d
    0.00 :   40be2d: mov    %r15d,%r14d
    0.00 :   40be30: lea    0x0(%rbp,%rdx,4),%rdx
         : 180    for (j = i+1; j < size; j++){
    0.00 :   40be35: mov    0x14(%rsp),%r10d
    0.00 :   40be3a: mov    %r10d,%r15d
    0.00 :   40be3d: cmp    %ebx,%r10d
    0.00 :   40be40: jge    40bf60 <void Minisat::sort<Minisat::Lit, Minisat::LessThan_default<Minisat::Lit> >(Minisat::Lit*, int, Minisat::LessThan_default<Minisat::Lit>) [clone .isra.0]+0x2f0>
    0.00 :   40be46: mov    0x1c(%rax),%r10d
    0.00 :   40be4a: lea    0x1c(%rax),%rdx
         : 187    if (lt(array[j], array[best_i]))
    0.00 :   40be4e: cmp    %r10d,%r12d
    0.00 :   40be51: jg     40be61 <void Minisat::sort<Minisat::Lit, Minisat::LessThan_default<Minisat::Lit> >(Minisat::Lit*, int, Minisat::LessThan_default<Minisat::Lit>) [clone .isra.0]+0x1f1>
    0.00 :   40be53: movslq %r14d,%rdx
    0.00 :   40be56: mov    %r12d,%r10d
    0.00 :   40be59: mov    %r14d,%r15d
    0.00 :   40be5c: lea    0x0(%rbp,%rdx,4),%rdx
         : 194    for (j = i+1; j < size; j++){
    0.00 :   40be61: lea    0x8(%rsi),%r14d
    0.00 :   40be65: cmp    %r14d,%ebx
    0.00 :   40be68: jle    40bf60 <void Minisat::sort<Minisat::Lit, Minisat::LessThan_default<Minisat::Lit> >(Minisat::Lit*, int, Minisat::LessThan_default<Minisat::Lit>) [clone .isra.0]+0x2f0>
    0.00 :   40be6e: mov    0x20(%rax),%r12d
    0.00 :   40be72: lea    0x20(%rax),%rdx
         : 200    if (lt(array[j], array[best_i]))
    0.00 :   40be76: cmp    %r12d,%r10d
    0.00 :   40be79: jg     40be89 <void Minisat::sort<Minisat::Lit, Minisat::LessThan_default<Minisat::Lit> >(Minisat::Lit*, int, Minisat::LessThan_default<Minisat::Lit>) [clone .isra.0]+0x219>
    0.00 :   40be7b: movslq %r15d,%rdx
    0.00 :   40be7e: mov    %r10d,%r12d
    0.00 :   40be81: mov    %r15d,%r14d
    0.00 :   40be84: lea    0x0(%rbp,%rdx,4),%rdx
         : 207    for (j = i+1; j < size; j++){
    0.00 :   40be89: lea    0x9(%rsi),%r15d
    0.00 :   40be8d: cmp    %r15d,%ebx
    0.00 :   40be90: jle    40bf60 <void Minisat::sort<Minisat::Lit, Minisat::LessThan_default<Minisat::Lit> >(Minisat::Lit*, int, Minisat::LessThan_default<Minisat::Lit>) [clone .isra.0]+0x2f0>
    0.00 :   40be96: mov    0x24(%rax),%r10d
    0.00 :   40be9a: lea    0x24(%rax),%rdx
         : 213    if (lt(array[j], array[best_i]))
    0.00 :   40be9e: cmp    %r10d,%r12d
    0.00 :   40bea1: jg     40beb1 <void Minisat::sort<Minisat::Lit, Minisat::LessThan_default<Minisat::Lit> >(Minisat::Lit*, int, Minisat::LessThan_default<Minisat::Lit>) [clone .isra.0]+0x241>
    0.00 :   40bea3: movslq %r14d,%rdx
    0.00 :   40bea6: mov    %r12d,%r10d
    0.00 :   40bea9: mov    %r14d,%r15d
    0.00 :   40beac: lea    0x0(%rbp,%rdx,4),%rdx
         : 220    for (j = i+1; j < size; j++){
    0.00 :   40beb1: lea    0xa(%rsi),%r14d
    0.00 :   40beb5: cmp    %r14d,%ebx
    0.00 :   40beb8: jle    40bf60 <void Minisat::sort<Minisat::Lit, Minisat::LessThan_default<Minisat::Lit> >(Minisat::Lit*, int, Minisat::LessThan_default<Minisat::Lit>) [clone .isra.0]+0x2f0>
    0.00 :   40bebe: mov    0x28(%rax),%r12d
    0.00 :   40bec2: lea    0x28(%rax),%rdx
         : 226    if (lt(array[j], array[best_i]))
    0.00 :   40bec6: cmp    %r12d,%r10d
    0.00 :   40bec9: jg     40bed9 <void Minisat::sort<Minisat::Lit, Minisat::LessThan_default<Minisat::Lit> >(Minisat::Lit*, int, Minisat::LessThan_default<Minisat::Lit>) [clone .isra.0]+0x269>
    0.00 :   40becb: movslq %r15d,%rdx
    0.00 :   40bece: mov    %r10d,%r12d
    0.00 :   40bed1: mov    %r15d,%r14d
    0.00 :   40bed4: lea    0x0(%rbp,%rdx,4),%rdx
         : 233    for (j = i+1; j < size; j++){
    0.00 :   40bed9: lea    0xb(%rsi),%r15d
    0.00 :   40bedd: cmp    %r15d,%ebx
    0.00 :   40bee0: jle    40bf60 <void Minisat::sort<Minisat::Lit, Minisat::LessThan_default<Minisat::Lit> >(Minisat::Lit*, int, Minisat::LessThan_default<Minisat::Lit>) [clone .isra.0]+0x2f0>
    0.00 :   40bee2: mov    0x2c(%rax),%r10d
    0.00 :   40bee6: lea    0x2c(%rax),%rdx
         : 239    if (lt(array[j], array[best_i]))
    0.00 :   40beea: cmp    %r10d,%r12d
    0.00 :   40beed: jg     40befd <void Minisat::sort<Minisat::Lit, Minisat::LessThan_default<Minisat::Lit> >(Minisat::Lit*, int, Minisat::LessThan_default<Minisat::Lit>) [clone .isra.0]+0x28d>
    0.00 :   40beef: movslq %r14d,%rdx
    0.00 :   40bef2: mov    %r12d,%r10d
    0.00 :   40bef5: mov    %r14d,%r15d
    0.00 :   40bef8: lea    0x0(%rbp,%rdx,4),%rdx
         : 246    for (j = i+1; j < size; j++){
    0.00 :   40befd: lea    0xc(%rsi),%r14d
    0.00 :   40bf01: cmp    %r14d,%ebx
    0.00 :   40bf04: jle    40bf60 <void Minisat::sort<Minisat::Lit, Minisat::LessThan_default<Minisat::Lit> >(Minisat::Lit*, int, Minisat::LessThan_default<Minisat::Lit>) [clone .isra.0]+0x2f0>
    0.00 :   40bf06: mov    0x30(%rax),%r12d
    0.00 :   40bf0a: lea    0x30(%rax),%rdx
         : 252    if (lt(array[j], array[best_i]))
    0.00 :   40bf0e: cmp    %r12d,%r10d
    0.00 :   40bf11: jg     40bf21 <void Minisat::sort<Minisat::Lit, Minisat::LessThan_default<Minisat::Lit> >(Minisat::Lit*, int, Minisat::LessThan_default<Minisat::Lit>) [clone .isra.0]+0x2b1>
    0.00 :   40bf13: movslq %r15d,%rdx
    0.00 :   40bf16: mov    %r10d,%r12d
    0.00 :   40bf19: mov    %r15d,%r14d
    0.00 :   40bf1c: lea    0x0(%rbp,%rdx,4),%rdx
         : 259    for (j = i+1; j < size; j++){
    0.00 :   40bf21: add    $0xd,%esi
    0.00 :   40bf24: cmp    %esi,%ebx
    0.00 :   40bf26: jle    40bf60 <void Minisat::sort<Minisat::Lit, Minisat::LessThan_default<Minisat::Lit> >(Minisat::Lit*, int, Minisat::LessThan_default<Minisat::Lit>) [clone .isra.0]+0x2f0>
    0.00 :   40bf28: mov    0x34(%rax),%r10d
    0.00 :   40bf2c: lea    0x34(%rax),%rdx
         : 265    if (lt(array[j], array[best_i]))
    0.00 :   40bf30: cmp    %r10d,%r12d
    0.00 :   40bf33: jg     40bf43 <void Minisat::sort<Minisat::Lit, Minisat::LessThan_default<Minisat::Lit> >(Minisat::Lit*, int, Minisat::LessThan_default<Minisat::Lit>) [clone .isra.0]+0x2d3>
    0.00 :   40bf35: movslq %r14d,%rdx
    0.00 :   40bf38: mov    %r12d,%r10d
    0.00 :   40bf3b: mov    %r14d,%esi
    0.00 :   40bf3e: lea    0x0(%rbp,%rdx,4),%rdx
         : 272    for (j = i+1; j < size; j++){
    0.00 :   40bf43: cmp    0x18(%rsp),%ebx
    0.00 :   40bf47: jle    40bf60 <void Minisat::sort<Minisat::Lit, Minisat::LessThan_default<Minisat::Lit> >(Minisat::Lit*, int, Minisat::LessThan_default<Minisat::Lit>) [clone .isra.0]+0x2f0>
    0.00 :   40bf49: lea    0x38(%rax),%rdx
         : 276    if (lt(array[j], array[best_i]))
    0.00 :   40bf4d: cmp    %r10d,0x38(%rax)
    0.00 :   40bf51: jl     40bf60 <void Minisat::sort<Minisat::Lit, Minisat::LessThan_default<Minisat::Lit> >(Minisat::Lit*, int, Minisat::LessThan_default<Minisat::Lit>) [clone .isra.0]+0x2f0>
    0.00 :   40bf53: movslq %esi,%rsi
    0.00 :   40bf56: lea    0x0(%rbp,%rsi,4),%rdx
         : 281    for (j = i+1; j < size; j++){
    0.00 :   40bf5b: nopl   0x0(%rax,%rax,1)
         : 283    tmp = array[i]; array[i] = array[best_i]; array[best_i] = tmp;
    0.00 :   40bf60: mov    (%rdx),%esi
         : 285    for (i = 0; i < size-1; i++){
  100.00 :   40bf62: addl   $0x1,0x18(%rsp)
    0.00 :   40bf67: add    $0x1,%edi
    0.00 :   40bf6a: add    $0x1,%r8d
    0.00 :   40bf6e: addl   $0x1,0x10(%rsp)
    0.00 :   40bf73: add    $0x1,%r9d
    0.00 :   40bf77: add    $0x1,%r13d
         : 292    tmp = array[i]; array[i] = array[best_i]; array[best_i] = tmp;
    0.00 :   40bf7b: mov    %esi,(%rax)
         : 294    for (i = 0; i < size-1; i++){
    0.00 :   40bf7d: mov    0x8(%rsp),%rax
    0.00 :   40bf82: addl   $0x1,0x14(%rsp)
         : 297    tmp = array[i]; array[i] = array[best_i]; array[best_i] = tmp;
    0.00 :   40bf87: mov    %r11d,(%rdx)
         : 299    for (i = 0; i < size-1; i++){
    0.00 :   40bf8a: cmp    0x1c(%rsp),%ecx
    0.00 :   40bf8e: je     40bfae <void Minisat::sort<Minisat::Lit, Minisat::LessThan_default<Minisat::Lit> >(Minisat::Lit*, int, Minisat::LessThan_default<Minisat::Lit>) [clone .isra.0]+0x33e>
    0.00 :   40bf90: mov    %ecx,%esi
         : 303    for (j = i+1; j < size; j++){
    0.00 :   40bf92: add    $0x1,%ecx
         : 305    tmp = array[i]; array[i] = array[best_i]; array[best_i] = tmp;
    0.00 :   40bf95: mov    (%rax),%r11d
         : 307    for (j = i+1; j < size; j++){
    0.00 :   40bf98: cmp    %ebx,%ecx
    0.00 :   40bf9a: jl     40bd50 <void Minisat::sort<Minisat::Lit, Minisat::LessThan_default<Minisat::Lit> >(Minisat::Lit*, int, Minisat::LessThan_default<Minisat::Lit>) [clone .isra.0]+0xe0>
    0.00 :   40bfa0: lea    0x4(%rax),%rsi
    0.00 :   40bfa4: mov    %rax,%rdx
    0.00 :   40bfa7: mov    %rsi,0x8(%rsp)
    0.00 :   40bfac: jmp    40bf60 <void Minisat::sort<Minisat::Lit, Minisat::LessThan_default<Minisat::Lit> >(Minisat::Lit*, int, Minisat::LessThan_default<Minisat::Lit>) [clone .isra.0]+0x2f0>
         : 314    }
         : 315    }
    0.00 :   40bfae: add    $0x28,%rsp
    0.00 :   40bfb2: pop    %rbx
    0.00 :   40bfb3: pop    %rbp
    0.00 :   40bfb4: pop    %r12
    0.00 :   40bfb6: pop    %r13
    0.00 :   40bfb8: pop    %r14
    0.00 :   40bfba: pop    %r15
    0.00 :   40bfbc: ret
 Percent |	Source code & Disassembly of minisat_HACK_999ED_CSSC_static for cycles:u (1 samples, percent: local period)
---------------------------------------------------------------------------------------------------------------------------
         :
         :
         :
         : 3      Disassembly of section .text:
         :
         : 5      000000000043e940 <handle_amd>:
    0.00 :   43e940: push   %rbx
    0.00 :   43e941: mov    $0x80000000,%eax
    0.00 :   43e946: cpuid
    0.00 :   43e948: xor    %edx,%edx
    0.00 :   43e94a: cmp    $0xbe,%edi
    0.00 :   43e950: setg   %dl
    0.00 :   43e953: xor    %r8d,%r8d
    0.00 :   43e956: sub    $0x7ffffffb,%edx
    0.00 :   43e95c: cmp    %eax,%edx
    0.00 :   43e95e: ja     43e99a <handle_amd+0x5a>
    0.00 :   43e960: mov    %edi,%esi
    0.00 :   43e962: mov    %edx,%eax
    0.00 :   43e964: cpuid
  100.00 :   43e966: cmp    $0xbb,%edi
    0.00 :   43e96c: jle    43e99f <handle_amd+0x5f>
    0.00 :   43e96e: sub    $0xbd,%esi
    0.00 :   43e974: cmp    $0x7,%esi
    0.00 :   43e977: ja     43eacf <handle_amd+0x18f>
    0.00 :   43e97d: lea    0xb88fc(%rip),%rdi        # 4f7280 <terminator.3+0x10>
    0.00 :   43e984: movslq (%rdi,%rsi,4),%rax
    0.00 :   43e988: add    %rdi,%rax
    0.00 :   43e98b: notrack jmp *%rax
    0.00 :   43e98e: xor    %r8d,%r8d
    0.00 :   43e991: test   $0xf0,%ch
    0.00 :   43e994: je     43e99a <handle_amd+0x5a>
    0.00 :   43e996: movzbl %cl,%r8d
    0.00 :   43e99a: mov    %r8,%rax
    0.00 :   43e99d: pop    %rbx
    0.00 :   43e99e: ret
    0.00 :   43e99f: add    $0x3,%esi
    0.00 :   43e9a2: mov    %edx,%ecx
    0.00 :   43e9a4: jmp    43e96e <handle_amd+0x2e>
    0.00 :   43e9a6: shr    $0x10,%ecx
    0.00 :   43e9a9: movzbl %cl,%r8d
    0.00 :   43e9ad: cmp    $0xff,%r8d
    0.00 :   43e9b4: jne    43e99a <handle_amd+0x5a>
    0.00 :   43e9b6: lea    0x0(,%rcx,4),%r8d
    0.00 :   43e9be: and    $0x3fc00,%r8d
    0.00 :   43e9c5: jmp    43e99a <handle_amd+0x5a>
    0.00 :   43e9c7: xor    %r8d,%r8d
    0.00 :   43e9ca: test   $0xf0,%ch
    0.00 :   43e9cd: je     43e99a <handle_amd+0x5a>
    0.00 :   43e9cf: shr    $0x6,%ecx
    0.00 :   43e9d2: mov    %ecx,%r8d
    0.00 :   43e9d5: and    $0x3fffc00,%r8d
    0.00 :   43e9dc: jmp    43e99a <handle_amd+0x5a>
    0.00 :   43e9de: mov    %ecx,%r8d
    0.00 :   43e9e1: lea    0xb88b8(%rip),%rsi        # 4f72a0 <terminator.3+0x30>
    0.00 :   43e9e8: shr    $0xc,%r8d
    0.00 :   43e9ec: mov    %r8d,%edx
    0.00 :   43e9ef: and    $0xf,%edx
    0.00 :   43e9f2: movslq (%rsi,%rdx,4),%rax
    0.00 :   43e9f6: add    %rsi,%rax
    0.00 :   43e9f9: notrack jmp *%rax
    0.00 :   43e9fc: xor    %r8d,%r8d
    0.00 :   43e9ff: test   $0xf0,%dh
    0.00 :   43ea02: je     43e99a <handle_amd+0x5a>
    0.00 :   43ea04: lea    (%rdx,%rdx,1),%r8d
    0.00 :   43ea08: and    $0x7ff80000,%r8d
    0.00 :   43ea0f: jmp    43e99a <handle_amd+0x5a>
    0.00 :   43ea11: mov    %edx,%r8d
    0.00 :   43ea14: lea    0xb88c5(%rip),%rcx        # 4f72e0 <terminator.3+0x70>
    0.00 :   43ea1b: shr    $0xc,%r8d
    0.00 :   43ea1f: and    $0xf,%r8d
    0.00 :   43ea23: movslq (%rcx,%r8,4),%rax
    0.00 :   43ea27: add    %rcx,%rax
    0.00 :   43ea2a: notrack jmp *%rax
    0.00 :   43ea2d: xor    %r8d,%r8d
    0.00 :   43ea30: test   $0xf0,%dh
    0.00 :   43ea33: je     43e99a <handle_amd+0x5a>
    0.00 :   43ea39: movzbl %dl,%r8d
    0.00 :   43ea3d: jmp    43e99a <handle_amd+0x5a>
    0.00 :   43ea42: mov    %rdx,%r8
    0.00 :   43ea45: jmp    43e99a <handle_amd+0x5a>
    0.00 :   43ea4a: xor    %r8d,%r8d
    0.00 :   43ea4d: jmp    43e99a <handle_amd+0x5a>
    0.00 :   43ea52: mov    $0x10,%r8d
    0.00 :   43ea58: jmp    43e99a <handle_amd+0x5a>
    0.00 :   43ea5d: mov    $0x60,%r8d
    0.00 :   43ea63: jmp    43e99a <handle_amd+0x5a>
    0.00 :   43ea68: mov    $0x40,%r8d
    0.00 :   43ea6e: jmp    43e99a <handle_amd+0x5a>
    0.00 :   43ea73: mov    $0x30,%r8d
    0.00 :   43ea79: jmp    43e99a <handle_amd+0x5a>
    0.00 :   43ea7e: mov    $0x20,%r8d
    0.00 :   43ea84: jmp    43e99a <handle_amd+0x5a>
    0.00 :   43ea89: mov    $0x8,%r8d
    0.00 :   43ea8f: jmp    43e99a <handle_amd+0x5a>
    0.00 :   43ea94: mov    $0x80,%r8d
    0.00 :   43ea9a: jmp    43e99a <handle_amd+0x5a>
    0.00 :   43ea9f: mov    %ecx,%eax
    0.00 :   43eaa1: xor    %edx,%edx
    0.00 :   43eaa3: movzbl %cl,%ecx
    0.00 :   43eaa6: shr    $0x6,%eax
    0.00 :   43eaa9: and    $0x3fffc00,%eax
    0.00 :   43eaae: div    %ecx
    0.00 :   43eab0: mov    %eax,%r8d
    0.00 :   43eab3: jmp    43e99a <handle_amd+0x5a>
    0.00 :   43eab8: lea    (%rdx,%rdx,1),%eax
    0.00 :   43eabb: movzbl %dl,%ecx
    0.00 :   43eabe: xor    %edx,%edx
    0.00 :   43eac0: and    $0x7ff80000,%eax
    0.00 :   43eac5: div    %ecx
    0.00 :   43eac7: mov    %eax,%r8d
    0.00 :   43eaca: jmp    43e99a <handle_amd+0x5a>
    0.00 :   43eacf: shr    $0xe,%ecx
    0.00 :   43ead2: mov    %ecx,%r8d
    0.00 :   43ead5: and    $0x3fc00,%r8d
    0.00 :   43eadc: jmp    43e99a <handle_amd+0x5a>
 Percent |	Source code & Disassembly of minisat_HACK_999ED_CSSC_static for cycles:u (1 samples, percent: local period)
---------------------------------------------------------------------------------------------------------------------------
         :
         :
         :
         : 3      Disassembly of section .text:
         :
         : 5      00000000004a1300 <__tunables_init>:
    0.00 :   4a1300: endbr64
    0.00 :   4a1304: push   %r15
    0.00 :   4a1306: push   %r14
    0.00 :   4a1308: push   %r13
    0.00 :   4a130a: push   %r12
    0.00 :   4a130c: push   %rbp
    0.00 :   4a130d: mov    %rdi,%rbp
    0.00 :   4a1310: push   %rbx
    0.00 :   4a1311: sub    $0x28,%rsp
    0.00 :   4a1315: mov    0x8f775(%rip),%eax        # 530a90 <__libc_enable_secure>
    0.00 :   4a131b: test   %eax,%eax
    0.00 :   4a131d: jne    4a15b5 <__tunables_init+0x2b5>
    0.00 :   4a1323: lea    0x8e7d6(%rip),%rbx        # 52fb00 <tunable_list>
    0.00 :   4a132a: mov    $0xffffffffffffffa8,%r12
    0.00 :   4a1331: sub    %rbx,%r12
    0.00 :   4a1334: nopl   0x0(%rax)
    0.00 :   4a1338: test   %rbp,%rbp
    0.00 :   4a133b: je     4a137d <__tunables_init+0x7d>
    0.00 :   4a133d: mov    0x0(%rbp),%r9
    0.00 :   4a1341: test   %r9,%r9
    0.00 :   4a1344: je     4a137d <__tunables_init+0x7d>
    0.00 :   4a1346: movzbl (%r9),%edx
    0.00 :   4a134a: lea    0x8(%rbp),%r13
    0.00 :   4a134e: cmp    $0x3d,%dl
    0.00 :   4a1351: je     4a138c <__tunables_init+0x8c>
    0.00 :   4a1353: test   %dl,%dl
    0.00 :   4a1355: je     4a138c <__tunables_init+0x8c>
    0.00 :   4a1357: mov    $0x1,%eax
    0.00 :   4a135c: jmp    4a1365 <__tunables_init+0x65>
    0.00 :   4a135e: xchg   %ax,%ax
    0.00 :   4a1360: cmp    $0x3d,%dl
    0.00 :   4a1363: je     4a1390 <__tunables_init+0x90>
    0.00 :   4a1365: movzbl (%r9,%rax,1),%edx
    0.00 :   4a136a: mov    %rax,%rcx
    0.00 :   4a136d: add    $0x1,%rax
    0.00 :   4a1371: test   %dl,%dl
    0.00 :   4a1373: jne    4a1360 <__tunables_init+0x60>
    0.00 :   4a1375: mov    %r13,%rbp
    0.00 :   4a1378: test   %rbp,%rbp
    0.00 :   4a137b: jne    4a133d <__tunables_init+0x3d>
    0.00 :   4a137d: add    $0x28,%rsp
    0.00 :   4a1381: pop    %rbx
    0.00 :   4a1382: pop    %rbp
    0.00 :   4a1383: pop    %r12
    0.00 :   4a1385: pop    %r13
    0.00 :   4a1387: pop    %r14
    0.00 :   4a1389: pop    %r15
    0.00 :   4a138b: ret
    0.00 :   4a138c: xor    %ecx,%ecx
    0.00 :   4a138e: xchg   %ax,%ax
    0.00 :   4a1390: test   %dl,%dl
    0.00 :   4a1392: je     4a1375 <__tunables_init+0x75>
    0.00 :   4a1394: lea    0x1(%rcx),%r14
    0.00 :   4a1398: mov    %r9,%rax
    0.00 :   4a139b: lea    0x5e86a(%rip),%rsi        # 4ffc0c <__rseq_flags+0x4>
    0.00 :   4a13a2: mov    $0x47,%ecx
    0.00 :   4a13a7: lea    (%r9,%r14,1),%r15
    0.00 :   4a13ab: jmp    4a13cb <__tunables_init+0xcb>
    0.00 :   4a13ad: nopl   (%rax)
    0.00 :   4a13b0: cmp    %cl,%dl
    0.00 :   4a13b2: jne    4a13d2 <__tunables_init+0xd2>
    0.00 :   4a13b4: movzbl 0x1(%rsi),%ecx
    0.00 :   4a13b8: add    $0x1,%rsi
    0.00 :   4a13bc: lea    0x1(%rax),%rdx
    0.00 :   4a13c0: test   %cl,%cl
    0.00 :   4a13c2: je     4a149c <__tunables_init+0x19c>
    0.00 :   4a13c8: mov    %rdx,%rax
    0.00 :   4a13cb: movzbl (%rax),%edx
    0.00 :   4a13ce: test   %dl,%dl
    0.00 :   4a13d0: jne    4a13b0 <__tunables_init+0xb0>
    0.00 :   4a13d2: mov    0x8f6b7(%rip),%r11d        # 530a90 <__libc_enable_secure>
    0.00 :   4a13d9: lea    0x8e778(%rip),%r8        # 52fb58 <tunable_list+0x58>
    0.00 :   4a13e0: xor    %r10d,%r10d
    0.00 :   4a13e3: jmp    4a13fa <__tunables_init+0xfa>
    0.00 :   4a13e5: nopl   (%rax)
    0.00 :   4a13e8: add    $0x1,%r10d
  100.00 :   4a13ec: add    $0x70,%r8
    0.00 :   4a13f0: cmp    $0x23,%r10d
    0.00 :   4a13f4: je     4a1375 <__tunables_init+0x75>
    0.00 :   4a13fa: cmpb   $0x0,-0x8(%r8)
    0.00 :   4a13ff: jne    4a13e8 <__tunables_init+0xe8>
    0.00 :   4a1401: movzbl (%r8),%edi
    0.00 :   4a1405: test   %dil,%dil
    0.00 :   4a1408: je     4a13e8 <__tunables_init+0xe8>
    0.00 :   4a140a: lea    (%r12,%r8,1),%r14
    0.00 :   4a140e: mov    %r8,%rsi
    0.00 :   4a1411: mov    %r9,%rax
    0.00 :   4a1414: mov    %edi,%edx
    0.00 :   4a1416: cs nopw 0x0(%rax,%rax,1)
    0.00 :   4a1420: movzbl (%rax),%ecx
    0.00 :   4a1423: cmp    %dl,%cl
    0.00 :   4a1425: jne    4a13e8 <__tunables_init+0xe8>
    0.00 :   4a1427: test   %cl,%cl
    0.00 :   4a1429: je     4a13e8 <__tunables_init+0xe8>
    0.00 :   4a142b: movzbl 0x1(%rsi),%edx
    0.00 :   4a142f: add    $0x1,%rsi
    0.00 :   4a1433: add    $0x1,%rax
    0.00 :   4a1437: test   %dl,%dl
    0.00 :   4a1439: jne    4a1420 <__tunables_init+0x120>
    0.00 :   4a143b: cmpb   $0x3d,(%rax)
    0.00 :   4a143e: jne    4a13e8 <__tunables_init+0xe8>
    0.00 :   4a1440: test   %r11d,%r11d
    0.00 :   4a1443: je     4a1456 <__tunables_init+0x156>
    0.00 :   4a1445: mov    -0x4(%r8),%eax
    0.00 :   4a1449: test   %eax,%eax
    0.00 :   4a144b: je     4a1520 <__tunables_init+0x220>
    0.00 :   4a1451: cmp    $0x2,%eax
    0.00 :   4a1454: jne    4a13e8 <__tunables_init+0xe8>
    0.00 :   4a1456: movslq %r10d,%r10
    0.00 :   4a1459: lea    0x0(,%r10,8),%rax
    0.00 :   4a1461: sub    %r10,%rax
    0.00 :   4a1464: shl    $0x4,%rax
    0.00 :   4a1468: cmpl   $0x3,0x30(%rbx,%rax,1)
    0.00 :   4a146d: je     4a1516 <__tunables_init+0x216>
    0.00 :   4a1473: xor    %esi,%esi
    0.00 :   4a1475: mov    %r15,%rdi
    0.00 :   4a1478: call   4d5a70 <_dl_strtoul>
    0.00 :   4a147d: mov    %rax,0x18(%rsp)
    0.00 :   4a1482: lea    0x18(%rsp),%rsi
    0.00 :   4a1487: lea    (%rbx,%r14,1),%rdi
    0.00 :   4a148b: xor    %ecx,%ecx
    0.00 :   4a148d: xor    %edx,%edx
    0.00 :   4a148f: call   4a0cb0 <do_tunable_update_val>
    0.00 :   4a1494: mov    %r13,%rbp
    0.00 :   4a1497: jmp    4a1338 <__tunables_init+0x38>
    0.00 :   4a149c: cmpb   $0x3d,0x1(%rax)
    0.00 :   4a14a0: jne    4a13d2 <__tunables_init+0xd2>
    0.00 :   4a14a6: xor    %eax,%eax
    0.00 :   4a14a8: nopl   0x0(%rax,%rax,1)
    0.00 :   4a14b0: mov    %rax,%rdx
    0.00 :   4a14b3: add    $0x1,%rax
    0.00 :   4a14b7: cmpb   $0x0,-0x1(%r9,%rax,1)
    0.00 :   4a14bd: jne    4a14b0 <__tunables_init+0x1b0>
    0.00 :   4a14bf: lea    0x2(%rdx),%rdi
    0.00 :   4a14c3: mov    %r9,0x8(%rsp)
    0.00 :   4a14c8: mov    %rdx,(%rsp)
    0.00 :   4a14cc: call   4d56f0 <__minimal_malloc>
    0.00 :   4a14d1: mov    (%rsp),%rdx
    0.00 :   4a14d5: mov    0x8(%rsp),%r9
    0.00 :   4a14da: test   %rax,%rax
    0.00 :   4a14dd: je     4a15e3 <__tunables_init+0x2e3>
    0.00 :   4a14e3: nopl   0x0(%rax,%rax,1)
    0.00 :   4a14e8: movzbl (%r9,%rdx,1),%ecx
    0.00 :   4a14ed: mov    %cl,(%rax,%rdx,1)
    0.00 :   4a14f0: sub    $0x1,%rdx
    0.00 :   4a14f4: jae    4a14e8 <__tunables_init+0x1e8>
    0.00 :   4a14f6: lea    (%rax,%r14,1),%rdi
    0.00 :   4a14fa: mov    %r15,%rsi
    0.00 :   4a14fd: mov    %rax,(%rsp)
    0.00 :   4a1501: call   4a0da0 <parse_tunables>
    0.00 :   4a1506: mov    (%rsp),%rax
    0.00 :   4a150a: mov    %rax,0x0(%rbp)
    0.00 :   4a150e: mov    %r13,%rbp
    0.00 :   4a1511: jmp    4a1338 <__tunables_init+0x38>
    0.00 :   4a1516: mov    %r15,0x18(%rsp)
    0.00 :   4a151b: jmp    4a1482 <__tunables_init+0x182>
    0.00 :   4a1520: mov    0x0(%rbp),%rax
    0.00 :   4a1524: mov    %rbp,%rsi
    0.00 :   4a1527: mov    %rbp,%r13
    0.00 :   4a152a: test   %rax,%rax
    0.00 :   4a152d: je     4a13e8 <__tunables_init+0xe8>
    0.00 :   4a1533: mov    %r8,%rcx
    0.00 :   4a1536: test   %dil,%dil
    0.00 :   4a1539: jne    4a1556 <__tunables_init+0x256>
    0.00 :   4a153b: jmp    4a1580 <__tunables_init+0x280>
    0.00 :   4a153d: nopl   (%rax)
    0.00 :   4a1540: cmp    %dl,%dil
    0.00 :   4a1543: jne    4a155d <__tunables_init+0x25d>
    0.00 :   4a1545: movzbl 0x1(%rcx),%edi
    0.00 :   4a1549: add    $0x1,%rcx
    0.00 :   4a154d: add    $0x1,%rax
    0.00 :   4a1551: test   %dil,%dil
    0.00 :   4a1554: je     4a1580 <__tunables_init+0x280>
    0.00 :   4a1556: movzbl (%rax),%edx
    0.00 :   4a1559: test   %dl,%dl
    0.00 :   4a155b: jne    4a1540 <__tunables_init+0x240>
    0.00 :   4a155d: mov    0x8(%rsi),%rax
    0.00 :   4a1561: add    $0x8,%rsi
    0.00 :   4a1565: test   %rax,%rax
    0.00 :   4a1568: je     4a15a9 <__tunables_init+0x2a9>
    0.00 :   4a156a: movzbl (%r8),%edi
    0.00 :   4a156e: mov    %r8,%rcx
    0.00 :   4a1571: test   %dil,%dil
    0.00 :   4a1574: jne    4a1556 <__tunables_init+0x256>
    0.00 :   4a1576: cs nopw 0x0(%rax,%rax,1)
    0.00 :   4a1580: cmpb   $0x3d,(%rax)
    0.00 :   4a1583: jne    4a155d <__tunables_init+0x25d>
    0.00 :   4a1585: mov    %rsi,%rax
    0.00 :   4a1588: nopl   0x0(%rax,%rax,1)
    0.00 :   4a1590: mov    0x8(%rax),%rdx
    0.00 :   4a1594: add    $0x8,%rax
    0.00 :   4a1598: mov    %rdx,-0x8(%rax)
    0.00 :   4a159c: test   %rdx,%rdx
    0.00 :   4a159f: jne    4a1590 <__tunables_init+0x290>
    0.00 :   4a15a1: mov    (%rsi),%rax
    0.00 :   4a15a4: test   %rax,%rax
    0.00 :   4a15a7: jne    4a156a <__tunables_init+0x26a>
    0.00 :   4a15a9: mov    -0x4(%r8),%eax
    0.00 :   4a15ad: mov    %rbp,%r13
    0.00 :   4a15b0: jmp    4a1451 <__tunables_init+0x151>
    0.00 :   4a15b5: xor    %esi,%esi
    0.00 :   4a15b7: lea    0x5e65d(%rip),%rdi        # 4ffc1b <__rseq_flags+0x13>
    0.00 :   4a15be: mov    $0x15,%eax
    0.00 :   4a15c3: syscall
    0.00 :   4a15c5: test   %eax,%eax
    0.00 :   4a15c7: je     4a15d4 <__tunables_init+0x2d4>
    0.00 :   4a15c9: cmp    $0xfffff000,%eax
    0.00 :   4a15ce: ja     4a1323 <__tunables_init+0x23>
    0.00 :   4a15d4: movl   $0x2,0x8f456(%rip)        # 530a34 <tunable_list+0xf34>
    0.00 :   4a15de: jmp    4a1323 <__tunables_init+0x23>
    0.00 :   4a15e3: lea    0x5e666(%rip),%rdi        # 4ffc50 <__rseq_flags+0x48>
    0.00 :   4a15ea: call   4d6b60 <_dl_fatal_printf>
